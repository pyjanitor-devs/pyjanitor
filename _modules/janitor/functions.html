
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>janitor.functions &#8212; pyjanitor  documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for janitor.functions</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; General purpose data cleaning functions. &quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">unicodedata</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">fnmatch</span> <span class="kn">import</span> <span class="n">translate</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Pattern</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pandas_flavor</span> <span class="k">as</span> <span class="nn">pf</span>
<span class="kn">from</span> <span class="nn">natsort</span> <span class="kn">import</span> <span class="n">index_natsorted</span>
<span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">union_categoricals</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="n">OutOfBoundsDatetime</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">mode</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">LabelEncoder</span>

<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">JanitorError</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_check_instance</span><span class="p">,</span>
    <span class="n">_clean_accounting_column</span><span class="p">,</span>
    <span class="n">_complete_groupings</span><span class="p">,</span>
    <span class="n">_computations_pivot_longer</span><span class="p">,</span>
    <span class="n">_computations_pivot_wider</span><span class="p">,</span>
    <span class="n">_currency_column_to_numeric</span><span class="p">,</span>
    <span class="n">_data_checks_pivot_longer</span><span class="p">,</span>
    <span class="n">_data_checks_pivot_wider</span><span class="p">,</span>
    <span class="n">_grid_computation</span><span class="p">,</span>
    <span class="n">_pivot_longer_pattern_match</span><span class="p">,</span>
    <span class="n">_replace_empty_string_with_none</span><span class="p">,</span>
    <span class="n">_replace_original_empty_string_with_none</span><span class="p">,</span>
    <span class="n">_strip_underscores</span><span class="p">,</span>
    <span class="n">check</span><span class="p">,</span>
    <span class="n">check_column</span><span class="p">,</span>
    <span class="n">deprecated_alias</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="unionize_dataframe_categories"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.unionize_dataframe_categories.html#janitor.unionize_dataframe_categories">[docs]</a><span class="k">def</span> <span class="nf">unionize_dataframe_categories</span><span class="p">(</span>
    <span class="o">*</span><span class="n">dataframes</span><span class="p">,</span> <span class="n">column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a group of dataframes which contain some categorical columns, for</span>
<span class="sd">    each categorical column present, find all the possible categories across</span>
<span class="sd">    all the dataframes which have that column.</span>
<span class="sd">    Update each dataframes&#39; corresponding column with a new categorical object</span>
<span class="sd">    that contains the original data</span>
<span class="sd">    but has labels for all the possible categories from all dataframes.</span>
<span class="sd">    This is useful when concatenating a list of dataframes which all have the</span>
<span class="sd">    same categorical columns into one dataframe.</span>

<span class="sd">    If, for a given categorical column, all input dataframes do not have at</span>
<span class="sd">    least one instance of all the possible categories,</span>
<span class="sd">    Pandas will change the output dtype of that column from ``category`` to</span>
<span class="sd">    ``object``, losing out on dramatic speed gains you get from the former</span>
<span class="sd">    format.</span>

<span class="sd">    Usage example for concatenation of categorical column-containing</span>
<span class="sd">    dataframes:</span>

<span class="sd">    Instead of:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        concatenated_df = pd.concat([df1, df2, df3], ignore_index=True)</span>

<span class="sd">    which in your case has resulted in ``category`` -&gt; ``object`` conversion,</span>
<span class="sd">    use:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        unionized_dataframes = unionize_dataframe_categories(df1, df2, df2)</span>
<span class="sd">        concatenated_df = pd.concat(unionized_dataframes, ignore_index=True)</span>

<span class="sd">    :param dataframes: The dataframes you wish to unionize the categorical</span>
<span class="sd">        objects for.</span>
<span class="sd">    :param column_names: If supplied, only unionize this subset of columns.</span>
<span class="sd">    :returns: A list of the category-unioned dataframes in the same order they</span>
<span class="sd">        were provided.</span>
<span class="sd">    :raises TypeError: if any inputs are not pandas DataFrames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Inputs must all be dataframes.&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">column_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Find all columns across all dataframes that are categorical</span>

        <span class="n">column_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="p">:</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="n">column_names</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">column_name</span>
                    <span class="k">for</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">column_names</span><span class="p">]</span>
    <span class="c1"># For each categorical column, find all possible values across the DFs</span>

    <span class="n">category_unions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">column_name</span><span class="p">:</span> <span class="n">union_categoricals</span><span class="p">(</span>
            <span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span> <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">column_names</span>
    <span class="p">}</span>

    <span class="c1"># Make a shallow copy of all DFs and modify the categorical columns</span>
    <span class="c1"># such that they can encode the union of all possible categories for each.</span>

    <span class="n">refactored_dfs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">categorical</span> <span class="ow">in</span> <span class="n">category_unions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">categories</span><span class="o">=</span><span class="n">categorical</span><span class="o">.</span><span class="n">categories</span>
                <span class="p">)</span>

        <span class="n">refactored_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">refactored_dfs</span></div>


<div class="viewcode-block" id="move"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.move.html#janitor.move">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">move</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;before&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Move column or row to a position adjacent to another column or row in</span>
<span class="sd">    dataframe. Must have unique column names or indices.</span>

<span class="sd">    This operation does not reset the index of the dataframe. User must</span>
<span class="sd">    explicitly do so.</span>

<span class="sd">    Does not apply to multilevel dataframes.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = move(df, source=3, target=15, position=&#39;after&#39;, axis=0)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).move(source=3, target=15, position=&#39;after&#39;,</span>
<span class="sd">        axis=0)</span>

<span class="sd">    :param df: The pandas Dataframe object.</span>
<span class="sd">    :param source: column or row to move</span>
<span class="sd">    :param target: column or row to move adjacent to</span>
<span class="sd">    :param position: Specifies whether the Series is moved to before or</span>
<span class="sd">        after the adjacent Series. Values can be either &#39;before&#39; or &#39;after&#39;;</span>
<span class="sd">        defaults to &#39;before&#39;.</span>
<span class="sd">    :param axis: Axis along which the function is applied. 0 to move a</span>
<span class="sd">        row, 1 to move a column.</span>
<span class="sd">    :returns: The dataframe with the Series moved.</span>
<span class="sd">    :raises ValueError: if ``axis`` is not ``0`` or ``1``.</span>
<span class="sd">    :raises ValueError: if ``position`` is not ``before`` or ``after``.</span>
<span class="sd">    :raises ValueError: if  ``source`` row or column is not in dataframe.</span>
<span class="sd">    :raises ValueError: if ``target`` row or column is not in dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid axis &#39;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&#39;. Can only be 0 or 1.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;before&quot;</span><span class="p">,</span> <span class="s2">&quot;after&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid position &#39;</span><span class="si">{</span><span class="n">position</span><span class="si">}</span><span class="s2">&#39;. Can only be &#39;before&#39; or &#39;after&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Source row &#39;</span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&#39; not in dataframe.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target row &#39;</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&#39; not in dataframe.&quot;</span><span class="p">)</span>

        <span class="n">names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;after&quot;</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">names</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">names</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Source column &#39;</span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&#39; not in dataframe.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target column &#39;</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&#39; not in dataframe.&quot;</span><span class="p">)</span>

        <span class="n">names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;after&quot;</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">names</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">names</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="clean_names"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.clean_names.html#janitor.clean_names">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">clean_names</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">strip_underscores</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">case_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span>
    <span class="n">remove_special</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">strip_accents</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">preserve_original_columns</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">enforce_string</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">truncate_limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clean column names.</span>

<span class="sd">    Takes all column names, converts them to lowercase,</span>
<span class="sd">    then replaces all spaces with underscores.</span>

<span class="sd">    By default, column names are converted to string types.</span>
<span class="sd">    This can be switched off by passing in ``enforce_string=False``.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = clean_names(df)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).clean_names()</span>

<span class="sd">    :Example of transformation:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        Columns before: First Name, Last Name, Employee Status, Subject</span>
<span class="sd">        Columns after: first_name, last_name, employee_status, subject</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param strip_underscores: (optional) Removes the outer underscores from all</span>
<span class="sd">        column names. Default None keeps outer underscores. Values can be</span>
<span class="sd">        either &#39;left&#39;, &#39;right&#39; or &#39;both&#39; or the respective shorthand &#39;l&#39;, &#39;r&#39;</span>
<span class="sd">        and True.</span>
<span class="sd">    :param case_type: (optional) Whether to make columns lower or uppercase.</span>
<span class="sd">        Current case may be preserved with &#39;preserve&#39;,</span>
<span class="sd">        while snake case conversion (from CamelCase or camelCase only)</span>
<span class="sd">        can be turned on using &quot;snake&quot;.</span>
<span class="sd">        Default &#39;lower&#39; makes all characters lowercase.</span>
<span class="sd">    :param remove_special: (optional) Remove special characters from columns.</span>
<span class="sd">        Only letters, numbers and underscores are preserved.</span>
<span class="sd">    :param strip_accents: Whether or not to remove accents from</span>
<span class="sd">        columns names.</span>
<span class="sd">    :param preserve_original_columns: (optional) Preserve original names.</span>
<span class="sd">        This is later retrievable using `df.original_columns`.</span>
<span class="sd">    :param enforce_string: Whether or not to convert all column names</span>
<span class="sd">        to string type. Defaults to True, but can be turned off.</span>
<span class="sd">        Columns with &gt;1 levels will not be converted by default.</span>
<span class="sd">    :param truncate_limit: (optional) Truncates formatted column names to</span>
<span class="sd">        the specified length. Default None does not truncate.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_column_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">enforce_string</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_change_case</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">case_type</span><span class="p">))</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">_normalize_1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_special</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">_remove_special</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">strip_accents</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">_strip_accents</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;_+&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>  <span class="c1"># noqa: PD005</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">_strip_underscores</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">strip_underscores</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[:</span><span class="n">truncate_limit</span><span class="p">])</span>

    <span class="c1"># Store the original column names, if enabled by user</span>
    <span class="k">if</span> <span class="n">preserve_original_columns</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;original_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_column_names</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="k">def</span> <span class="nf">_change_case</span><span class="p">(</span><span class="n">col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">case_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Change case of a column name.&quot;&quot;&quot;</span>
    <span class="n">case_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;preserve&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;snake&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">case_types</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;case_type must be one of: </span><span class="si">{</span><span class="n">case_types</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;preserve&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;snake&quot;</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">_camel2snake</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">col</span>


<span class="k">def</span> <span class="nf">_remove_special</span><span class="p">(</span><span class="n">col_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Remove special characters from column name.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="ow">or</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">item</span>
    <span class="p">)</span>


<span class="n">_underscorer1</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.)([A-Z][a-z]+)&quot;</span><span class="p">)</span>
<span class="n">_underscorer2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;([a-z0-9])([A-Z])&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_camel2snake</span><span class="p">(</span><span class="n">col_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert camelcase names to snake case.</span>

<span class="sd">    Implementation taken from: https://gist.github.com/jaytaylor/3660565</span>
<span class="sd">    by @jtaylor</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subbed</span> <span class="o">=</span> <span class="n">_underscorer1</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\1_\2&quot;</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span>  <span class="c1"># noqa: PD005</span>
    <span class="k">return</span> <span class="n">_underscorer2</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\1_\2&quot;</span><span class="p">,</span> <span class="n">subbed</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="c1"># noqa: PD005</span>


<span class="n">FIXES</span> <span class="o">=</span> <span class="p">[(</span><span class="sa">r</span><span class="s2">&quot;[ /:,?()\.-]&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">),</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[&#39;â€™]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_normalize_1</span><span class="p">(</span><span class="n">col_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Perform normalization of column name.&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">search</span><span class="p">,</span> <span class="n">replace</span> <span class="ow">in</span> <span class="n">FIXES</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">search</span><span class="p">,</span> <span class="n">replace</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>  <span class="c1"># noqa: PD005</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_strip_accents</span><span class="p">(</span><span class="n">col_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Remove accents from a DataFrame column name.</span>
<span class="sd">    .. _StackOverflow: https://stackoverflow.com/questions/517923/what-is-the-best-way-to-remove-accents-in-a-python-unicode-strin</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">letter</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s2">&quot;NFD&quot;</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">combining</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
    <span class="p">)</span>


<div class="viewcode-block" id="remove_empty"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.remove_empty.html#janitor.remove_empty">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">remove_empty</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Drop all rows and columns that are completely null.</span>

<span class="sd">    This method also resets the index(by default) since it doesn&#39;t make sense</span>
<span class="sd">    to preserve the index of a completely empty row.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Implementation is inspired from `StackOverflow`_.</span>

<span class="sd">    .. _StackOverflow: https://stackoverflow.com/questions/38884538/python-pandas-find-all-rows-where-all-values-are-nan</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = remove_empty(df)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).remove_empty()</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>

<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">nanrows</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">nanrows</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">nancols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">nancols</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="get_dupes"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.get_dupes.html#janitor.get_dupes">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_dupes</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return all duplicate rows.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = get_dupes(df)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).get_dupes()</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param column_names: (optional) A column name or an iterable</span>
<span class="sd">        (list or tuple) of column names. Following pandas API, this only</span>
<span class="sd">        considers certain columns for identifying duplicates. Defaults to using</span>
<span class="sd">        all columns.</span>
<span class="sd">    :returns: The duplicate rows, as a pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dupes</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">column_names</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">dupes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>  <span class="c1"># noqa: E712</span></div>


<div class="viewcode-block" id="encode_categorical"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.encode_categorical.html#janitor.encode_categorical">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">encode_categorical</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Encode the specified columns with Pandas&#39;</span>
<span class="sd">    `category dtype &lt;http://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html&gt;`_.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        categorical_cols = [&#39;col1&#39;, &#39;col2&#39;, &#39;col4&#39;]</span>
<span class="sd">        df = encode_categorical(df, columns=categorical_cols)  # one way</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        categorical_cols = [&#39;col1&#39;, &#39;col2&#39;, &#39;col4&#39;]</span>
<span class="sd">        df = pd.DataFrame(...).encode_categorical(columns=categorical_cols)</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param column_names: A column name or an iterable (list or</span>
<span class="sd">        tuple) of column names.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    :raises JanitorError: if a column specified within ``column_names``</span>
<span class="sd">        is not found in the DataFrame.</span>
<span class="sd">    :raises JanitorError: if ``column_names`` is not hashable</span>
<span class="sd">        nor iterable.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> missing from DataFrame columns!&quot;</span><span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">column_names</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_names</span><span class="si">}</span><span class="s2"> missing from DataFrame columns!&quot;</span>
            <span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_names</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_names</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
            <span class="s2">&quot;kwarg `column_names` must be hashable or iterable!&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="label_encode"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.label_encode.html#janitor.label_encode">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">label_encode</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert labels into numerical data.</span>

<span class="sd">    This method will create a new column with the string &quot;_enc&quot; appended</span>
<span class="sd">    after the original column&#39;s name. Consider this to be syntactic sugar.</span>

<span class="sd">    This method behaves differently from `encode_categorical`. This method</span>
<span class="sd">    creates a new column of numeric data. `encode_categorical` replaces the</span>
<span class="sd">    dtype of the original column with a &quot;categorical&quot; dtype.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = label_encode(df, column_names=&quot;my_categorical_column&quot;)  # one way</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        categorical_cols = [&#39;col1&#39;, &#39;col2&#39;, &#39;col4&#39;]</span>
<span class="sd">        df = pd.DataFrame(...).label_encode(column_names=categorical_cols)</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param column_names: A column name or an iterable (list</span>
<span class="sd">        or tuple) of column names.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    :raises JanitorError: if a column specified within ``column_names``</span>
<span class="sd">        is not found in the DataFrame.</span>
<span class="sd">    :raises JanitorError: if ``column_names`` is not hashable</span>
<span class="sd">        nor iterable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">le</span> <span class="o">=</span> <span class="n">LabelEncoder</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> missing from DataFrame columns!&quot;</span><span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">_enc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">le</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">column_names</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_names</span><span class="si">}</span><span class="s2"> missing from DataFrame columns!&quot;</span>
            <span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_names</span><span class="si">}</span><span class="s2">_enc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">le</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_names</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
            <span class="s2">&quot;kwarg `column_names` must be hashable or iterable!&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="rename_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.rename_column.html#janitor.rename_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">old</span><span class="o">=</span><span class="s2">&quot;old_column_name&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="s2">&quot;new_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rename_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">old_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">new_column_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Rename a column in place.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = rename_column(df, &quot;old_column_name&quot;, &quot;new_column_name&quot;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).rename_column(&quot;old_column_name&quot;, &quot;new_column_name&quot;)</span>

<span class="sd">    This is just syntactic sugar/a convenience function for renaming one column</span>
<span class="sd">    at a time. If you are convinced that there are multiple columns in need of</span>
<span class="sd">    changing, then use the :py:meth:`pandas.DataFrame.rename` method.</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param old_column_name: The old column name.</span>
<span class="sd">    :param new_column_name: The new column name.</span>
<span class="sd">    :returns: A pandas DataFrame with renamed columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="n">old_column_name</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">old_column_name</span><span class="p">:</span> <span class="n">new_column_name</span><span class="p">})</span></div>


<div class="viewcode-block" id="rename_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.rename_columns.html#janitor.rename_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">rename_columns</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">new_column_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Rename columns in place.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = rename_columns(df, {&quot;old_column_name&quot;: &quot;new_column_name&quot;})</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).rename_columns({&quot;old_column_name&quot;: &quot;new_column_name&quot;})</span>

<span class="sd">    This is just syntactic sugar/a convenience function for renaming one column</span>
<span class="sd">    at a time. If you are convinced that there are multiple columns in need of</span>
<span class="sd">    changing, then use the :py:meth:`pandas.DataFrame.rename` method.</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param new_column_names: A dictionary of old and new column names.</span>
<span class="sd">    :returns: A pandas DataFrame with renamed columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_column_names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_names</span><span class="p">)</span></div>


<div class="viewcode-block" id="reorder_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.reorder_columns.html#janitor.reorder_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">reorder_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_order</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Reorder DataFrame columns by specifying desired order as list of col names.</span>

<span class="sd">    Columns not specified retain their order and follow after specified cols.</span>

<span class="sd">    Validates column_order to ensure columns are all present in DataFrame.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    Given `DataFrame` with column names `col1`, `col2`, `col3`:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = reorder_columns(df, [&#39;col2&#39;, &#39;col3&#39;])</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).reorder_columns([&#39;col2&#39;, &#39;col3&#39;])</span>

<span class="sd">    The column order of `df` is now `col2`, `col3`, `col1`.</span>

<span class="sd">    Internally, this function uses `DataFrame.reindex` with `copy=False`</span>
<span class="sd">    to avoid unnecessary data duplication.</span>

<span class="sd">    :param df: `DataFrame` to reorder</span>
<span class="sd">    :param column_order: A list of column names or Pandas `Index`</span>
<span class="sd">        specifying their order in the returned `DataFrame`.</span>
<span class="sd">    :returns: A pandas DataFrame with reordered columns.</span>
<span class="sd">    :raises IndexError: if a column within ``column_order`` is not found</span>
<span class="sd">        within the DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_order&quot;</span><span class="p">,</span> <span class="n">column_order</span><span class="p">,</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_order</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
            <span class="s2">&quot;A column in ``column_order`` was not found in the DataFrame.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># if column_order is a Pandas index, needs conversion to list:</span>
    <span class="n">column_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">column_order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">(</span>
            <span class="n">column_order</span>
            <span class="o">+</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">column_order</span><span class="p">]</span>
        <span class="p">),</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="coalesce"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.coalesce.html#janitor.coalesce">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">coalesce</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="n">new_column_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">delete_columns</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Coalesce two or more columns of data in order of column names provided.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = coalesce(df, columns=[&#39;col1&#39;, &#39;col2&#39;], &#39;col3&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).coalesce([&#39;col1&#39;, &#39;col2&#39;])</span>

<span class="sd">    The first example will create a new column called &#39;col3&#39; with values from</span>
<span class="sd">    &#39;col2&#39; inserted where values from &#39;col1&#39; are NaN, then delete the original</span>
<span class="sd">    columns. The second example will keep the name &#39;col1&#39; in the new column.</span>

<span class="sd">    This is more syntactic diabetes! For R users, this should look familiar to</span>
<span class="sd">    `dplyr`&#39;s `coalesce` function; for Python users, the interface</span>
<span class="sd">    should be more intuitive than the :py:meth:`pandas.Series.combine_first`</span>
<span class="sd">    method (which we&#39;re just using internally anyways).</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_names: A list of column names.</span>
<span class="sd">    :param new_column_name: The new column name after combining.</span>
<span class="sd">    :param delete_columns: Whether to delete the columns being coalesced</span>
<span class="sd">    :returns: A pandas DataFrame with coalesced columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">series</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_coalesce</span><span class="p">(</span><span class="n">series1</span><span class="p">,</span> <span class="n">series2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">series1</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">series2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">delete_columns</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">column_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">new_column_name</span><span class="p">:</span>
        <span class="n">new_column_name</span> <span class="o">=</span> <span class="n">column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">_coalesce</span><span class="p">,</span> <span class="n">series</span><span class="p">)</span>  <span class="c1"># noqa: F821</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="convert_excel_date"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.convert_excel_date.html#janitor.convert_excel_date">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convert_excel_date</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert Excel&#39;s serial date format into Python datetime format.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Implementation is also from `Stack Overflow`.</span>

<span class="sd">    .. _Stack Overflow: https://stackoverflow.com/questions/38454403/convert-excel-style-date-with-pandas</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = convert_excel_date(df, column_name=&#39;date&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).convert_excel_date(&#39;date&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: A column name.</span>
<span class="sd">    :returns: A pandas DataFrame with corrected dates.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;d&quot;</span>
    <span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
        <span class="mi">1899</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">30</span>
    <span class="p">)</span>  <span class="c1"># noqa: W503</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="convert_matlab_date"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.convert_matlab_date.html#janitor.convert_matlab_date">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convert_matlab_date</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert Matlab&#39;s serial date number into Python datetime format.</span>

<span class="sd">    Implementation is also from `StackOverflow`_.</span>

<span class="sd">    .. _StackOverflow: https://stackoverflow.com/questions/13965740/converting-matlabs-datenum-format-to-python</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = convert_matlab_date(df, column_name=&#39;date&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).convert_matlab_date(&#39;date&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: A column name.</span>
<span class="sd">    :returns: A pandas DataFrame with corrected dates.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">days</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]])</span>
    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromordinal</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">days</span>
        <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">366</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="convert_unix_date"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.convert_unix_date.html#janitor.convert_unix_date">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convert_unix_date</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert unix epoch time into Python datetime format.</span>

<span class="sd">    Note that this ignores local tz and convert all timestamps to naive</span>
<span class="sd">    datetime based on UTC!</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = convert_unix_date(df, column_name=&#39;date&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).convert_unix_date(&#39;date&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: A column name.</span>
<span class="sd">    :returns: A pandas DataFrame with corrected dates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">OutOfBoundsDatetime</span><span class="p">:</span>  <span class="c1"># Indicates time is in milliseconds.</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="fill_empty"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.fill_empty.html#janitor.fill_empty">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fill_empty</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">],</span> <span class="n">value</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Fill `NaN` values in specified columns with a given value.</span>

<span class="sd">    Super sugary syntax that wraps :py:meth:`pandas.DataFrame.fillna`.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = fill_empty(df, column_names=[&#39;col1&#39;, &#39;col2&#39;], value=0)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).fill_empty(column_names=&#39;col1&#39;, value=0)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_names: column_names: A column name or an iterable (list</span>
<span class="sd">        or tuple) of column names If a single column name is passed in, then</span>
<span class="sd">        only that column will be filled; if a list or tuple is passed in, then</span>
<span class="sd">        those columns will all be filled with the same value.</span>
<span class="sd">    :param value: The value that replaces the `NaN` values.</span>
<span class="sd">    :returns: A pandas DataFrame with `Nan` values filled.</span>
<span class="sd">    :raises JanitorError: if a column specified within ``column_names``</span>
<span class="sd">        is not found in the DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> missing from DataFrame columns!&quot;</span><span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">column_names</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_names</span><span class="si">}</span><span class="s2"> missing from DataFrame columns!&quot;</span>
            <span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_names</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_names</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="expand_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.expand_column.html#janitor.expand_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">expand_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">concat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Expand a categorical column with multiple labels into dummy-coded columns.</span>

<span class="sd">    Super sugary syntax that wraps :py:meth:`pandas.Series.str.get_dummies`.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = expand_column(df,</span>
<span class="sd">                           column_name=&#39;col_name&#39;,</span>
<span class="sd">                           sep=&#39;, &#39;)  # note space in sep</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).expand_column(column_name=&#39;col_name&#39;,</span>
<span class="sd">                                             sep=&#39;, &#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: Which column to expand.</span>
<span class="sd">    :param sep: The delimiter. Example delimiters include `|`, `, `, `,` etc.</span>
<span class="sd">    :param concat: Whether to return the expanded column concatenated to</span>
<span class="sd">        the original dataframe (`concat=True`), or to return it standalone</span>
<span class="sd">        (`concat=False`).</span>
<span class="sd">    :returns: A pandas DataFrame with an expanded column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expanded_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">concat</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">expanded_df</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expanded_df</span></div>


<div class="viewcode-block" id="concatenate_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.concatenate_columns.html#janitor.concatenate_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">concatenate_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="n">new_column_name</span><span class="p">,</span>
    <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Concatenates the set of columns into a single column.</span>

<span class="sd">    Used to quickly generate an index based on a group of columns.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = concatenate_columns(df,</span>
<span class="sd">                                 column_names=[&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">                                 new_column_name=&#39;id&#39;,</span>
<span class="sd">                                 sep=&#39;-&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...).</span>
<span class="sd">              concatenate_columns(column_names=[&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">                                  new_column_name=&#39;id&#39;,</span>
<span class="sd">                                  sep=&#39;-&#39;))</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_names: A list of columns to concatenate together.</span>
<span class="sd">    :param new_column_name: The name of the new column.</span>
<span class="sd">    :param sep: The separator between each column&#39;s data.</span>
<span class="sd">    :returns: A pandas DataFrame with concatenated columns.</span>
<span class="sd">    :raises JanitorError: if at least two columns are not provided</span>
<span class="sd">        within ``column_names``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span><span class="s2">&quot;At least two columns must be specified&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">+</span> <span class="n">sep</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="deconcatenate_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.deconcatenate_column.html#janitor.deconcatenate_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">deconcatenate_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">sep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">new_column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">autoname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">preserve_position</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;De-concatenates a single column into multiple columns.</span>

<span class="sd">    The column to de-concatenate can be either a collection (list, tuple, ...)</span>
<span class="sd">    which can be separated out with ``pd.Series.tolist()``,</span>
<span class="sd">    or a string to slice based on ``sep``.</span>

<span class="sd">    To determine this behaviour automatically,</span>
<span class="sd">    the first element in the column specified is inspected.</span>

<span class="sd">    If it is a string, then ``sep`` must be specified.</span>
<span class="sd">    Else, the function assumes that it is an iterable type</span>
<span class="sd">    (e.g. ``list`` or ``tuple``),</span>
<span class="sd">    and will attempt to deconcatenate by splitting the list.</span>

<span class="sd">    Given a column with string values, this is the inverse of the</span>
<span class="sd">    ``concatenate_columns`` function.</span>

<span class="sd">    Used to quickly split columns out of a single column.</span>

<span class="sd">    The keyword argument ``preserve_position``</span>
<span class="sd">    takes ``True`` or ``False`` boolean</span>
<span class="sd">    that controls whether the ``new_column_names``</span>
<span class="sd">    will take the original position</span>
<span class="sd">    of the to-be-deconcatenated ``column_name``:</span>

<span class="sd">    - When `preserve_position=False` (default), `df.columns` change from</span>
<span class="sd">      `[..., column_name, ...]` to `[..., column_name, ..., new_column_names]`.</span>
<span class="sd">      In other words, the deconcatenated new columns are appended to the right</span>
<span class="sd">      of the original dataframe and the original `column_name` is NOT dropped.</span>
<span class="sd">    - When `preserve_position=True`, `df.column` change from</span>
<span class="sd">      `[..., column_name, ...]` to `[..., new_column_names, ...]`.</span>
<span class="sd">      In other words, the deconcatenated new column will REPLACE the original</span>
<span class="sd">      `column_name` at its original position, and `column_name` itself</span>
<span class="sd">      is dropped.</span>

<span class="sd">    The keyword argument ``autoname`` accepts a base string</span>
<span class="sd">    and then automatically creates numbered column names</span>
<span class="sd">    based off the base string.</span>
<span class="sd">    For example, if ``col`` is passed in</span>
<span class="sd">    as the argument to ``autoname``,</span>
<span class="sd">    and 4 columns are created,</span>
<span class="sd">    then the resulting columns will be named</span>
<span class="sd">    ``col1, col2, col3, col4``.</span>
<span class="sd">    Numbering is always 1-indexed, not 0-indexed,</span>
<span class="sd">    in order to make the column names human-friendly.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = deconcatenate_column(</span>
<span class="sd">                df, column_name=&#39;id&#39;, new_column_names=[&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">                sep=&#39;-&#39;, preserve_position=True</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...).</span>
<span class="sd">                deconcatenate_column(</span>
<span class="sd">                    column_name=&#39;id&#39;, new_column_names=[&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">                    sep=&#39;-&#39;, preserve_position=True</span>
<span class="sd">                ))</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column to split.</span>
<span class="sd">    :param sep: The separator delimiting the column&#39;s data.</span>
<span class="sd">    :param new_column_names: A list of new column names post-splitting.</span>
<span class="sd">    :param autoname: A base name for automatically naming the new columns.</span>
<span class="sd">        Takes precedence over ``new_column_names`` if both are provided.</span>
<span class="sd">    :param preserve_position: Boolean for whether or not to preserve original</span>
<span class="sd">        position of the column upon de-concatenation, default to False</span>
<span class="sd">    :returns: A pandas DataFrame with a deconcatenated column.</span>
<span class="sd">    :raises ValueError: if ``column_name`` is not present in the</span>
<span class="sd">        DataFrame.</span>
<span class="sd">    :raises ValueError: if ``sep`` is not provided and the column values</span>
<span class="sd">        are of type ``str``.</span>
<span class="sd">    :raises ValueError: if either ``new_column_names`` or ``autoname``</span>
<span class="sd">        is not supplied.</span>
<span class="sd">    :raises JanitorError: if incorrect number of names is provided</span>
<span class="sd">        within ``new_column_names``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;column name </span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2"> not present in DataFrame&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`sep` must be specified if the column values &quot;</span>
                <span class="s2">&quot;are of type `str`.&quot;</span>
            <span class="p">)</span>
        <span class="n">df_deconcat</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df_deconcat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span><span class="n">new_column_names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">preserve_position</span><span class="p">:</span>
        <span class="c1"># Keep a copy of the original dataframe</span>
        <span class="n">df_original</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">new_column_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">autoname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;One of `new_column_names` or `autoname` must be supplied.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">autoname</span><span class="p">:</span>
        <span class="n">new_column_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">autoname</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">df_deconcat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_names</span><span class="p">)</span> <span class="o">==</span> <span class="n">df_deconcat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;you need to provide </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df_deconcat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2"> names &quot;</span>
            <span class="s2">&quot;to `new_column_names`&quot;</span>
        <span class="p">)</span>

    <span class="n">df_deconcat</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">new_column_names</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">df_deconcat</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">preserve_position</span><span class="p">:</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_original</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">index_original</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col_new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_column_names</span><span class="p">):</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index_original</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">col_new</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">column_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="filter_string"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.filter_string.html#janitor.filter_string">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">filter_string</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">search_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">complement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Filter a string-based column according to whether it contains a substring.</span>

<span class="sd">    This is super sugary syntax that builds on top of</span>
<span class="sd">    `pandas.Series.str.contains`.</span>

<span class="sd">    Because this uses internally `pandas.Series.str.contains`, which allows a</span>
<span class="sd">    regex string to be passed into it, thus `search_string` can also be a regex</span>
<span class="sd">    pattern.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    This function allows us to method chain filtering operations:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .filter_string(&#39;column&#39;, search_string=&#39;pattern&#39;, complement=False)</span>
<span class="sd">              ...)  # chain on more data preprocessing.</span>

<span class="sd">    This stands in contrast to the in-place syntax that is usually used:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = df[df[&#39;column&#39;].str.contains(&#39;pattern&#39;)]]</span>

<span class="sd">    As can be seen here, the API design allows for a more seamless flow in</span>
<span class="sd">    expressing the filtering operations.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = filter_string(df,</span>
<span class="sd">                           column_name=&#39;column&#39;,</span>
<span class="sd">                           search_string=&#39;pattern&#39;,</span>
<span class="sd">                           complement=False)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .filter_string(column_name=&#39;column&#39;,</span>
<span class="sd">                             search_string=&#39;pattern&#39;,</span>
<span class="sd">                             complement=False)</span>
<span class="sd">              ...)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column to filter. The column should contain strings.</span>
<span class="sd">    :param search_string: A regex pattern or a (sub-)string to search.</span>
<span class="sd">    :param complement: Whether to return the complement of the filter or not.</span>
<span class="sd">    :returns: A filtered pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">search_string</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">complement</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">criteria</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">criteria</span><span class="p">]</span></div>


<div class="viewcode-block" id="filter_on"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.filter_on.html#janitor.filter_on">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">filter_on</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">criteria</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">complement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return a dataframe filtered on a particular criteria.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    This is super-sugary syntax that wraps the pandas `.query()` API, enabling</span>
<span class="sd">    users to use strings to quickly specify filters for filtering their</span>
<span class="sd">    dataframe. The intent is that `filter_on` as a verb better matches the</span>
<span class="sd">    intent of a pandas user than the verb `query`.</span>

<span class="sd">    Let&#39;s say we wanted to filter students based on whether they failed an exam</span>
<span class="sd">    or not, which is defined as their score (in the &quot;score&quot; column) being less</span>
<span class="sd">    than 50.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .filter_on(&#39;score &lt; 50&#39;, complement=False)</span>
<span class="sd">              ...)  # chain on more data preprocessing.</span>

<span class="sd">    This stands in contrast to the in-place syntax that is usually used:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = df[df[&#39;score&#39;] &lt; 3]</span>

<span class="sd">    As with the `filter_string` function, a more seamless flow can be expressed</span>
<span class="sd">    in the code.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = filter_on(df,</span>
<span class="sd">                       &#39;score &lt; 50&#39;,</span>
<span class="sd">                       complement=False)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .filter_on(&#39;score &lt; 50&#39;, complement=False))</span>

<span class="sd">    Credit to Brant Peterson for the name.</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param criteria: A filtering criteria that returns an array or Series of</span>
<span class="sd">        booleans, on which pandas can filter on.</span>
<span class="sd">    :param complement: Whether to return the complement of the filter or not.</span>
<span class="sd">    :returns: A filtered pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">complement</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;not &quot;</span> <span class="o">+</span> <span class="n">criteria</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span></div>


<div class="viewcode-block" id="filter_date"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.filter_date.html#janitor.filter_date">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="s2">&quot;start_date&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;end_date&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">filter_date</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">start_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">end_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">years</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">months</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">days</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">column_date_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Filter a date-based column based on certain criteria.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Dates may be finicky and this function builds on top of the &quot;magic&quot; from</span>
<span class="sd">    the pandas `to_datetime` function that is able to parse dates well.</span>

<span class="sd">    Additional options to parse the date type of your column may be found at</span>
<span class="sd">    the official pandas documentation:</span>

<span class="sd">    pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html</span>

<span class="sd">    **Note:** This method will cast your column to a Timestamp!</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: The column which to apply the fraction transformation.</span>
<span class="sd">    :param start_date: The beginning date to use to filter the DataFrame.</span>
<span class="sd">    :param end_date: The end date to use to filter the DataFrame.</span>
<span class="sd">    :param years: The years to use to filter the DataFrame.</span>
<span class="sd">    :param months: The months to use to filter the DataFrame.</span>
<span class="sd">    :param days: The days to use to filter the DataFrame.</span>
<span class="sd">    :param column_date_options: &#39;Special options to use when parsing the date</span>
<span class="sd">        column in the original DataFrame. The options may be found at the</span>
<span class="sd">        official Pandas documentation.&#39;</span>
<span class="sd">    :param format: &#39;If you&#39;re using a format for `start_date` or `end_date`</span>
<span class="sd">        that is not recognized natively by pandas&#39; to_datetime function, you</span>
<span class="sd">        may supply the format yourself. Python date and time formats may be</span>
<span class="sd">        found at http://strftime.org/.&#39;</span>
<span class="sd">    :returns: A filtered pandas DataFrame.</span>

<span class="sd">    **Note:** This only affects the format of the `start_date` and `end_date`</span>
<span class="sd">    parameters. If there&#39;s an issue with the format of the DataFrame being</span>
<span class="sd">    parsed, you would pass `{&#39;format&#39;: your_format}` to `column_date_options`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: need to convert this to notebook.</span>
    <span class="c1">#     :Setup:</span>
    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>

    <span class="c1">#     date_list = [</span>
    <span class="c1">#         [1, &quot;01/28/19&quot;], [2, &quot;01/29/19&quot;], [3, &quot;01/30/19&quot;],</span>
    <span class="c1">#         [4, &quot;01/31/19&quot;], [5, &quot;02/01/19&quot;], [6, &quot;02/02/19&quot;],</span>
    <span class="c1">#         [7, &quot;02/03/19&quot;], [8, &quot;02/04/19&quot;], [9, &quot;02/05/19&quot;],</span>
    <span class="c1">#         [10, &quot;02/06/19&quot;], [11, &quot;02/07/20&quot;], [12, &quot;02/08/20&quot;],</span>
    <span class="c1">#         [13, &quot;02/09/20&quot;], [14, &quot;02/10/20&quot;], [15, &quot;02/11/20&quot;],</span>
    <span class="c1">#         [16, &quot;02/12/20&quot;], [17, &quot;02/07/20&quot;], [18, &quot;02/08/20&quot;],</span>
    <span class="c1">#         [19, &quot;02/09/20&quot;], [20, &quot;02/10/20&quot;], [21, &quot;02/11/20&quot;],</span>
    <span class="c1">#         [22, &quot;02/12/20&quot;], [23, &quot;03/08/20&quot;], [24, &quot;03/09/20&quot;],</span>
    <span class="c1">#         [25, &quot;03/10/20&quot;], [26, &quot;03/11/20&quot;], [27, &quot;03/12/20&quot;]]</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(date_list,</span>
    <span class="c1">#                                      columns = [&#39;AMOUNT&#39;, &#39;DATE&#39;])</span>

    <span class="c1"># :Example 1: Filter dataframe between two dates</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     start_date = &quot;01/29/19&quot;</span>
    <span class="c1">#     end_date = &quot;01/30/19&quot;</span>

    <span class="c1">#     example_dataframe.filter_date(</span>
    <span class="c1">#         &#39;DATE&#39;, start_date=start_date, end_date=end_date</span>
    <span class="c1">#     )</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        AMOUNT       DATE</span>
    <span class="c1">#     1       2 2019-01-29</span>
    <span class="c1">#     2       3 2019-01-30</span>

    <span class="c1"># :Example 2: Using a different date format for filtering</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     end_date = &quot;01$$$30$$$19&quot;</span>
    <span class="c1">#     format = &quot;%m$$$%d$$$%y&quot;</span>

    <span class="c1">#     example_dataframe.filter_date(</span>
    <span class="c1">#         &#39;DATE&#39;, end_date=end_date, format=format</span>
    <span class="c1">#     )</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        AMOUNT       DATE</span>
    <span class="c1">#     0       1 2019-01-28</span>
    <span class="c1">#     1       2 2019-01-29</span>
    <span class="c1">#     2       3 2019-01-30</span>

    <span class="c1"># :Example 3: Filtering by year</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     years = [2019]</span>

    <span class="c1">#     example_dataframe.filter_date(&#39;DATE&#39;, years=years)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        AMOUNT       DATE</span>
    <span class="c1">#     0       1 2019-01-28</span>
    <span class="c1">#     1       2 2019-01-29</span>
    <span class="c1">#     2       3 2019-01-30</span>
    <span class="c1">#     3       4 2019-01-31</span>
    <span class="c1">#     4       5 2019-02-01</span>
    <span class="c1">#     5       6 2019-02-02</span>
    <span class="c1">#     6       7 2019-02-03</span>
    <span class="c1">#     7       8 2019-02-04</span>
    <span class="c1">#     8       9 2019-02-05</span>
    <span class="c1">#     9      10 2019-02-06</span>

    <span class="c1"># :Example 4: Filtering by year and month</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     years = [2020]</span>
    <span class="c1">#     months = [3]</span>

    <span class="c1">#     example_dataframe.filter_date(&#39;DATE&#39;, years=years, months=months)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#         AMOUNT       DATE</span>
    <span class="c1">#     22      23 2020-03-08</span>
    <span class="c1">#     23      24 2020-03-09</span>
    <span class="c1">#     24      25 2020-03-10</span>
    <span class="c1">#     25      26 2020-03-11</span>
    <span class="c1">#     26      27 2020-03-12</span>

    <span class="c1"># :Example 5: Filtering by year and day</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     years = [2020]</span>
    <span class="c1">#     days = range(10,12)</span>

    <span class="c1">#     example_dataframe.filter_date(&#39;DATE&#39;, years=years, days=days)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#         AMOUNT       DATE</span>
    <span class="c1">#     13      14 2020-02-10</span>
    <span class="c1">#     14      15 2020-02-11</span>
    <span class="c1">#     19      20 2020-02-10</span>
    <span class="c1">#     20      21 2020-02-11</span>
    <span class="c1">#     24      25 2020-03-10</span>
    <span class="c1">#     25      26 2020-03-11</span>

    <span class="k">def</span> <span class="nf">_date_filter_conditions</span><span class="p">(</span><span class="n">conditions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Taken from: https://stackoverflow.com/a/13616382.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span> <span class="n">conditions</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">column_date_options</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">],</span> <span class="o">**</span><span class="n">column_date_options</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">])</span>

    <span class="n">_filter_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">start_date</span><span class="p">:</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_date</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">end_date</span><span class="p">:</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">end_date</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end_date</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">years</span><span class="p">:</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">years</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">months</span><span class="p">:</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">months</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">days</span><span class="p">:</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">day</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">days</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">start_date</span> <span class="ow">and</span> <span class="n">end_date</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">start_date</span> <span class="o">&gt;</span> <span class="n">end_date</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Your start date of </span><span class="si">{</span><span class="n">start_date</span><span class="si">}</span><span class="s2"> is after your end date of &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">end_date</span><span class="si">}</span><span class="s2">. Is this intended?&quot;</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">_date_filter_conditions</span><span class="p">(</span><span class="n">_filter_list</span><span class="p">),</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="filter_column_isin"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.filter_column_isin.html#janitor.filter_column_isin">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">filter_column_isin</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">iterable</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">complement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Filter a dataframe for values in a column that exist in another iterable.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Assumes exact matching; fuzzy matching not implemented.</span>

<span class="sd">    The below example syntax will filter the DataFrame such that we only get</span>
<span class="sd">    rows for which the &quot;names&quot; are exactly &quot;James&quot; and &quot;John&quot;.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .clean_names()</span>
<span class="sd">            .filter_column_isin(column_name=&quot;names&quot;, iterable=[&quot;James&quot;, &quot;John&quot;]</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    This is the method chaining alternative to:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = df[df[&#39;names&#39;].isin([&#39;James&#39;, &#39;John&#39;])]</span>

<span class="sd">    If &quot;complement&quot; is true, then we will only get rows for which the names</span>
<span class="sd">    are not James or John.</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param column_name: The column on which to filter.</span>
<span class="sd">    :param iterable: An iterable. Could be a list, tuple, another pandas</span>
<span class="sd">        Series.</span>
<span class="sd">    :param complement: Whether to return the complement of the selection or</span>
<span class="sd">        not.</span>
<span class="sd">    :returns: A filtered pandas DataFrame.</span>
<span class="sd">    :raises ValueError: if ``iterable`` does not have a length of ``1``</span>
<span class="sd">        or greater.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;`iterable` kwarg must be given an iterable of length 1 or greater&quot;</span>
        <span class="p">)</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">complement</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">criteria</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">criteria</span><span class="p">]</span></div>


<div class="viewcode-block" id="remove_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.remove_columns.html#janitor.remove_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">remove_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Remove the set of columns specified in `column_names`.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Intended to be the method-chaining alternative to `del df[col]`.</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).remove_columns(column_names=[&#39;col1&#39;, &#39;col2&#39;])</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param column_names: The columns to remove.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">column_names</span><span class="p">)</span></div>


<div class="viewcode-block" id="change_type"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.change_type.html#janitor.change_type">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">change_type</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span>
    <span class="n">ignore_exception</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Change the type of a column.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Exceptions that are raised can be ignored. For example, if one has a mixed</span>
<span class="sd">    dtype column that has non-integer strings and integers, and you want to</span>
<span class="sd">    coerce everything to integers, you can optionally ignore the non-integer</span>
<span class="sd">    strings and replace them with ``NaN`` or keep the original value</span>

<span class="sd">    Intended to be the method-chaining alternative to:</span>

<span class="sd">        df[col] = df[col].astype(dtype)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).change_type(&#39;col1&#39;, str)</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: A column in the dataframe.</span>
<span class="sd">    :param dtype: The datatype to convert to. Should be one of the standard</span>
<span class="sd">        Python types, or a numpy datatype.</span>
<span class="sd">    :param ignore_exception: one of ``{False, &quot;fillna&quot;, &quot;keep_values&quot;}``.</span>
<span class="sd">    :returns: A pandas DataFrame with changed column types.</span>
<span class="sd">    :raises ValueError: if unknown option provided for</span>
<span class="sd">        ``ignore_exception``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_exception</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ignore_exception</span> <span class="o">==</span> <span class="s2">&quot;keep_values&quot;</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ignore_exception</span> <span class="o">==</span> <span class="s2">&quot;fillna&quot;</span><span class="p">:</span>
        <span class="c1"># returns None when conversion</span>
        <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">convert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown option for ignore_exception&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.add_column.html#janitor.add_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">fill_remaining</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add a column to the dataframe.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Intended to be the method-chaining alternative to::</span>

<span class="sd">        df[column_name] = value</span>

<span class="sd">    Method chaining syntax adding a column with only a single value:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # This will add a column with only one value.</span>
<span class="sd">        df = pd.DataFrame(...).add_column(column_name=&quot;new_column&quot;, 2)</span>

<span class="sd">    Method chaining syntax adding a column with more than one value:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # This will add a column with an iterable of values.</span>
<span class="sd">        vals = [1, 2, 5, ..., 3, 4]  # of same length as the dataframe.</span>
<span class="sd">        df = pd.DataFrame(...).add_column(column_name=&quot;new_column&quot;, vals)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: Name of the new column. Should be a string, in order</span>
<span class="sd">        for the column name to be compatible with the Feather binary</span>
<span class="sd">        format (this is a useful thing to have).</span>
<span class="sd">    :param value: Either a single value, or a list/tuple of values.</span>
<span class="sd">    :param fill_remaining: If value is a tuple or list that is smaller than</span>
<span class="sd">        the number of rows in the DataFrame, repeat the list or tuple</span>
<span class="sd">        (R-style) to the end of the DataFrame.</span>
<span class="sd">    :returns: A pandas DataFrame with an added column.</span>
<span class="sd">    :raises ValueError: if attempting to add a column that already exists.</span>
<span class="sd">    :raises ValueError: if ``value`` has more elements that number of</span>
<span class="sd">        rows in the DataFrame.</span>
<span class="sd">    :raises ValueError: if attempting to add an iterable of values with</span>
<span class="sd">        a length not equal to the number of DataFrame rows.</span>
<span class="sd">    :raises ValueError: if ``value`` has length of ``0``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Convert examples to notebook.</span>
    <span class="c1"># :Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data = {</span>
    <span class="c1">#         &quot;a&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;Bell__Chart&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;decorated-elephant&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;animals&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
    <span class="c1">#         &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3,</span>
    <span class="c1">#     }</span>
    <span class="c1">#     df = pd.DataFrame(data)</span>

    <span class="c1"># :Example 1: Create a new column with a single value:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.add_column(&quot;city_pop&quot;, 100000)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        a  Bell__Chart  decorated-elephant  animals     cities  city_pop</span>
    <span class="c1">#     0  1            1                   1   rabbit  Cambridge    100000</span>
    <span class="c1">#     1  2            2                   2  leopard   Shanghai    100000</span>
    <span class="c1">#     2  3            3                   3     lion      Basel    100000</span>
    <span class="c1">#     3  1            1                   1   rabbit  Cambridge    100000</span>
    <span class="c1">#     4  2            2                   2  leopard   Shanghai    100000</span>
    <span class="c1">#     5  3            3                   3     lion      Basel    100000</span>
    <span class="c1">#     6  1            1                   1   rabbit  Cambridge    100000</span>
    <span class="c1">#     7  2            2                   2  leopard   Shanghai    100000</span>
    <span class="c1">#     8  3            3                   3     lion      Basel    100000</span>

    <span class="c1"># :Example 2: Create a new column with an iterator which fills to the</span>
    <span class="c1"># column</span>
    <span class="c1"># size:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.add_column(&quot;city_pop&quot;, range(3), fill_remaining=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        a  Bell__Chart  decorated-elephant  animals     cities  city_pop</span>
    <span class="c1">#     0  1            1                   1   rabbit  Cambridge         0</span>
    <span class="c1">#     1  2            2                   2  leopard   Shanghai         1</span>
    <span class="c1">#     2  3            3                   3     lion      Basel         2</span>
    <span class="c1">#     3  1            1                   1   rabbit  Cambridge         0</span>
    <span class="c1">#     4  2            2                   2  leopard   Shanghai         1</span>
    <span class="c1">#     5  3            3                   3     lion      Basel         2</span>
    <span class="c1">#     6  1            1                   1   rabbit  Cambridge         0</span>
    <span class="c1">#     7  2            2                   2  leopard   Shanghai         1</span>
    <span class="c1">#     8  3            3                   3     lion      Basel         2</span>

    <span class="c1"># :Example 3: Add new column based on mutation of other columns:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.add_column(&quot;city_pop&quot;, df.Bell__Chart - 2 * df.a)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        a  Bell__Chart  decorated-elephant  animals     cities  city_pop</span>
    <span class="c1">#     0  1            1                   1   rabbit  Cambridge        -1</span>
    <span class="c1">#     1  2            2                   2  leopard   Shanghai        -2</span>
    <span class="c1">#     2  3            3                   3     lion      Basel        -3</span>
    <span class="c1">#     3  1            1                   1   rabbit  Cambridge        -1</span>
    <span class="c1">#     4  2            2                   2  leopard   Shanghai        -2</span>
    <span class="c1">#     5  3            3                   3     lion      Basel        -3</span>
    <span class="c1">#     6  1            1                   1   rabbit  Cambridge        -1</span>
    <span class="c1">#     7  2            2                   2  leopard   Shanghai        -2</span>
    <span class="c1">#     8  3            3                   3     lion      Basel        -3</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Attempted to add column that already exists: &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="n">nrows</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="c1"># if `value` is a list, ndarray, etc.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nrows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`value` has more elements than number of rows &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;in your `DataFrame`. vals: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;df: </span><span class="si">{</span><span class="n">nrows</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nrows</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fill_remaining</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempted to add iterable of values with length&quot;</span>
                <span class="s2">&quot; not equal to number of DataFrame rows&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`value` has to be an iterable of minimum length 1&quot;</span>
            <span class="p">)</span>
        <span class="n">len_value</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fill_remaining</span><span class="p">:</span>
        <span class="c1"># relevant if a scalar val was passed, yet fill_remaining == True</span>
        <span class="n">len_value</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="n">nrows</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">fill_remaining</span><span class="p">:</span>
        <span class="n">times_to_loop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nrows</span> <span class="o">/</span> <span class="n">len_value</span><span class="p">))</span>

        <span class="n">fill_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="n">times_to_loop</span>

        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_values</span><span class="p">[:</span><span class="n">nrows</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.add_columns.html#janitor.add_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">add_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">fill_remaining</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add multiple columns to the dataframe.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Method to augment `add_column` with ability to add multiple columns in</span>
<span class="sd">    one go. This replaces the need for multiple `add_column` calls.</span>

<span class="sd">    Usage is through supplying kwargs where the key is the col name and the</span>
<span class="sd">    values correspond to the values of the new DataFrame column.</span>

<span class="sd">    Values passed can be scalar or iterable (list, ndarray, etc.)</span>

<span class="sd">    Usage example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        x = 3</span>
<span class="sd">        y = np.arange(0, 10)</span>
<span class="sd">        df = pd.DataFrame(...).add_columns(x=x, y=y)</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param fill_remaining: If value is a tuple or list that is smaller than</span>
<span class="sd">        the number of rows in the DataFrame, repeat the list or tuple</span>
<span class="sd">        (R-style) to the end of the DataFrame. (Passed to `add_column`)</span>
<span class="sd">    :param kwargs: column, value pairs which are looped through in</span>
<span class="sd">        `add_column` calls.</span>
<span class="sd">    :returns: A pandas DataFrame with added columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: error checking can pretty much be handled in `add_column`</span>

    <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">fill_remaining</span><span class="o">=</span><span class="n">fill_remaining</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="limit_column_characters"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.limit_column_characters.html#janitor.limit_column_characters">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">limit_column_characters</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">col_separator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Truncate column sizes to a specific length.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Method chaining will truncate all columns to a given length and append</span>
<span class="sd">    a given separator character with the index of duplicate columns, except</span>
<span class="sd">    for the first distinct column name.</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_length: Character length for which to truncate all columns.</span>
<span class="sd">        The column separator value and number for duplicate column name does</span>
<span class="sd">        not contribute. Therefore, if all columns are truncated to 10</span>
<span class="sd">        characters, the first distinct column will be 10 characters and the</span>
<span class="sd">        remaining will be 12 characters (assuming a column separator of one</span>
<span class="sd">        character).</span>
<span class="sd">    :param col_separator: The separator to use for counting distinct column</span>
<span class="sd">        values. I think an underscore looks nicest, however a period is a</span>
<span class="sd">        common option as well. Supply an empty string (i.e. &#39;&#39;) to remove the</span>
<span class="sd">        separator.</span>
<span class="sd">    :returns: A pandas DataFrame with truncated column lengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># :Example Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data_dict = {</span>
    <span class="c1">#         &quot;really_long_name_for_a_column&quot;: range(10),</span>
    <span class="c1">#         &quot;another_really_long_name_for_a_column&quot;: \</span>
    <span class="c1">#         [2 * item for item in range(10)],</span>
    <span class="c1">#         &quot;another_really_longer_name_for_a_column&quot;: list(&quot;lllongname&quot;),</span>
    <span class="c1">#         &quot;this_is_getting_out_of_hand&quot;: list(&quot;longername&quot;),</span>
    <span class="c1">#     }</span>

    <span class="c1"># :Example: Standard truncation:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.limit_column_characters(7)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#            really_  another another_1 this_is</span>
    <span class="c1">#     0        0        0         l       l</span>
    <span class="c1">#     1        1        2         l       o</span>
    <span class="c1">#     2        2        4         l       n</span>
    <span class="c1">#     3        3        6         o       g</span>
    <span class="c1">#     4        4        8         n       e</span>
    <span class="c1">#     5        5       10         g       r</span>
    <span class="c1">#     6        6       12         n       n</span>
    <span class="c1">#     7        7       14         a       a</span>
    <span class="c1">#     8        8       16         m       m</span>
    <span class="c1">#     9        9       18         e       e</span>

    <span class="c1"># :Example: Standard truncation with different separator character:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe2 = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe2.limit_column_characters(7, &quot;.&quot;)</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#            really_  another another.1 this_is</span>
    <span class="c1">#     0        0        0         l       l</span>
    <span class="c1">#     1        1        2         l       o</span>
    <span class="c1">#     2        2        4         l       n</span>
    <span class="c1">#     3        3        6         o       g</span>
    <span class="c1">#     4        4        8         n       e</span>
    <span class="c1">#     5        5       10         g       r</span>
    <span class="c1">#     6        6       12         n       n</span>
    <span class="c1">#     7        7       14         a       a</span>
    <span class="c1">#     8        8       16         m       m</span>
    <span class="c1">#     9        9       18         e       e</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_length&quot;</span><span class="p">,</span> <span class="n">column_length</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">])</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;col_separator&quot;</span><span class="p">,</span> <span class="n">col_separator</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>

    <span class="n">col_names</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_name</span><span class="p">[:</span><span class="n">column_length</span><span class="p">]</span> <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">col_names</span><span class="p">]</span>

    <span class="n">col_name_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span>
    <span class="n">col_name_count</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># If no columns are duplicates, we can skip the loops below.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_name_set</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
        <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">col_names</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">for</span> <span class="n">col_name_to_check</span> <span class="ow">in</span> <span class="n">col_name_set</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">col_name_to_check</span> <span class="o">==</span> <span class="n">col_name</span><span class="p">:</span>
                <span class="n">col_name_count</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">final_col_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">col_name_count</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">col_name_to_append</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">col_name</span> <span class="o">+</span> <span class="n">col_separator</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_name_count</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">final_col_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name_to_append</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_col_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>

    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">final_col_names</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="row_to_names"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.row_to_names.html#janitor.row_to_names">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">row_to_names</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">row_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">remove_row</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">remove_rows_above</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Elevates a row to be the column names of a DataFrame.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Contains options to remove the elevated row from the DataFrame along with</span>
<span class="sd">    removing the rows above the selected row.</span>

<span class="sd">    Method chaining usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .row_to_names(</span>
<span class="sd">                row_number=0,</span>
<span class="sd">                remove_row=False,</span>
<span class="sd">                remove_rows_above=False,</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param row_number: The row containing the variable names</span>
<span class="sd">    :param remove_row: Whether the row should be removed from the DataFrame.</span>
<span class="sd">        Defaults to False.</span>
<span class="sd">    :param remove_rows_above: Whether the rows above the selected row should</span>
<span class="sd">        be removed from the DataFrame. Defaults to False.</span>
<span class="sd">    :returns: A pandas DataFrame with set column names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># :Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data_dict = {</span>
    <span class="c1">#         &quot;a&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;Bell__Chart&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;decorated-elephant&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;animals&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
    <span class="c1">#         &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3</span>
    <span class="c1">#     }</span>

    <span class="c1"># :Example: Move first row to column names:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.row_to_names(0)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     0  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     1  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     2  3  3  3     lion      Basel</span>
    <span class="c1">#     3  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     4  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     5  3  3  3     lion      Basel</span>
    <span class="c1">#     6  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     7  2  2  2  leopard   Shanghai</span>

    <span class="c1"># :Example: Move first row to column names and remove row:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.row_to_names(0, remove_row=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     1  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     2  3  3  3     lion      Basel</span>
    <span class="c1">#     3  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     4  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     5  3  3  3     lion      Basel</span>
    <span class="c1">#     6  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     7  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     8  3  3  3     lion      Basel</span>

    <span class="c1"># :Example: Move first row to column names, remove row, \</span>
    <span class="c1"># and remove rows above selected row:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.row_to_names(2, remove_row=True, \</span>
    <span class="c1">#         remove_rows_above=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        3  3  3     lion      Basel</span>
    <span class="c1">#     3  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     4  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     5  3  3  3     lion      Basel</span>
    <span class="c1">#     6  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     7  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     8  3  3  3     lion      Basel</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;row_number&quot;</span><span class="p">,</span> <span class="n">row_number</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">])</span>

    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row_number</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">remove_row</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">row_number</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">remove_rows_above</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">row_number</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="round_to_fraction"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.round_to_fraction.html#janitor.round_to_fraction">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">round_to_fraction</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">denominator</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">digits</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Round all values in a column to a fraction.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Taken from https://github.com/sfirke/janitor/issues/235.</span>

<span class="sd">    Also, optionally round to a specified number of digits.</span>

<span class="sd">    Method-chaining usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # Round to two decimal places</span>
<span class="sd">        df = pd.DataFrame(...).round_to_fraction(&#39;a&#39;, 2)</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: Name of column to round to fraction.</span>
<span class="sd">    :param denominator: The denominator of the fraction for rounding</span>
<span class="sd">    :param digits: The number of digits for rounding after rounding to the</span>
<span class="sd">        fraction. Default is np.inf (i.e. no subsequent rounding)</span>
<span class="sd">    :returns: A pandas DataFrame with a column&#39;s values rounded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: THESE EXAMPLES SHOULD BE MOVED TO NOTEBOOKS.</span>
    <span class="c1">#     :Example Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data_dict = {</span>
    <span class="c1">#         &quot;a&quot;: [1.23452345, 2.456234, 3.2346125] * 3,</span>
    <span class="c1">#         &quot;Bell__Chart&quot;: [1/3, 2/7, 3/2] * 3,</span>
    <span class="c1">#         &quot;decorated-elephant&quot;: [1/234, 2/13, 3/167] * 3,</span>
    <span class="c1">#         &quot;animals&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
    <span class="c1">#         &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3,</span>
    <span class="c1">#     }</span>

    <span class="c1"># :Example: Rounding the first column to the nearest half:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#          a  Bell__Chart  decorated-elephant  animals     cities</span>
    <span class="c1">#     0  1.0     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     1  2.5     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     2  3.0     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     3  1.0     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     4  2.5     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     5  3.0     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     6  1.0     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     7  2.5     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     8  3.0     1.500000            0.017964     lion      Basel</span>

    <span class="c1"># :Example: Rounding the first column to nearest third:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe2 = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe2.round_to_fraction(&#39;a&#39;, 3)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#               a  Bell__Chart  decorated-elephant  animals     cities</span>
    <span class="c1">#     0  1.333333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     1  2.333333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     2  3.333333     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     3  1.333333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     4  2.333333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     5  3.333333     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     6  1.333333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     7  2.333333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     8  3.333333     1.500000            0.017964     lion      Basel</span>

    <span class="c1"># :Example 3: Rounding the first column to the nearest third and rounding \</span>
    <span class="c1"># each value to the 10,000th place:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe2 = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe2.round_to_fraction(&#39;a&#39;, 3, 4)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#             a  Bell__Chart  decorated-elephant  animals     cities</span>
    <span class="c1">#     0  1.3333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     1  2.3333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     2  3.3333     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     3  1.3333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     4  2.3333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     5  3.3333     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     6  1.3333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     7  2.3333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     8  3.3333     1.500000            0.017964     lion      Basel</span>

    <span class="k">if</span> <span class="n">denominator</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;denominator&quot;</span><span class="p">,</span> <span class="n">denominator</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;digits&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span>

    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">*</span> <span class="n">denominator</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">digits</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">digits</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="transform_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.transform_column.html#janitor.transform_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="n">dest_col_name</span><span class="o">=</span><span class="s2">&quot;dest_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transform_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">dest_column_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">elementwise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Transform the given column in-place using the provided function.</span>

<span class="sd">    Functions can be applied one of two ways:</span>

<span class="sd">    - Element-wise (default; ``elementwise=True``)</span>
<span class="sd">    - Column-wise  (alternative; ``elementwise=False``)</span>

<span class="sd">    If the function is applied &quot;elementwise&quot;,</span>
<span class="sd">    then the first argument of the function signature</span>
<span class="sd">    should be the individual element of each function.</span>
<span class="sd">    This is the default behaviour of ``transform_column``,</span>
<span class="sd">    because it is easy to understand.</span>
<span class="sd">    For example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        def elemwise_func(x):</span>
<span class="sd">            modified_x = ... # do stuff here</span>
<span class="sd">            return modified_x</span>

<span class="sd">        df.transform_column(column_name=&quot;my_column&quot;, function=elementwise_func)</span>

<span class="sd">    On the other hand, columnwise application of a function</span>
<span class="sd">    behaves as if the function takes in a pandas Series</span>
<span class="sd">    and emits back a sequence that is of identical length to the original.</span>
<span class="sd">    One place where this is desirable</span>
<span class="sd">    is to gain access to `pandas` native string methods,</span>
<span class="sd">    which are super fast!</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        def columnwise_func(s: pd.Series) -&gt; pd.Series:</span>
<span class="sd">            return s.str[0:5]</span>

<span class="sd">        df.transform_column(</span>
<span class="sd">            column_name=&quot;my_column&quot;,</span>
<span class="sd">            lambda s: s.str[0:5],</span>
<span class="sd">            elementwise=False</span>
<span class="sd">        )</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Let&#39;s say we wanted to apply a log10 transform a column of data.</span>

<span class="sd">    Originally one would write code like this:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # YOU NO LONGER NEED TO WRITE THIS!</span>
<span class="sd">        df[column_name] = df[column_name].apply(np.log10)</span>

<span class="sd">    With the method chaining syntax, we can do the following instead:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .transform_column(column_name, np.log10)</span>
<span class="sd">        )</span>

<span class="sd">    With the functional syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = transform_column(df, column_name, np.log10)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column to transform.</span>
<span class="sd">    :param function: A function to apply on the column.</span>
<span class="sd">    :param dest_column_name: The column name to store the transformation result</span>
<span class="sd">        in. Defaults to None, which will result in the original column</span>
<span class="sd">        name being overwritten. If a name is provided here, then a new column</span>
<span class="sd">        with the transformed values will be created.</span>
<span class="sd">    :param elementwise: Whether to apply the function elementwise or not.</span>
<span class="sd">        If elementwise is True, then the function&#39;s first argument</span>
<span class="sd">        should be the data type of each datum in the column of data,</span>
<span class="sd">        and should return a transformed datum.</span>
<span class="sd">        If elementwise is False, then the function&#39;s should expect</span>
<span class="sd">        a pandas Series passed into it, and return a pandas Series.</span>

<span class="sd">    :returns: A pandas DataFrame with a transformed column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dest_column_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dest_column_name</span> <span class="o">=</span> <span class="n">column_name</span>

    <span class="k">if</span> <span class="n">elementwise</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">])</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">dest_column_name</span><span class="p">:</span> <span class="n">result</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="transform_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.transform_columns.html#janitor.transform_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">,</span> <span class="n">new_names</span><span class="o">=</span><span class="s2">&quot;new_column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transform_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">elementwise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">new_column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Transform multiple columns through the same transformation.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Super syntactic sugar!</span>

<span class="sd">    Basically wraps `transform_column` and calls it repeatedly over all column</span>
<span class="sd">    names provided.</span>

<span class="sd">    User can optionally supply either a suffix to create a new set of columns</span>
<span class="sd">    with the specified suffix, or provide a dictionary mapping each original</span>
<span class="sd">    column name to its corresponding new column name. Note that all column</span>
<span class="sd">    names must be strings.</span>

<span class="sd">    A few examples below. Firstly, to just log10 transform a list of columns</span>
<span class="sd">    without creating new columns to hold the transformed values:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .transform_columns([&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;], np.log10)</span>
<span class="sd">        )</span>

<span class="sd">    Secondly, to add a &#39;_log&#39; suffix when creating a new column, which we think</span>
<span class="sd">    is going to be the most common use case:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .transform_columns(</span>
<span class="sd">                [&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;],</span>
<span class="sd">                np.log10,</span>
<span class="sd">                suffix=&quot;_log&quot;</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    Finally, to provide new names explicitly:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .transform_column(</span>
<span class="sd">                [&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;],</span>
<span class="sd">                np.log10,</span>
<span class="sd">                new_column_names={</span>
<span class="sd">                    &#39;col1&#39;: &#39;transform1&#39;,</span>
<span class="sd">                    &#39;col2&#39;: &#39;transform2&#39;,</span>
<span class="sd">                    &#39;col3&#39;: &#39;transform3&#39;,</span>
<span class="sd">                    }</span>
<span class="sd">                )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_names: An iterable of columns to transform.</span>
<span class="sd">    :param function: A function to apply on each column.</span>
<span class="sd">    :param suffix: (optional) Suffix to use when creating new columns to hold</span>
<span class="sd">        the transformed values.</span>
<span class="sd">    :param elementwise: Passed on to `transform_column`; whether or not</span>
<span class="sd">        to apply the transformation function elementwise (True)</span>
<span class="sd">        or columnwise (False).</span>
<span class="sd">    :param new_column_names: (optional) An explicit mapping of old column names</span>
<span class="sd">        to new column names.</span>
<span class="sd">    :returns: A pandas DataFrame with transformed columns.</span>
<span class="sd">    :raises ValueError: if both ``suffix`` and ``new_column_names`` are</span>
<span class="sd">        specified</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dest_column_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">column_names</span><span class="p">))</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_names&quot;</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_column_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;only one of suffix or new_column_names should be specified&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">suffix</span><span class="p">:</span>  <span class="c1"># If suffix is specified...</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;suffix&quot;</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
            <span class="n">dest_column_names</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">suffix</span>

    <span class="k">if</span> <span class="n">new_column_names</span><span class="p">:</span>  <span class="c1"># If new_column_names is specified...</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;new_column_names&quot;</span><span class="p">,</span> <span class="n">new_column_names</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">])</span>
        <span class="n">dest_column_names</span> <span class="o">=</span> <span class="n">new_column_names</span>

    <span class="c1"># Now, transform columns.</span>
    <span class="k">for</span> <span class="n">old_col</span><span class="p">,</span> <span class="n">new_col</span> <span class="ow">in</span> <span class="n">dest_column_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">transform_column</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">old_col</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">new_col</span><span class="p">,</span> <span class="n">elementwise</span><span class="o">=</span><span class="n">elementwise</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="min_max_scale"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.min_max_scale.html#janitor.min_max_scale">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">min_max_scale</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">old_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">old_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">column_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">new_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">new_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Scales data to between a minimum and maximum value.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    If `minimum` and `maximum` are provided, the true min/max of the</span>
<span class="sd">    `DataFrame` or column is ignored in the scaling process and replaced with</span>
<span class="sd">    these values, instead.</span>

<span class="sd">    One can optionally set a new target minimum and maximum value using the</span>
<span class="sd">    `new_min` and `new_max` keyword arguments. This will result in the</span>
<span class="sd">    transformed data being bounded between `new_min` and `new_max`.</span>

<span class="sd">    If a particular column name is specified, then only that column of data</span>
<span class="sd">    are scaled. Otherwise, the entire dataframe is scaled.</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).min_max_scale(column_name=&quot;a&quot;)</span>

<span class="sd">    Setting custom minimum and maximum:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .min_max_scale(</span>
<span class="sd">                column_name=&quot;a&quot;,</span>
<span class="sd">                new_min=2,</span>
<span class="sd">                new_max=10</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    Setting a min and max that is not based on the data, while applying to</span>
<span class="sd">    entire dataframe:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .min_max_scale(</span>
<span class="sd">                old_min=0,</span>
<span class="sd">                old_max=14,</span>
<span class="sd">                new_min=0,</span>
<span class="sd">                new_max=1,</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    The aforementioned example might be applied to something like scaling the</span>
<span class="sd">    isoelectric points of amino acids. While technically they range from</span>
<span class="sd">    approx 3-10, we can also think of them on the pH scale which ranges from</span>
<span class="sd">    1 to 14. Hence, 3 gets scaled not to 0 but approx. 0.15 instead, while 10</span>
<span class="sd">    gets scaled to approx. 0.69 instead.</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param old_min: (optional) Overrides for the current minimum</span>
<span class="sd">        value of the data to be transformed.</span>
<span class="sd">    :param old_max: (optional) Overrides for the current maximum</span>
<span class="sd">        value of the data to be transformed.</span>
<span class="sd">    :param new_min: (optional) The minimum value of the data after</span>
<span class="sd">        it has been scaled.</span>
<span class="sd">    :param new_max: (optional) The maximum value of the data after</span>
<span class="sd">        it has been scaled.</span>
<span class="sd">    :param column_name: (optional) The column on which to perform scaling.</span>
<span class="sd">    :returns: A pandas DataFrame with scaled data.</span>
<span class="sd">    :raises ValueError: if ``old_max`` is not greater than ``old_min``.</span>
<span class="sd">    :raises ValueError: if ``new_max`` is not greater than ``new_min``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">old_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="n">old_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="n">old_max</span> <span class="o">&lt;=</span> <span class="n">old_min</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`old_max` should be greater than `old_min`&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">new_max</span> <span class="o">&lt;=</span> <span class="n">new_min</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`new_max` should be greater than `new_min`&quot;</span><span class="p">)</span>

    <span class="n">new_range</span> <span class="o">=</span> <span class="n">new_max</span> <span class="o">-</span> <span class="n">new_min</span>

    <span class="k">if</span> <span class="n">column_name</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">old_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_min</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">old_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_max</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">old_range</span> <span class="o">=</span> <span class="n">old_max</span> <span class="o">-</span> <span class="n">old_min</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_min</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">new_range</span> <span class="o">/</span> <span class="n">old_range</span> <span class="o">+</span> <span class="n">new_min</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">old_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_min</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">old_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_max</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">old_range</span> <span class="o">=</span> <span class="n">old_max</span> <span class="o">-</span> <span class="n">old_min</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">old_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">new_range</span> <span class="o">/</span> <span class="n">old_range</span> <span class="o">+</span> <span class="n">new_min</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="collapse_levels"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.collapse_levels.html#janitor.collapse_levels">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">collapse_levels</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Flatten multi-level column dataframe to a single level.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Given a `DataFrame` containing multi-level columns, flatten to single-</span>
<span class="sd">    level by string-joining the column labels in each level.</span>

<span class="sd">    After a `groupby` / `aggregate` operation where `.agg()` is passed a</span>
<span class="sd">    list of multiple aggregation functions, a multi-level `DataFrame` is</span>
<span class="sd">    returned with the name of the function applied in the second level.</span>

<span class="sd">    It is sometimes convenient for later indexing to flatten out this</span>
<span class="sd">    multi-level configuration back into a single level. This function does</span>
<span class="sd">    this through a simple string-joining of all the names across different</span>
<span class="sd">    levels in a single column.</span>

<span class="sd">    Method chaining syntax given two value columns `[&#39;max_speed&#39;, &#39;type&#39;]`:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        data = {&quot;class&quot;: [&quot;bird&quot;, &quot;bird&quot;, &quot;bird&quot;, &quot;mammal&quot;, &quot;mammal&quot;],</span>
<span class="sd">                &quot;max_speed&quot;: [389, 389, 24, 80, 21],</span>
<span class="sd">                &quot;type&quot;: [&quot;falcon&quot;, &quot;falcon&quot;, &quot;parrot&quot;, &quot;Lion&quot;, &quot;Monkey&quot;]}</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(data)</span>
<span class="sd">                .groupby(&#39;class&#39;)</span>
<span class="sd">                .agg([&#39;mean&#39;, &#39;median&#39;])</span>
<span class="sd">                .collapse_levels(sep=&#39;_&#39;)</span>
<span class="sd">        )</span>

<span class="sd">    Before applying ``.collapse_levels``, the ``.agg`` operation returns a</span>
<span class="sd">    multi-level column `DataFrame` whose columns are (level 1, level 2):</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        [(&#39;class&#39;, &#39;&#39;), (&#39;max_speed&#39;, &#39;mean&#39;), (&#39;max_speed&#39;, &#39;median&#39;),</span>
<span class="sd">        (&#39;type&#39;, &#39;mean&#39;), (&#39;type&#39;, &#39;median&#39;)]</span>

<span class="sd">    ``.collapse_levels`` then flattens the column names to:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        [&#39;class&#39;, &#39;max_speed_mean&#39;, &#39;max_speed_median&#39;,</span>
<span class="sd">        &#39;type_mean&#39;, &#39;type_median&#39;]</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param sep: String separator used to join the column level names</span>
<span class="sd">    :returns: A flattened pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;sep&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>

    <span class="c1"># if already single-level, just return the DataFrame</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># noqa: PD011</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">tup</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># noqa: PD011</span>
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="currency_column_to_numeric"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.currency_column_to_numeric.html#janitor.currency_column_to_numeric">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;cleaning_style&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">currency_column_to_numeric</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">,</span>
    <span class="n">cleaning_style</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cast_non_numeric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_all_non_numeric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">remove_non_numeric</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert currency column to numeric.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    This method allows one to take a column containing currency values,</span>
<span class="sd">    inadvertently imported as a string, and cast it as a float. This is</span>
<span class="sd">    usually the case when reading CSV files that were modified in Excel.</span>
<span class="sd">    Empty strings (i.e. `&#39;&#39;`) are retained as `NaN` values.</span>

<span class="sd">    :param df: The DataFrame</span>
<span class="sd">    :param column_name: The column to modify</span>
<span class="sd">    :param cleaning_style: What style of cleaning to perform. If None, standard</span>
<span class="sd">        cleaning is applied. Options are:</span>

<span class="sd">            * &#39;accounting&#39;:</span>
<span class="sd">            Replaces numbers in parentheses with negatives, removes commas.</span>

<span class="sd">    :param cast_non_numeric: A dict of how to coerce certain strings. For</span>
<span class="sd">        example, if there are values of &#39;REORDER&#39; in the DataFrame,</span>
<span class="sd">        {&#39;REORDER&#39;: 0} will cast all instances of &#39;REORDER&#39; to 0.</span>
<span class="sd">    :param fill_all_non_numeric: Similar to `cast_non_numeric`, but fills all</span>
<span class="sd">        strings to the same value. For example,  fill_all_non_numeric=1, will</span>
<span class="sd">        make everything that doesn&#39;t coerce to a currency 1.</span>
<span class="sd">    :param remove_non_numeric: Will remove rows of a DataFrame that contain</span>
<span class="sd">        non-numeric values in the `column_name` column. Defaults to `False`.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Convert this to a notebook.</span>
    <span class="c1"># :Example Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data = {</span>
    <span class="c1">#         &quot;a&quot;: [&quot;-$1.00&quot;, &quot;&quot;, &quot;REPAY&quot;] * 2 + [&quot;$23.00&quot;, &quot;&quot;,</span>
    <span class="c1"># &quot;Other Account&quot;],</span>
    <span class="c1">#         &quot;Bell__Chart&quot;: [1.234_523_45, 2.456_234, 3.234_612_5] * 3,</span>
    <span class="c1">#         &quot;decorated-elephant&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;animals@#$%^&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
    <span class="c1">#         &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3,</span>
    <span class="c1">#     }</span>
    <span class="c1">#     df = pd.DataFrame(data)</span>

    <span class="c1"># :Example 1: Coerce numeric values in column to float:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2   NaN     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5   NaN     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     8   NaN     3.234612                   3         lion      Basel</span>

    <span class="c1"># :Example 2: Coerce numeric values in column to float, and replace a</span>
    <span class="c1"># string\</span>
    <span class="c1"># value with a specific value:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     cast_non_numeric = {&quot;REPAY&quot;: 22}</span>
    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, cast_non_numeric=cast_non_numeric)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     8   NaN     3.234612                   3         lion      Basel</span>

    <span class="c1"># :Example 3: Coerce numeric values in column to float, and replace all\</span>
    <span class="c1">#     string value with a specific value:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, fill_all_non_numeric=35)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2  35.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5  35.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     8  35.0     3.234612                   3         lion      Basel</span>

    <span class="c1"># :Example 4: Coerce numeric values in column to float, replace a string\</span>
    <span class="c1">#     value with a specific value, and replace remaining string values</span>
    <span class="c1"># with\</span>
    <span class="c1">#     a specific value:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, cast_non_numeric=cast_non_numeric,</span>
    <span class="c1">#     fill_all_non_numeric=35)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     8  35.0     3.234612                   3         lion      Basel</span>

    <span class="c1"># :Example 5: Coerce numeric values in column to float, and remove string\</span>
    <span class="c1">#     values:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, remove_non_numeric=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>

    <span class="c1"># :Example 6: Coerce numeric values in column to float, replace a string\</span>
    <span class="c1">#     value with a specific value, and remove remaining string values:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, cast_non_numeric=cast_non_numeric,</span>
    <span class="c1">#     remove_non_numeric=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>

    <span class="n">column_series</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cleaning_style</span> <span class="o">==</span> <span class="s2">&quot;accounting&quot;</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="n">_clean_accounting_column</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">if</span> <span class="n">cast_non_numeric</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;cast_non_numeric&quot;</span><span class="p">,</span> <span class="n">cast_non_numeric</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">])</span>

    <span class="n">_make_cc_patrial</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">_currency_column_to_numeric</span><span class="p">,</span> <span class="n">cast_non_numeric</span><span class="o">=</span><span class="n">cast_non_numeric</span>
    <span class="p">)</span>

    <span class="n">column_series</span> <span class="o">=</span> <span class="n">column_series</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">_make_cc_patrial</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_non_numeric</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">column_series</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># _replace_empty_string_with_none is applied here after the check on</span>
    <span class="c1"># remove_non_numeric since &quot;&quot; is our indicator that a string was coerced</span>
    <span class="c1"># in the original column</span>
    <span class="n">column_series</span> <span class="o">=</span> <span class="n">_replace_empty_string_with_none</span><span class="p">(</span><span class="n">column_series</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fill_all_non_numeric</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;fill_all_non_numeric&quot;</span><span class="p">,</span> <span class="n">fill_all_non_numeric</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
        <span class="n">column_series</span> <span class="o">=</span> <span class="n">column_series</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_all_non_numeric</span><span class="p">)</span>

    <span class="n">column_series</span> <span class="o">=</span> <span class="n">_replace_original_empty_string_with_none</span><span class="p">(</span><span class="n">column_series</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">column_name</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">column_series</span><span class="p">)})</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="select_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.select_columns.html#janitor.select_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">search_cols</span><span class="o">=</span><span class="s2">&quot;search_column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">select_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">search_column_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">invert</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Method-chainable selection of columns.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Optional ability to invert selection of columns available as well.</span>

<span class="sd">    Method-chaining example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).select_columns([&#39;a&#39;, &#39;b&#39;, &#39;col_*&#39;], invert=True)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param search_column_names: A list of column names or search strings to be</span>
<span class="sd">        used to select. Valid inputs include:</span>
<span class="sd">        1) an exact column name to look for</span>
<span class="sd">        2) a shell-style glob string (e.g., `*_thing_*`)</span>
<span class="sd">    :param invert: Whether or not to invert the selection.</span>
<span class="sd">        This will result in selection of the complement of the columns</span>
<span class="sd">        provided.</span>
<span class="sd">    :returns: A pandas DataFrame with the specified columns selected.</span>
<span class="sd">    :raises TypeError: if input is not passed as a list.</span>
<span class="sd">    :raises NameError: if one or more of the specified column names or</span>
<span class="sd">        search strings are not found in DataFrame columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">search_column_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Column name(s) or search string(s) must be passed as list&quot;</span>
        <span class="p">)</span>

    <span class="n">wildcards</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">search_column_names</span> <span class="k">if</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">}</span>
    <span class="n">non_wildcards</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">search_column_names</span><span class="p">)</span> <span class="o">-</span> <span class="n">wildcards</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">non_wildcards</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">nonexistent_column_names</span> <span class="o">=</span> <span class="n">non_wildcards</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">nonexistent_column_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> missing from DataFrame&quot;</span>
        <span class="p">)</span>

    <span class="n">missing_wildcards</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">full_column_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">search_column_names</span><span class="p">:</span>
        <span class="n">search_string</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">search_string</span><span class="p">,</span> <span class="n">col</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">missing_wildcards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">full_column_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_wildcards</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Search string(s) </span><span class="si">{</span><span class="n">missing_wildcards</span><span class="si">}</span><span class="s2"> not found in DataFrame&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">full_column_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">invert</span> <span class="k">else</span> <span class="n">df</span><span class="p">[</span><span class="n">full_column_list</span><span class="p">]</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="impute"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.impute.html#janitor.impute">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">statistic</span><span class="o">=</span><span class="s2">&quot;statistic_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">impute</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">statistic_column_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Method-chainable imputation of values in a column.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Underneath the hood, this function calls the ``.fillna()`` method available</span>
<span class="sd">    to every pandas.Series object.</span>

<span class="sd">    Method-chaining example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        data = {</span>
<span class="sd">            &quot;a&quot;: [1, 2, 3],</span>
<span class="sd">            &quot;sales&quot;: np.nan,</span>
<span class="sd">            &quot;score&quot;: [np.nan, 3, 2]}</span>
<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(data)</span>
<span class="sd">            # Impute null values with 0</span>
<span class="sd">            .impute(column_name=&#39;sales&#39;, value=0.0)</span>
<span class="sd">            # Impute null values with median</span>
<span class="sd">            .impute(column_name=&#39;score&#39;, statistic_column_name=&#39;median&#39;)</span>
<span class="sd">        )</span>

<span class="sd">    Either one of ``value`` or ``statistic_column_name`` should be provided.</span>

<span class="sd">    If ``value`` is provided, then all null values in the selected column will</span>
<span class="sd">        take on the value provided.</span>

<span class="sd">    If ``statistic_column_name`` is provided, then all null values in the</span>
<span class="sd">    selected column will take on the summary statistic value of other non-null</span>
<span class="sd">    values.</span>

<span class="sd">    Currently supported statistics include:</span>

<span class="sd">    - ``mean`` (also aliased by ``average``)</span>
<span class="sd">    - ``median``</span>
<span class="sd">    - ``mode``</span>
<span class="sd">    - ``minimum`` (also aliased by ``min``)</span>
<span class="sd">    - ``maximum`` (also aliased by ``max``)</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param column_name: The name of the column on which to impute values.</span>
<span class="sd">    :param value: (optional) The value to impute.</span>
<span class="sd">    :param statistic_column_name: (optional) The column statistic to impute.</span>
<span class="sd">    :returns: An imputed pandas DataFrame.</span>
<span class="sd">    :raises ValueError: if both ``value`` and ``statistic`` are provided.</span>
<span class="sd">    :raises KeyError: if ``statistic`` is not one of ``mean``, ``average``</span>
<span class="sd">        ``median``, ``mode``, ``minimum``, ``min``, ``maximum``, or ``max``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Firstly, we check that only one of `value` or `statistic` are provided.</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">statistic_column_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Only one of `value` or `statistic` should be provided&quot;</span>
        <span class="p">)</span>

    <span class="c1"># If statistic is provided, then we compute the relevant summary statistic</span>
    <span class="c1"># from the other data.</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
        <span class="s2">&quot;average&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>  <span class="c1"># aliased</span>
        <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">,</span>
        <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="p">,</span>
        <span class="s2">&quot;minimum&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
        <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>  <span class="c1"># aliased</span>
        <span class="s2">&quot;maximum&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
        <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>  <span class="c1"># aliased</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">statistic_column_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check that the statistic keyword argument is one of the approved.</span>
        <span class="k">if</span> <span class="n">statistic_column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`statistic` must be one of </span><span class="si">{</span><span class="n">funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="n">statistic_column_name</span><span class="p">](</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="c1"># special treatment for mode, because scipy stats mode returns a</span>
        <span class="c1"># moderesult object.</span>
        <span class="k">if</span> <span class="n">statistic_column_name</span> <span class="o">==</span> <span class="s2">&quot;mode&quot;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># The code is architected this way - if `value` is not provided but</span>
    <span class="c1"># statistic is, we then overwrite the None value taken on by `value`, and</span>
    <span class="c1"># use it to set the imputation column.</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="then"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.then.html#janitor.then">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">then</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add an arbitrary function to run in the ``pyjanitor`` method chain.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param func: A function you would like to run in the method chain.</span>
<span class="sd">        It should take one parameter and return one parameter, each being the</span>
<span class="sd">        DataFrame object. After that, do whatever you want in the middle.</span>
<span class="sd">        Go crazy.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="also"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.also.html#janitor.also">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">also</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add an arbitrary function with no return value to run in the</span>
<span class="sd">    ``pyjanitor`` method chain. This returns the input dataframe instead,</span>
<span class="sd">    not the output of `func`.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .query(...)</span>
<span class="sd">            .also(lambda df: print(f&quot;DataFrame shape is: {df.shape}&quot;))</span>
<span class="sd">            .transform_column(...)</span>
<span class="sd">            .also(lambda df: df.to_csv(&quot;midpoint.csv&quot;))</span>
<span class="sd">            .also(</span>
<span class="sd">                lambda df: print(</span>
<span class="sd">                    f&quot;Column col_name has these values: {set(df[&#39;col_name&#39;].unique())}&quot;</span>
<span class="sd">                )</span>
<span class="sd">            )</span>
<span class="sd">            .group_add(...)</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param func: A function you would like to run in the method chain.</span>
<span class="sd">        It should take one DataFrame object as a parameter and have no return.</span>
<span class="sd">        If there is a return, it will be ignored.</span>
<span class="sd">    :param args: Optional arguments for ``func``.</span>
<span class="sd">    :param kwargs: Optional keyword arguments for ``func``.</span>
<span class="sd">    :returns: The input pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">func</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="dropnotnull"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.dropnotnull.html#janitor.dropnotnull">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dropnotnull</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Drop rows that do not have null values in the given column.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).dropnotnull(&#39;column3&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column name to drop rows from.</span>
<span class="sd">    :returns: A pandas DataFrame with dropped rows.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">])]</span></div>


<div class="viewcode-block" id="find_replace"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.find_replace.html#janitor.find_replace">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">find_replace</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;exact&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">mappings</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Perform a find-and-replace action on provided columns.</span>

<span class="sd">    Depending on use case, users can choose either exact, full-value matching,</span>
<span class="sd">    or regular-expression-based fuzzy matching</span>
<span class="sd">    (hence allowing substring matching in the latter case).</span>
<span class="sd">    For strings, the matching is always case sensitive.</span>

<span class="sd">    For instance, given a dataframe containing orders at a coffee shop:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame({</span>
<span class="sd">            &#39;customer&#39;: [&#39;Mary&#39;, &#39;Tom&#39;, &#39;Lila&#39;],</span>
<span class="sd">            &#39;order&#39;: [&#39;ice coffee&#39;, &#39;lemonade&#39;, &#39;regular coffee&#39;]</span>
<span class="sd">        })</span>

<span class="sd">    Our task is to replace values `&#39;ice coffee&#39;` and `&#39;regular coffee&#39;`</span>
<span class="sd">    of the `&#39;order&#39;` column into `&#39;latte&#39;`.</span>

<span class="sd">    Example 1 for exact matching</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # Functional usage</span>
<span class="sd">        df = find_replace(</span>
<span class="sd">            df,</span>
<span class="sd">            match=&#39;exact&#39;,</span>
<span class="sd">            order={&#39;ice coffee&#39;: &#39;latte&#39;, &#39;regular coffee&#39;: &#39;latte&#39;},</span>
<span class="sd">        )</span>

<span class="sd">        # Method chaining usage</span>
<span class="sd">        df = df.find_replace(</span>
<span class="sd">            match=&#39;exact&#39;</span>
<span class="sd">            order={&#39;ice coffee&#39;: &#39;latte&#39;, &#39;regular coffee&#39;: &#39;latte&#39;},</span>
<span class="sd">        )</span>

<span class="sd">    Example 2: Regular-expression-based matching</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # Functional usage</span>
<span class="sd">        df = find_replace(</span>
<span class="sd">            df,</span>
<span class="sd">            match=&#39;regex&#39;,</span>
<span class="sd">            order={&#39;coffee$&#39;: &#39;latte&#39;},</span>
<span class="sd">        )</span>

<span class="sd">        # Method chaining usage</span>
<span class="sd">        df = df.find_replace(</span>
<span class="sd">            match=&#39;regex&#39;,</span>
<span class="sd">            order={&#39;coffee$&#39;: &#39;latte&#39;},</span>
<span class="sd">        )</span>

<span class="sd">    To perform a find and replace on the entire dataframe,</span>
<span class="sd">    pandas&#39; ``df.replace()`` function provides the appropriate functionality.</span>
<span class="sd">    You can find more detail on the replace_ docs.</span>

<span class="sd">    This function only works with column names that have no spaces</span>
<span class="sd">    or punctuation in them.</span>
<span class="sd">    For example, a column name ``item_name`` would work with ``find_replace``,</span>
<span class="sd">    because it is a contiguous string that can be parsed correctly,</span>
<span class="sd">    but ``item name`` would not be parsed correctly by the Python interpreter.</span>

<span class="sd">    If you have column names that might not be compatible,</span>
<span class="sd">    we recommend calling on ``clean_names()`` as the first method call.</span>
<span class="sd">    If, for whatever reason, that is not possible,</span>
<span class="sd">    then ``_find_replace()`` is available as a function</span>
<span class="sd">    that you can do a pandas pipe_ call on.</span>

<span class="sd">    .. _replace: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html</span>
<span class="sd">    .. _pipe: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pipe.html</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param match: Whether or not to perform an exact match or not.</span>
<span class="sd">        Valid values are &quot;exact&quot; or &quot;regex&quot;.</span>
<span class="sd">    :param mappings: keyword arguments corresponding to column names</span>
<span class="sd">        that have dictionaries passed in indicating what to find (keys)</span>
<span class="sd">        and what to replace with (values).</span>
<span class="sd">    :returns: A pandas DataFrame with replaced values.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="k">for</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">mapper</span> <span class="ow">in</span> <span class="n">mappings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">_find_replace</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="k">def</span> <span class="nf">_find_replace</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mapper</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;exact&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Utility function for ``find_replace``.</span>

<span class="sd">    The code in here was the original implementation of ``find_replace``,</span>
<span class="sd">    but we decided to change out the front-facing API to accept</span>
<span class="sd">    kwargs + dictionaries for readability,</span>
<span class="sd">    and instead dispatch underneath to this function.</span>
<span class="sd">    This implementation was kept</span>
<span class="sd">    because it has a number of validations that are quite useful.</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column on which the find/replace action is to be</span>
<span class="sd">        made. Must be a string.</span>
<span class="sd">    :param mapper: A dictionary that maps &quot;thing to find&quot; -&gt; &quot;thing to</span>
<span class="sd">        replace&quot;.  Note: Does not support null-value replacement.</span>
<span class="sd">    :param match: A string that dictates whether exact match or</span>
<span class="sd">        regular-expression-based fuzzy match will be used for finding patterns.</span>
<span class="sd">        Default to &quot;exact&quot;. Can only be &quot;exact&quot; or &quot;regex&quot;.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    :raises ValueError: is trying to use null replacement. Kindly use</span>
<span class="sd">        ``.fillna()`` instead.</span>
<span class="sd">    :raises ValueError: if ``match`` is not one of &#39;exact&#39; or &#39;regex&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">,</span> <span class="n">mapper</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;find_replace() does not support null replacement. &quot;</span>
            <span class="s2">&quot;Use DataFrame.fillna() instead.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;exact&quot;</span><span class="p">,</span> <span class="s2">&quot;regex&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`match` can only be &#39;exact&#39; or &#39;regex&#39;.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;exact&quot;</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;regex&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">condition</span><span class="p">,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">df</span>


<div class="viewcode-block" id="update_where"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.update_where.html#janitor.update_where">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">target_col</span><span class="o">=</span><span class="s2">&quot;target_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update_where</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">conditions</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">target_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">target_val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add multiple conditions to update a column in the dataframe.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # The dataframe must be assigned to a variable first.</span>
<span class="sd">        data = {</span>
<span class="sd">            &quot;a&quot;: [1, 2, 3, 4],</span>
<span class="sd">            &quot;b&quot;: [5, 6, 7, 8],</span>
<span class="sd">            &quot;c&quot;: [0, 0, 0, 0]</span>
<span class="sd">        }</span>
<span class="sd">        df = pd.DataFrame(data)</span>
<span class="sd">        df = (</span>
<span class="sd">            df</span>
<span class="sd">            .update_where(</span>
<span class="sd">                condition=(&quot;a &gt; 2 and b &lt; 8&quot;,</span>
<span class="sd">                target_column_name=&#39;c&#39;,</span>
<span class="sd">                target_val=10)</span>
<span class="sd">            )</span>
<span class="sd">        # a b  c</span>
<span class="sd">        # 1 5  0</span>
<span class="sd">        # 2 6  0</span>
<span class="sd">        # 3 7 10</span>
<span class="sd">        # 4 8  0</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param conditions: Conditions used to update a target column</span>
<span class="sd">        and target value.</span>
<span class="sd">    :param target_column_name: Column to be updated. If column does not exist</span>
<span class="sd">        in dataframe, a new column will be created; note that entries that do</span>
<span class="sd">        not get set in the new column will be null.</span>
<span class="sd">    :param target_val: Value to be updated</span>
<span class="sd">    :returns: An updated pandas DataFrame.</span>
<span class="sd">    :raises IndexError: if ``conditions`` does not have the same length as</span>
<span class="sd">        ``df``.</span>
<span class="sd">    :raises TypeError: if ``conditions`` is not a pandas-compatible string</span>
<span class="sd">        query.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># use query mode if a string expression is passed</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conditions</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">conditions_index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conditions_index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">conditions</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">conditions_index</span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_val</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="to_datetime"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.to_datetime.html#janitor.to_datetime">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">to_datetime</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Method-chainable to_datetime.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = to_datetime(df, &#39;col1&#39;, format=&#39;%Y%m%d&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).to_datetime(&#39;col1&#39;, format=&#39;%Y%m%d&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: Column name.</span>
<span class="sd">    :param kwargs: provide any kwargs that pd.to_datetime can take.</span>
<span class="sd">    :returns: A pandas DataFrame with updated datetime data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="groupby_agg"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.groupby_agg.html#janitor.groupby_agg">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">new_column</span><span class="o">=</span><span class="s2">&quot;new_column_name&quot;</span><span class="p">,</span> <span class="n">agg_column</span><span class="o">=</span><span class="s2">&quot;agg_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">groupby_agg</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">by</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">new_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">agg_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">agg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Shortcut for assigning a groupby-transform to a new column.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Without this function, we would have to write a verbose line:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = df.assign(...=df.groupby(...)[...].transform(...))</span>

<span class="sd">    Now, this function can be method-chained:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).groupby_agg(by=&#39;group&#39;,</span>
<span class="sd">                                           agg=&#39;mean&#39;,</span>
<span class="sd">                                           agg_column_name=&quot;col1&quot;</span>
<span class="sd">                                           new_column_name=&#39;col1_mean_by_group&#39;)</span>

<span class="sd">    Example Link : https://pyjanitor.readthedocs.io/notebooks/groupby_agg.html</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param by: Column(s) to groupby on, either a `str` or</span>
<span class="sd">               a `list` of `str`</span>
<span class="sd">    :param new_column_name: Name of the aggregation output column.</span>
<span class="sd">    :param agg_column_name: Name of the column to aggregate over.</span>
<span class="sd">    :param agg: How to aggregate.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># convert to list</span>
    <span class="c1"># needed when creating a mapping through the iteration</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">by</span> <span class="o">=</span> <span class="p">[</span><span class="n">by</span><span class="p">]</span>
    <span class="c1"># this is a temporary measure, till the minimum Pandas version is 1.1,</span>
    <span class="c1"># which supports null values in the group by</span>
    <span class="c1"># If any of the grouping columns has null values, we temporarily</span>
    <span class="c1"># replace the values with some outrageous value, that should not exist</span>
    <span class="c1"># in the column. Also, the hasnans property is significantly faster than</span>
    <span class="c1"># .isnull().any()</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">hasnans</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">by</span><span class="p">):</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">column</span><span class="p">:</span> <span class="s2">&quot;.*^</span><span class="si">%s</span><span class="s2">1ho1go1logoban?*&amp;-|/</span><span class="se">\\</span><span class="s2">gos1he()#_&quot;</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">by</span>
        <span class="p">}</span>

        <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="p">)[</span><span class="n">agg_column_name</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="p">)[</span><span class="n">agg_column_name</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_accessor</span><span class="p">(</span><span class="s2">&quot;data_description&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DataDescription</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;High-level description of data present in this DataFrame.</span>

<span class="sd">    This is a custom data accessor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize DataDescription class.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_get_data_df</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;column_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;pct_missing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_desc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a table of descriptive information in a DataFrame format.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data_df</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human-readable representation of the `DataDescription` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_data_df</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print the table of descriptive information about this DataFrame.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">desc</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Update the description for each of the columns in the DataFrame.</span>

<span class="sd">        :param desc: The structure containing the descriptions to update</span>
<span class="sd">        :raises ValueError: if length of description list does not match</span>
<span class="sd">            number of columns in DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Length of description list &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match number of columns in &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;DataFrame (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">desc</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="o">=</span> <span class="n">desc</span>


<div class="viewcode-block" id="bin_numeric"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.bin_numeric.html#janitor.bin_numeric">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">from_column</span><span class="o">=</span><span class="s2">&quot;from_column_name&quot;</span><span class="p">,</span> <span class="n">to_column</span><span class="o">=</span><span class="s2">&quot;to_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bin_numeric</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">from_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">to_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">num_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generate a new column that labels bins for a specified numeric column.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Makes use of pandas cut() function to bin data of one column, generating a</span>
<span class="sd">    new column with the results.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .bin_numeric(</span>
<span class="sd">                from_column_name=&#39;col1&#39;,</span>
<span class="sd">                to_column_name=&#39;col1_binned&#39;,</span>
<span class="sd">                num_bins=3,</span>
<span class="sd">                labels=[&#39;1-2&#39;, &#39;3-4&#39;, &#39;5-6&#39;]</span>
<span class="sd">                )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param from_column_name: The column whose data you want binned.</span>
<span class="sd">    :param to_column_name: The new column to be created with the binned data.</span>
<span class="sd">    :param num_bins: The number of bins to be utilized.</span>
<span class="sd">    :param labels: Optionally rename numeric bin ranges with labels. Number of</span>
<span class="sd">        label names must match number of bins specified.</span>
<span class="sd">    :return: A pandas DataFrame.</span>
<span class="sd">    :raises ValueError: if number of labels do not match number of bins.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">to_column_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">from_column_name</span><span class="p">)],</span> <span class="n">bins</span><span class="o">=</span><span class="n">num_bins</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_bins</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of labels must match number of bins.&quot;</span><span class="p">)</span>

        <span class="n">df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">to_column_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">from_column_name</span><span class="p">)],</span> <span class="n">bins</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="drop_duplicate_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.drop_duplicate_columns.html#janitor.drop_duplicate_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">drop_duplicate_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">nth_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Remove a duplicated column specified by column_name, its index.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Column order 0 is to remove the first column,</span>
<span class="sd">           order 1 is to remove the second column, and etc</span>

<span class="sd">    The corresponding tidyverse R&#39;s library is:</span>
<span class="sd">    `select(-&lt;column_name&gt;_&lt;nth_index + 1&gt;)`</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame({</span>
<span class="sd">            &quot;a&quot;: range(10),</span>
<span class="sd">            &quot;b&quot;: range(10),</span>
<span class="sd">            &quot;A&quot;: range(10, 20),</span>
<span class="sd">            &quot;a*&quot;: range(20, 30),</span>
<span class="sd">        }).clean_names(remove_special=True)</span>

<span class="sd">        # remove a duplicated second &#39;a&#39; column</span>
<span class="sd">        df.drop_duplicate_columns(column_name=&quot;a&quot;, nth_index=1)</span>



<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param column_name: Column to be removed</span>
<span class="sd">    :param nth_index: Among the duplicated columns,</span>
<span class="sd">        select the nth column to drop.</span>
<span class="sd">    :return: A pandas DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="n">col_indexes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">col_idx</span>
        <span class="k">for</span> <span class="n">col_idx</span><span class="p">,</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col_name</span> <span class="o">==</span> <span class="n">column_name</span>
    <span class="p">]</span>

    <span class="c1"># given that a column could be duplicated,</span>
    <span class="c1"># user could opt based on its order</span>
    <span class="n">removed_col_idx</span> <span class="o">=</span> <span class="n">col_indexes</span><span class="p">[</span><span class="n">nth_index</span><span class="p">]</span>
    <span class="c1"># get the column indexes without column that is being removed</span>
    <span class="n">filtered_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">c_i</span> <span class="k">for</span> <span class="n">c_i</span><span class="p">,</span> <span class="n">c_v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="k">if</span> <span class="n">c_i</span> <span class="o">!=</span> <span class="n">removed_col_idx</span>
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">filtered_cols</span><span class="p">]</span></div>


<div class="viewcode-block" id="take_first"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.take_first.html#janitor.take_first">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">take_first</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">subset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]],</span>
    <span class="n">by</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Take the first row within each group specified by `subset`.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        data = {</span>
<span class="sd">            &quot;a&quot;: [&quot;x&quot;, &quot;x&quot;, &quot;y&quot;, &quot;y&quot;],</span>
<span class="sd">            &quot;b&quot;: [0, 1, 2, 3]</span>
<span class="sd">        }</span>
<span class="sd">        df = pd.DataFrame(data)</span>

<span class="sd">        df.take_first(subset=&quot;a&quot;, by=&quot;b&quot;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param subset: Column(s) defining the group.</span>
<span class="sd">    :param by: Column to sort by.</span>
<span class="sd">    :param ascending: Whether or not to sort in ascending order, `bool`.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">by</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
        <span class="n">subset</span><span class="o">=</span><span class="n">subset</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="shuffle"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.shuffle.html#janitor.shuffle">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reset_index</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Shuffle the rows of the DataFrame.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Super-sugary syntax! Underneath the hood, we use ``df.sample(frac=1)``,</span>
<span class="sd">    with the option to set the random state.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).shuffle()</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param random_state: (optional) A seed for the random number generator.</span>
<span class="sd">    :param reset_index: (optional) Resets index to default integers</span>
<span class="sd">    :returns: A shuffled pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">reset_index</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="join_apply"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.join_apply.html#janitor.join_apply">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">join_apply</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">new_column_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Join the result of applying a function across dataframe rows.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    This is a convenience function that allows us to apply arbitrary functions</span>
<span class="sd">    that take any combination of information from any of the columns. The only</span>
<span class="sd">    requirement is that the function signature takes in a row from the</span>
<span class="sd">    DataFrame.</span>

<span class="sd">    The example below shows us how to sum the result of two columns into a new</span>
<span class="sd">    column.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame({&#39;a&#39;:[1, 2, 3], &#39;b&#39;: [2, 3, 4]})</span>
<span class="sd">            .join_apply(lambda x: 2 * x[&#39;a&#39;] + x[&#39;b&#39;], new_column_name=&quot;2a+b&quot;)</span>
<span class="sd">        )</span>

<span class="sd">    This following example shows us how to use conditionals in the same</span>
<span class="sd">    function.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        def take_a_if_even(x):</span>
<span class="sd">            if x[&#39;a&#39;] % 2:</span>
<span class="sd">                return x[&#39;a&#39;]</span>
<span class="sd">            else:</span>
<span class="sd">                return x[&#39;b&#39;]</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame({&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [2, 3, 4]})</span>
<span class="sd">            .join_apply(take_a_if_even, &#39;a_if_even&#39;)</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param func: A function that is applied elementwise across all rows of the</span>
<span class="sd">        DataFrame.</span>
<span class="sd">    :param new_column_name: New column name.</span>
<span class="sd">    :returns: A pandas DataFrame with new column appended.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">new_column_name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="flag_nulls"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.flag_nulls.html#janitor.flag_nulls">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">flag_nulls</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;null_flag&quot;</span><span class="p">,</span>
    <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Creates a new column to indicate whether you have null values in a given</span>
<span class="sd">    row. If the columns parameter is not set, looks across the entire</span>
<span class="sd">    DataFrame, otherwise will look only in the columns you set.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(</span>
<span class="sd">            {&#39;a&#39;: [1, 2, None, 4],</span>
<span class="sd">             &#39;b&#39;: [5.0, None, 7.0, 8.0]})</span>

<span class="sd">        df.flag_nulls()</span>
<span class="sd">        #  &#39;a&#39; | &#39;b&#39;  | &#39;null_flag&#39;</span>
<span class="sd">        #   1  | 5.0  |   0</span>
<span class="sd">        #   2  | NaN  |   1</span>
<span class="sd">        #  NaN | 7.0  |   1</span>
<span class="sd">        #   4  | 8.0  |   0</span>

<span class="sd">        jn.functions.flag_nulls(df)</span>
<span class="sd">        #  &#39;a&#39; | &#39;b&#39;  | &#39;null_flag&#39;</span>
<span class="sd">        #   1  | 5.0  |   0</span>
<span class="sd">        #   2  | NaN  |   1</span>
<span class="sd">        #  NaN | 7.0  |   1</span>
<span class="sd">        #   4  | 8.0  |   0</span>

<span class="sd">        df.flag_nulls(columns=[&#39;b&#39;])</span>
<span class="sd">        #  &#39;a&#39; | &#39;b&#39;  | &#39;null_flag&#39;</span>
<span class="sd">        #   1  | 5.0  |   0</span>
<span class="sd">        #   2  | NaN  |   1</span>
<span class="sd">        #  NaN | 7.0  |   0</span>
<span class="sd">        #   4  | 8.0  |   0</span>


<span class="sd">    :param df: Input Pandas dataframe.</span>
<span class="sd">    :param column_name: Name for the output column. Defaults to &#39;null_flag&#39;.</span>
<span class="sd">    :param columns: List of columns to look at for finding null values. If you</span>
<span class="sd">        only want to look at one column, you can simply give its name. If set</span>
<span class="sd">        to None (default), all DataFrame columns are used.</span>
<span class="sd">    :returns: Input dataframe with the null flag column.</span>
<span class="sd">    :raises ValueError: if ``column_name`` is already present in the</span>
<span class="sd">        DataFrame.</span>
<span class="sd">    :raises ValueError: if a column within ``columns`` is no present in</span>
<span class="sd">        the DataFrame.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Sort out columns input</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="c1"># catches other hashable types</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>

    <span class="c1"># Input sanitation checks</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">present</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># This algorithm works best for n_rows &gt;&gt; n_cols. See issue #501</span>
    <span class="n">null_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
        <span class="n">null_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">null_array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]))</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">null_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="count_cumulative_unique"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.count_cumulative_unique.html#janitor.count_cumulative_unique">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">count_cumulative_unique</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">dest_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generates a running total of cumulative unique values in a given column.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = jn.functions.count_cumulative_unique(</span>
<span class="sd">            df=df,</span>
<span class="sd">            column_name=&#39;animals&#39;,</span>
<span class="sd">            dest_column_name=&#39;animals_unique_count&#39;,</span>
<span class="sd">            case_sensitive=True</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining usage example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = df.count_cumulative_unique(</span>
<span class="sd">            column_name=&#39;animals&#39;,</span>
<span class="sd">            dest_column_name=&#39;animals_unique_count&#39;,</span>
<span class="sd">            case_sensitive=True</span>
<span class="sd">        )</span>

<span class="sd">    A new column will be created containing a running</span>
<span class="sd">    count of unique values in the specified column.</span>
<span class="sd">    If `case_sensitive` is `True`, then the case of</span>
<span class="sd">    any letters will matter (i.e., &#39;a&#39; != &#39;A&#39;);</span>
<span class="sd">    otherwise, the case of any letters will not matter.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: Name of the column containing</span>
<span class="sd">        values from which a running count of unique values</span>
<span class="sd">        will be created.</span>
<span class="sd">    :param dest_column_name: The name of the new column containing the</span>
<span class="sd">        cumulative count of unique values that will be created.</span>
<span class="sd">    :param case_sensitive: Whether or not uppercase and lowercase letters</span>
<span class="sd">        will be considered equal (e.g., &#39;A&#39; != &#39;a&#39; if `True`).</span>

<span class="sd">    :returns: A pandas DataFrame with a new column containing a cumulative</span>
<span class="sd">        count of unique values from another column.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">case_sensitive</span><span class="p">:</span>
        <span class="c1"># Make it so that the the same uppercase and lowercase</span>
        <span class="c1"># letter are treated as one unique value</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="n">dest_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span>
            <span class="n">df</span><span class="p">[[</span><span class="n">column_name</span><span class="p">]]</span>
            <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">dummyabcxyz</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">dummyabcxyz</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
        <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="toset"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.toset.html#janitor.toset">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_series_method</span>
<span class="k">def</span> <span class="nf">toset</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return a set of the values.</span>

<span class="sd">    These are each a scalar type, which is a Python scalar</span>
<span class="sd">    (for str, int, float) or a pandas scalar</span>
<span class="sd">    (for Timestamp/Timedelta/Interval/Period)</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        series = pd.Series(...)</span>
<span class="sd">        s = jn.functions.toset(series=series)</span>

<span class="sd">    Method chaining usage example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        series = pd.Series(...)</span>
<span class="sd">        s = series.toset()</span>

<span class="sd">    :param series: A pandas series.</span>
<span class="sd">    :returns: A set of values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span></div>


<div class="viewcode-block" id="jitter"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.jitter.html#janitor.jitter">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">jitter</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">dest_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span>
    <span class="n">clip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Adds Gaussian noise (jitter) to the values of a column.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = jn.functions.jitter(</span>
<span class="sd">            df=df,</span>
<span class="sd">            column_name=&#39;values&#39;,</span>
<span class="sd">            dest_column_name=&#39;values_jitter&#39;,</span>
<span class="sd">            scale=1.0,</span>
<span class="sd">            clip=None,</span>
<span class="sd">            random_state=None,</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining usage example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = df.jitter(</span>
<span class="sd">            column_name=&#39;values&#39;,</span>
<span class="sd">            dest_column_name=&#39;values_jitter&#39;,</span>
<span class="sd">            scale=1.0,</span>
<span class="sd">            clip=None,</span>
<span class="sd">            random_state=None,</span>
<span class="sd">        )</span>

<span class="sd">    A new column will be created containing the values of the original column</span>
<span class="sd">    with Gaussian noise added.</span>
<span class="sd">    For each value in the column, a Gaussian distribution is created</span>
<span class="sd">    having a location (mean) equal to the value</span>
<span class="sd">    and a scale (standard deviation) equal to `scale`.</span>
<span class="sd">    A random value is then sampled from this distribution,</span>
<span class="sd">    which is the jittered value.</span>
<span class="sd">    If a tuple is supplied for `clip`,</span>
<span class="sd">    then any values of the new column less than `clip[0]`</span>
<span class="sd">    will be set to `clip[0]`,</span>
<span class="sd">    and any values greater than `clip[1]` will be set to `clip[1]`.</span>
<span class="sd">    Additionally, if a numeric value is supplied for `random_state`,</span>
<span class="sd">    this value will be used to set the random seed used for sampling.</span>
<span class="sd">    NaN values are ignored in this method.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: Name of the column containing</span>
<span class="sd">        values to add Gaussian jitter to.</span>
<span class="sd">    :param dest_column_name: The name of the new column containing the</span>
<span class="sd">        jittered values that will be created.</span>
<span class="sd">    :param scale: A positive value multiplied by the original</span>
<span class="sd">        column value to determine the scale (standard deviation) of the</span>
<span class="sd">        Gaussian distribution to sample from. (A value of zero results in</span>
<span class="sd">        no jittering.)</span>
<span class="sd">    :param clip: An iterable of two values (minimum and maximum) to clip</span>
<span class="sd">        the jittered values to, default to None.</span>
<span class="sd">    :param random_state: An integer or 1-d array value used to set the random</span>
<span class="sd">        seed, default to None.</span>

<span class="sd">    :returns: A pandas DataFrame with a new column containing Gaussian-</span>
<span class="sd">        jittered values from another column.</span>
<span class="sd">    :raises TypeError: if ``column_name`` is not numeric.</span>
<span class="sd">    :raises ValueError: if ``scale`` is not a numerical value</span>
<span class="sd">        greater than ``0``.</span>
<span class="sd">    :raises ValueError: if ``clip`` is not an iterable of length ``2``.</span>
<span class="sd">    :raises ValueError: if ``clip[0]`` is not less than ``clip[1]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check types</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>

    <span class="c1"># Check that `column_name` is a numeric column</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2"> must be a numeric column.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`scale` must be a numeric value greater than 0.&quot;</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
        <span class="c1"># Ensure `clip` has length 2</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clip</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`clip` must be an iterable of length 2.&quot;</span><span class="p">)</span>
        <span class="c1"># Ensure the values in `clip` are ordered as min, max</span>
        <span class="k">if</span> <span class="n">clip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">clip</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`clip[0]` must be less than `clip[1]`.&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">clip</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="n">dest_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="sort_naturally"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.sort_naturally.html#janitor.sort_naturally">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">sort_naturally</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">natsorted_kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Sort a DataFrame by a column using &quot;natural&quot; sorting.</span>

<span class="sd">    Natural sorting is distinct from</span>
<span class="sd">    the default lexiographical sorting provided by ``pandas``.</span>
<span class="sd">    For example, given the following list of items:</span>

<span class="sd">        [&quot;A1&quot;, &quot;A11&quot;, &quot;A3&quot;, &quot;A2&quot;, &quot;A10&quot;]</span>

<span class="sd">    lexicographical sorting would give us:</span>


<span class="sd">        [&quot;A1&quot;, &quot;A10&quot;, &quot;A11&quot;, &quot;A2&quot;, &quot;A3&quot;]</span>

<span class="sd">    By contrast, &quot;natural&quot; sorting would give us:</span>

<span class="sd">        [&quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A10&quot;, &quot;A11&quot;]</span>

<span class="sd">    This function thus provides &quot;natural&quot; sorting</span>
<span class="sd">    on a single column of a dataframe.</span>

<span class="sd">    To accomplish this, we do a natural sort</span>
<span class="sd">    on the unique values that are present in the dataframe.</span>
<span class="sd">    Then, we reconstitute the entire dataframe</span>
<span class="sd">    in the naturally sorted order.</span>

<span class="sd">    Natural sorting is provided by the Python package natsort_.</span>

<span class="sd">    .. _natsort: https://natsort.readthedocs.io/en/master/index.html</span>

<span class="sd">    All keyword arguments to ``natsort`` should be provided</span>
<span class="sd">    after the column name to sort by is provided.</span>
<span class="sd">    They are passed through to the ``natsorted`` function.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = jn.sort_naturally(</span>
<span class="sd">            df=df,</span>
<span class="sd">            column_name=&#39;alphanumeric_column&#39;,</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = df.sort_naturally(</span>
<span class="sd">            column_name=&#39;alphanumeric_column&#39;,</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column on which natural sorting should take place.</span>
<span class="sd">    :param natsorted_kwargs: Keyword arguments to be passed</span>
<span class="sd">        to natsort&#39;s ``natsorted`` function.</span>
<span class="sd">    :returns: A sorted pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_order</span> <span class="o">=</span> <span class="n">index_natsorted</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="o">**</span><span class="n">natsorted_kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">new_order</span><span class="p">,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="expand_grid"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.expand_grid.html#janitor.expand_grid">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">expand_grid</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">df_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">others</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a dataframe from a combination of all inputs.</span>

<span class="sd">    This works with a dictionary of name value pairs,</span>
<span class="sd">    and will work with structures that are not dataframes.</span>
<span class="sd">    If method-chaining to a dataframe,</span>
<span class="sd">    a key to represent the column name in the output must be provided.</span>

<span class="sd">    Note that if a MultiIndex dataframe or series is passed, the index/columns</span>
<span class="sd">    will be discarded, and a single indexed dataframe will be returned.</span>

<span class="sd">    The output will always be a dataframe.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame({&quot;x&quot;:range(1,3), &quot;y&quot;:[2,1]})</span>
<span class="sd">        others = {&quot;z&quot; : range(1,4)}</span>

<span class="sd">        df.expand_grid(df_key=&quot;df&quot;,others=others)</span>

<span class="sd">        # df_x |   df_y |   z</span>
<span class="sd">        #    1 |      2 |   1</span>
<span class="sd">        #    1 |      2 |   2</span>
<span class="sd">        #    1 |      2 |   3</span>
<span class="sd">        #    2 |      1 |   1</span>
<span class="sd">        #    2 |      1 |   2</span>
<span class="sd">        #    2 |      1 |   3</span>

<span class="sd">        #create a dataframe from all combinations in a dictionary</span>
<span class="sd">        data = {&quot;x&quot;:range(1,4), &quot;y&quot;:[1,2]}</span>

<span class="sd">        jn.expand_grid(others=data)</span>

<span class="sd">        #  x |   y</span>
<span class="sd">        #  1 |   1</span>
<span class="sd">        #  1 |   2</span>
<span class="sd">        #  2 |   1</span>
<span class="sd">        #  2 |   2</span>
<span class="sd">        #  3 |   1</span>
<span class="sd">        #  3 |   2</span>


<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.expand_grid(df=df, df_key=&quot;...&quot;, others={...})</span>

<span class="sd">    Method-chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...).expand_grid(df_key=&quot;bla&quot;,others={...})</span>

<span class="sd">    Usage independent of a dataframe</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        from janitor import expand_grid</span>

<span class="sd">        df = expand_grid({&quot;x&quot;:range(1,4), &quot;y&quot;:[1,2]})</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param df_key: name of key for the dataframe.</span>
<span class="sd">        It becomes the column name of the dataframe.</span>
<span class="sd">    :param others: A dictionary that contains the data</span>
<span class="sd">        to be combined with the dataframe.</span>
<span class="sd">        If no dataframe exists, all inputs</span>
<span class="sd">        in others will be combined to create a dataframe.</span>
<span class="sd">    :returns: A pandas dataframe of all combinations of name value pairs.</span>
<span class="sd">    :raises TypeError: if others is not a dictionary</span>
<span class="sd">    :raises KeyError: if there is a dataframe and no key is provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check if others is a dictionary</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># strictly name value pairs</span>
        <span class="c1"># same idea as in R and tidyverse implementation</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;others must be a dictionary&quot;</span><span class="p">)</span>
    <span class="c1"># if there is a dataframe, for the method chaining,</span>
    <span class="c1"># it must have a key, to create a name value pair</span>
    <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`expand_grid` does not work with pd.MultiIndex&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">df_key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Using `expand_grid` as part of a DataFrame method chain</span>
<span class="sd">                requires that a string `df_key` be passed in.</span>
<span class="sd">                &quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="n">others</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="n">df_key</span><span class="p">:</span> <span class="n">df</span><span class="p">},</span> <span class="o">**</span><span class="n">others</span><span class="p">}</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">_check_instance</span><span class="p">(</span><span class="n">others</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_grid_computation</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_text"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.process_text.html#janitor.process_text">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">process_text</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">string_function</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a Pandas string method to an existing column and return a dataframe.</span>

<span class="sd">    This function aims to make string cleaning easy, while chaining,</span>
<span class="sd">    by simply passing the string method name to the ``process_text`` function.</span>
<span class="sd">    Note that this modifies an existing column,</span>
<span class="sd">    and should not be used to create a new column.</span>
<span class="sd">    A list of all the string methods in Pandas can be accessed here:</span>
<span class="sd">    https://pandas.pydata.org/docs/user_guide/text.html#method-summary.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame({&quot;text&quot;:[&quot;ragnar&quot;,&quot;sammywemmy&quot;,&quot;ginger&quot;],</span>
<span class="sd">                           &quot;code&quot; : [1, 2, 3]})</span>

<span class="sd">        df.process_text(column = &quot;text&quot;, string_function = &quot;lower&quot;)</span>
<span class="sd">        # text       |   code</span>
<span class="sd">        # ragnar     |    1</span>
<span class="sd">        # sammywemmy |    2</span>
<span class="sd">        # ginger     |    3</span>

<span class="sd">        #For string methods with parameters, simply pass the arguments :</span>
<span class="sd">        df.process_text(</span>
<span class="sd">            column = &quot;text&quot;,</span>
<span class="sd">            string_function = &quot;extract&quot;,</span>
<span class="sd">            pat = r&quot;(ag)&quot;,</span>
<span class="sd">            flags = re.IGNORECASE</span>
<span class="sd">            )</span>

<span class="sd">        # text |   code</span>
<span class="sd">        # ag   |    1</span>
<span class="sd">        # NaN  |    2</span>
<span class="sd">        # NaN  |    3</span>


<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.process_text(</span>
<span class="sd">            df = df,</span>
<span class="sd">            string_function = &quot;string_func_name_here&quot;,</span>
<span class="sd">            args, kwargs</span>
<span class="sd">            )</span>

<span class="sd">    Method-chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .process_text(</span>
<span class="sd">                string_function = &quot;string_func_name_here&quot;,</span>
<span class="sd">                args, kwargs</span>
<span class="sd">                )</span>
<span class="sd">        )</span>


<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column: String column to be operated on.</span>
<span class="sd">    :param string_function: Pandas string method to be applied.</span>
<span class="sd">    :param args: Arguments for parameters.</span>
<span class="sd">    :param kwargs: Keyword arguments for parameters.</span>
<span class="sd">    :returns: A pandas dataframe with modified column.</span>
<span class="sd">    :raises KeyError: if ``string_function`` is not a Pandas string method.</span>
<span class="sd">    :raises TypeError: if wrong ``arg`` or ``kwarg`` is supplied.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">pandas_string_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">string_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pandas_string_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">string_function</span><span class="si">}</span><span class="s2"> is not a Pandas string method.&quot;</span><span class="p">)</span>

    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">string_function</span><span class="p">)(</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="fill_direction"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.fill_direction.html#janitor.fill_direction">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">fill_direction</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">directions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Provide a method-chainable function for filling missing values</span>
<span class="sd">    in selected columns.</span>

<span class="sd">    Missing values are filled using the next or previous entry.</span>
<span class="sd">    The columns are paired with the directions in a dictionary.</span>
<span class="sd">    It is a wrapper for ``pd.Series.ffill`` and ``pd.Series.bfill``.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame({&quot;text&quot;: [&quot;ragnar&quot;, np.nan, &quot;sammywemmy&quot;,</span>
<span class="sd">                                    np.nan, &quot;ginger&quot;],</span>
<span class="sd">                           &quot;code&quot; : [np.nan, 2, 3, np.nan, 5]})</span>

<span class="sd">        # Single column :</span>
<span class="sd">        df.fill_direction({&quot;text&quot; : &quot;up&quot;})</span>
<span class="sd">        # text       |   code</span>
<span class="sd">        # ragnar     |    NaN</span>
<span class="sd">        # sammywemmy |    2</span>
<span class="sd">        # sammywemmy |    3</span>
<span class="sd">        # ginger     |    NaN</span>
<span class="sd">        # ginger     |    5</span>

<span class="sd">        # Multiple columns :</span>
<span class="sd">        df.fill_direction({&quot;text&quot; : &quot;down&quot;, &quot;code&quot; : &quot;down&quot;})</span>

<span class="sd">        # text       |   code</span>
<span class="sd">        # ragnar     |    NaN</span>
<span class="sd">        # ragnar     |    2</span>
<span class="sd">        # sammywemmy |    3</span>
<span class="sd">        # sammywemmy |    3</span>
<span class="sd">        # ginger     |    5</span>

<span class="sd">        # Multiple columns in different directions.</span>
<span class="sd">        df.fill_direction({&quot;text&quot; : &quot;up&quot;, &quot;code&quot; : &quot;down&quot;})</span>

<span class="sd">        # text       |   code</span>
<span class="sd">        # ragnar     |    NaN</span>
<span class="sd">        # sammywemmy |    2</span>
<span class="sd">        # sammywemmy |    3</span>
<span class="sd">        # ginger     |    3</span>
<span class="sd">        # ginger     |    5</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.fill_direction(</span>
<span class="sd">            df = df,</span>
<span class="sd">            directions = {column_1 : direction_1, column_2 : direction_2, ...},</span>
<span class="sd">            limit = None # limit must be None or greater than 0</span>
<span class="sd">            )</span>

<span class="sd">    Method-chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .fill_direction(</span>
<span class="sd">            directions = {column_1 : direction_1, column_2 : direction_2, ...},</span>
<span class="sd">            limit = None # limit must be None or greater than 0</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param directions: Key - value pairs of columns and directions. Directions</span>
<span class="sd">        can be either `down`(default), `up`, `updown`(fill up then down) and</span>
<span class="sd">        `downup` (fill down then up).</span>
<span class="sd">    :param limit: number of consecutive null values to forward/backward fill.</span>
<span class="sd">        Value must `None` or greater than 0.</span>
<span class="sd">    :returns: A pandas dataframe with modified column(s).</span>
<span class="sd">    :raises ValueError: if ``directions`` dictionary is empty.</span>
<span class="sd">    :raises ValueError: if column supplied is not in the dataframe.</span>
<span class="sd">    :raises ValueError: if direction supplied is not one of `down`,`up`,</span>
<span class="sd">        `updown`, or `downup`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># check that dictionary is not empty</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">directions</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A mapping of columns with directions is required.&quot;</span><span class="p">)</span>

    <span class="c1"># check that the right columns are provided</span>
    <span class="c1"># should be removed once the minimum Pandas version is 1.1,</span>
    <span class="c1"># as Pandas loc will raise a KeyError if columns provided do not exist</span>
    <span class="n">wrong_columns_provided</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">wrong_columns_provided</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrong_columns_provided</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">outcome</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">wrong_columns_provided</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Columns </span><span class="si">{</span><span class="n">outcome</span><span class="si">}</span><span class="s2"> do not exist in the dataframe.&quot;</span>
            <span class="p">)</span>
        <span class="n">outcome</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wrong_columns_provided</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">outcome</span><span class="si">}</span><span class="s2"> does not exist in the dataframe.&quot;</span><span class="p">)</span>

    <span class="c1"># check that the right directions are provided</span>
    <span class="n">set_directions</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="s2">&quot;updown&quot;</span><span class="p">,</span> <span class="s2">&quot;downup&quot;</span><span class="p">}</span>

    <span class="c1"># linter throws an error when I use dictionary.values()</span>
    <span class="c1"># it assumes that dictionary is a dataframe</span>
    <span class="n">directions_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">directions</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">wrong_directions_provided</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">directions_values</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
        <span class="n">set_directions</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">wrong_directions_provided</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;The direction should be a string and should be one of `up`,</span>
<span class="sd">            `down`, `updown`, or `downup`.&quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;updown&quot;</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;downup&quot;</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="groupby_topk"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.groupby_topk.html#janitor.groupby_topk">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">groupby_topk</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">groupby_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">sort_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sort_values_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return top `k` rows from a groupby of a set of columns.</span>

<span class="sd">    Returns a dataframe that has the top `k` values grouped by `groupby_column_name`</span>
<span class="sd">    and sorted by `sort_column_name`.</span>
<span class="sd">    Additional parameters to the sorting (such as ascending=True)</span>
<span class="sd">    can be passed using `sort_values_kwargs`.</span>

<span class="sd">    List of all sort_values() parameters can be found here_.</span>

<span class="sd">    .. _here: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html</span>


<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame({&#39;age&#39; : [20, 22, 24, 23, 21, 22],</span>
<span class="sd">                           &#39;ID&#39; : [1,2,3,4,5,6],</span>
<span class="sd">                           &#39;result&#39; : [&quot;pass&quot;, &quot;fail&quot;, &quot;pass&quot;,</span>
<span class="sd">                                       &quot;pass&quot;, &quot;fail&quot;, &quot;pass&quot;]})</span>

<span class="sd">        # Ascending top 3:</span>
<span class="sd">        df.groupby_topk(&#39;result&#39;, &#39;age&#39;, 3)</span>
<span class="sd">        #       age  ID  result</span>
<span class="sd">        #result</span>
<span class="sd">        #fail   21   5   fail</span>
<span class="sd">        #       22   2   fail</span>
<span class="sd">        #pass   20   1   pass</span>
<span class="sd">        #       22   6   pass</span>
<span class="sd">        #       23   4   pass</span>

<span class="sd">        #Descending top 2:</span>
<span class="sd">        df.groupby_topk(&#39;result&#39;, &#39;age&#39;, 2, {&#39;ascending&#39;:False})</span>
<span class="sd">        #       age  ID result</span>
<span class="sd">        #result</span>
<span class="sd">        #fail   22   2   fail</span>
<span class="sd">        #       21   5   fail</span>
<span class="sd">        #pass   24   3   pass</span>
<span class="sd">        #       23   4   pass</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.groupby_topk(</span>
<span class="sd">            df = df,</span>
<span class="sd">            groupby_column_name = &#39;groupby_column&#39;,</span>
<span class="sd">            sort_column_name = &#39;sort_column&#39;,</span>
<span class="sd">            k = 5</span>
<span class="sd">            )</span>

<span class="sd">    Method-chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .groupby_topk(</span>
<span class="sd">            df = df,</span>
<span class="sd">            groupby_column_name = &#39;groupby_column&#39;,</span>
<span class="sd">            sort_column_name = &#39;sort_column&#39;,</span>
<span class="sd">            k = 5</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param groupby_column_name: Column name to group input dataframe `df` by.</span>
<span class="sd">    :param sort_column_name: Name of the column to sort along the</span>
<span class="sd">        input dataframe `df`.</span>
<span class="sd">    :param k: Number of top rows to return from each group after sorting.</span>
<span class="sd">    :param sort_values_kwargs: Arguments to be passed to sort_values function.</span>
<span class="sd">    :returns: A pandas dataframe with top `k` rows that are grouped by</span>
<span class="sd">        `groupby_column_name` column with each group sorted along the</span>
<span class="sd">        column `sort_column_name`.</span>
<span class="sd">    :raises ValueError: if `k` is less than 1.</span>
<span class="sd">    :raises ValueError: if `groupby_column_name` not in dataframe `df`.</span>
<span class="sd">    :raises ValueError: if `sort_column_name` not in dataframe `df`.</span>
<span class="sd">    :raises KeyError: if `inplace:True` is present in `sort_values_kwargs`.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="c1"># Convert the default sort_values_kwargs from None to empty Dict</span>
    <span class="n">sort_values_kwargs</span> <span class="o">=</span> <span class="n">sort_values_kwargs</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="c1"># Check if groupby_column_name and sort_column_name exists in the dataframe</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="n">groupby_column_name</span><span class="p">,</span> <span class="n">sort_column_name</span><span class="p">])</span>

    <span class="c1"># Check if k is greater than 0.</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Numbers of rows per group to be returned must be greater than 0.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Check if inplace:True in sort values kwargs because it returns None</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="s2">&quot;inplace&quot;</span> <span class="ow">in</span> <span class="n">sort_values_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="ow">and</span> <span class="n">sort_values_kwargs</span><span class="p">[</span><span class="s2">&quot;inplace&quot;</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Cannot use `inplace=True` in `sort_values_kwargs`.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">groupby_column_name</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">sort_column_name</span><span class="p">,</span> <span class="o">**</span><span class="n">sort_values_kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="complete"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.complete.html#janitor.complete">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">complete</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">columns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function shows all possible combinations in a dataframe, including</span>
<span class="sd">    the missing values.</span>

<span class="sd">    This function is similar to tidyr&#39;s `complete` function.</span>

<span class="sd">    Individual combinations or combinations with groupings are possible.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">            Year      Taxon         Abundance</span>
<span class="sd">        0   1999    Saccharina         4</span>
<span class="sd">        1   2000    Saccharina         5</span>
<span class="sd">        2   2004    Saccharina         2</span>
<span class="sd">        3   1999     Agarum            1</span>
<span class="sd">        4   2004     Agarum            8</span>

<span class="sd">        Data Source - http://imachordata.com/2016/02/05/you-complete-me/</span>

<span class="sd">        Note that Year 2000 and Agarum pairing is missing. Let&#39;s make it</span>
<span class="sd">        explicit:</span>

<span class="sd">        df.complete(columns = [&#39;Year&#39;, &#39;Taxon&#39;])</span>

<span class="sd">           Year      Taxon     Abundance</span>
<span class="sd">        0  1999     Agarum         1.0</span>
<span class="sd">        1  1999     Saccharina     4.0</span>
<span class="sd">        2  2000     Agarum         NaN</span>
<span class="sd">        3  2000     Saccharina     5.0</span>
<span class="sd">        4  2004     Agarum         8.0</span>
<span class="sd">        5  2004     Saccharina     2.0</span>

<span class="sd">        The null value can be replaced with the fill_value argument:</span>

<span class="sd">        df.complete(columns = [&#39;Year&#39;, &#39;Taxon&#39;],</span>
<span class="sd">                    fill_value={&quot;Abundance&quot;:0})</span>

<span class="sd">           Year      Taxon     Abundance</span>
<span class="sd">        0  1999     Agarum         1.0</span>
<span class="sd">        1  1999     Saccharina     4.0</span>
<span class="sd">        2  2000     Agarum         0.0</span>
<span class="sd">        3  2000     Saccharina     5.0</span>
<span class="sd">        4  2004     Agarum         8.0</span>
<span class="sd">        5  2004     Saccharina     2.0</span>

<span class="sd">        What if we wanted the explicit missing values for all the years from</span>
<span class="sd">        1999 to 2004? Easy - simply pass a dictionary pairing the column name</span>
<span class="sd">        with the new values :</span>

<span class="sd">        df.complete(columns = [{&quot;Year&quot;: range(df.Year.min(),</span>
<span class="sd">                                              df.Year.max() + 1)},</span>
<span class="sd">                                       &quot;Taxon&quot;],</span>
<span class="sd">                    fill_value={&quot;Abundance&quot;:0})</span>

<span class="sd">            Year      Taxon     Abundance</span>
<span class="sd">        0   1999     Agarum         1.0</span>
<span class="sd">        1   1999    Saccharina      4.0</span>
<span class="sd">        2   2000     Agarum         0.0</span>
<span class="sd">        3   2000    Saccharina      5.0</span>
<span class="sd">        4   2001     Agarum         0.0</span>
<span class="sd">        5   2001    Saccharina      0.0</span>
<span class="sd">        6   2002     Agarum         0.0</span>
<span class="sd">        7   2002    Saccharina      0.0</span>
<span class="sd">        8   2003     Agarum         0.0</span>
<span class="sd">        9  2003     Saccharina      0.0</span>
<span class="sd">        10  2004     Agarum         8.0</span>
<span class="sd">        11  2004    Saccharina      2.0</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.complete(</span>
<span class="sd">            df = df,</span>
<span class="sd">            columns= [</span>
<span class="sd">                column_label,</span>
<span class="sd">                (column1, column2, ...),</span>
<span class="sd">                {column1: new_values, ...}</span>
<span class="sd">            ],</span>
<span class="sd">            fill_value = None</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .complete(columns=[</span>
<span class="sd">                column_label,</span>
<span class="sd">                (column1, column2, ...),</span>
<span class="sd">                {column1: new_values, ...},</span>
<span class="sd">            ],</span>
<span class="sd">            fill_value=None,</span>
<span class="sd">        )</span>


<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param columns: This is a list containing the columns to be</span>
<span class="sd">        completed. It could be column labels (string trype),</span>
<span class="sd">        a list/tuple of column labels, or a dictionary that pairs</span>
<span class="sd">        column labels with new values.</span>
<span class="sd">    :param fill_value: Dictionary pairing the columns with the null replacement</span>
<span class="sd">        value.</span>
<span class="sd">    :returns: A pandas dataframe with modified column(s).</span>
<span class="sd">    :raises ValueError: if `columns` is empty.</span>
<span class="sd">    :raises TypeError: if `columns` is not a list.</span>
<span class="sd">    :raises TypeError: if `fill_value` is not a dictionary.</span>
<span class="sd">    :raises ValueError: if entry in `columns` is not a</span>
<span class="sd">        str/dict/list/tuple.</span>
<span class="sd">    :raises ValueError: if entry in `columns` is a dict/list/tuple</span>
<span class="sd">        and is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Columns should be in a list&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;columns cannot be empty&quot;</span><span class="p">)</span>
    <span class="c1"># if there is no grouping within the list of columns :</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">):</span>
        <span class="c1"># Using sets gets more speed than say np.unique or drop_duplicates</span>
        <span class="n">reindex_columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
        <span class="n">reindex_columns</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">reindex_columns</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">reindex_columns</span> <span class="o">=</span> <span class="n">_complete_groupings</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">has_duplicates</span><span class="p">:</span>
        <span class="n">reindex_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">[],</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">reindex_columns</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reindex_columns</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">reindex_columns</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fill_value should be a dictionary.&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="k">def</span> <span class="nf">patterns</span><span class="p">(</span><span class="n">regex_pattern</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Pattern</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function converts a string into a compiled regular expression;</span>
<span class="sd">    it can be used to select columns in the index or columns_names</span>
<span class="sd">    arguments of ``pivot_longer`` function.</span>

<span class="sd">    :param regex_pattern: string to be converted to compiled regular</span>
<span class="sd">        expression.</span>
<span class="sd">    :returns: A compile regular expression from provided</span>
<span class="sd">        ``regex_pattern``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;regular expression&quot;</span><span class="p">,</span> <span class="n">regex_pattern</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex_pattern</span><span class="p">)</span>


<div class="viewcode-block" id="pivot_longer"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.pivot_longer.html#janitor.pivot_longer">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">pivot_longer</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
    <span class="n">values_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
    <span class="n">names_sep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_pattern</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtypes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unpivots a DataFrame from &#39;wide&#39; to &#39;long&#39; format.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    It is meant to serve as a single point for transformations of dataframes</span>
<span class="sd">    from wide to long form. It also offers more functionality and flexibility</span>
<span class="sd">    than `pd.wide_to_long`. It is modeled after the `pivot_longer` function in</span>
<span class="sd">    R&#39;s `tidyr` package.</span>

<span class="sd">    This function is useful to massage a DataFrame into a format where</span>
<span class="sd">    one or more columns are considered measured variables, and all other</span>
<span class="sd">    columns are considered as identifier variables.</span>

<span class="sd">    All measured variables are â€œunpivotedâ€ (and typically duplicated) along the</span>
<span class="sd">    row axis.</span>

<span class="sd">    This function is designed to work primarily with single indexed dataframes;</span>
<span class="sd">    If you wish to unpivot MultiIndexed dataframes, `pd.melt` is more than</span>
<span class="sd">    adequate.</span>

<span class="sd">    Example 1: The following DataFrame contains heartrate data for patients</span>
<span class="sd">    treated with two different drugs, &#39;a&#39; and &#39;b&#39;.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">              name   a   b</span>
<span class="sd">        0   Wilbur  67  56</span>
<span class="sd">        1  Petunia  80  90</span>
<span class="sd">        2  Gregory  64  50</span>

<span class="sd">    The column names &#39;a&#39; and &#39;b&#39; are actually the names of a measured variable</span>
<span class="sd">    (i.e. the name of a drug), but the values are a different measured variable</span>
<span class="sd">    (heartrate). We would like to unpivot these &#39;a&#39; and &#39;b&#39; columns into a</span>
<span class="sd">    &#39;drug&#39; column and a &#39;heartrate&#39; column.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).pivot_longer(column_names=[&#39;a&#39;, &#39;b&#39;],</span>
<span class="sd">                                            names_to=&#39;drug&#39;,</span>
<span class="sd">                                            values_to=&#39;heartrate&#39;)</span>

<span class="sd">              name drug  heartrate</span>
<span class="sd">        0   Wilbur    a         67</span>
<span class="sd">        1   Wilbur    b         56</span>
<span class="sd">        2  Petunia    a         80</span>
<span class="sd">        3  Petunia    b         90</span>
<span class="sd">        4  Gregory    a         64</span>
<span class="sd">        5  Gregory    b         50</span>

<span class="sd">    Example 2: The dataframe below has year and month variables embedded within</span>
<span class="sd">    the column names.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">            col1	    2019-12	 2020-01	 2020-02</span>
<span class="sd">        0	a	   -1.085631	-1.506295	-2.426679</span>
<span class="sd">        1	b	    0.997345	-0.578600	-0.428913</span>
<span class="sd">        2	c	    0.282978	 1.651437	 1.265936</span>

<span class="sd">    Pivot_longer can conveniently reshape the data into long format, with new</span>
<span class="sd">    columns for the year and month. We simply pass in the new column names to</span>
<span class="sd">    `names_to`, and pass the hyphen &#39;-&#39; to the `names_sep` argument. Note how</span>
<span class="sd">    this effectively replicates the pandas&#39; `wide_to_long` function.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">             .pivot_longer(index=&#39;col1&#39;,</span>
<span class="sd">                           names_to=(&#39;year&#39;,&#39;month&#39;),</span>
<span class="sd">                           names_sep=&#39;-&#39;)</span>
<span class="sd">              )</span>

<span class="sd">          col1  year   month      value</span>
<span class="sd">        0    a  2019     12     -1.085631</span>
<span class="sd">        1    a  2020     01     -1.506295</span>
<span class="sd">        2    a  2020     02     -2.426679</span>
<span class="sd">        3    b  2019     12      0.997345</span>
<span class="sd">        4    b  2020     01     -0.578600</span>
<span class="sd">        5    b  2020     02     -0.428913</span>
<span class="sd">        6    c  2019     12      0.282978</span>
<span class="sd">        7    c  2020     01      1.651437</span>
<span class="sd">        8    c  2020     02      1.265936</span>

<span class="sd">    Example 3: The dataframe below has names embedded in it</span>
<span class="sd">    (&#39;measure1&#39;, &#39;measure2&#39;) that we would love to reuse as</span>
<span class="sd">    column names.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">            treat1-measure1	treat1-measure2	treat2-measure1	treat2-measure2</span>
<span class="sd">        0	         1	        4	            2	            5</span>
<span class="sd">        1	         2	        5	            3	            4</span>

<span class="sd">    For this, we take advantage of the `.value` variable, which signals to</span>
<span class="sd">    `pivot_longer` to treat the part of the column names corresponding to</span>
<span class="sd">    `.value` as new column names.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(names_to=(&quot;group&quot;,&#39;.value&#39;),</span>
<span class="sd">                            names_sep = &#39;-&#39;)</span>
<span class="sd">              )</span>

<span class="sd">            group  measure1  measure2</span>
<span class="sd">        0  treat1         1         4</span>
<span class="sd">        1  treat2         2         5</span>
<span class="sd">        2  treat1         2         5</span>
<span class="sd">        3  treat2         3         4</span>

<span class="sd">    Let&#39;s break down the `.value` idea a bit. When `.value` is used,</span>
<span class="sd">    `pivot_longer` creates a pairing. In the example above, we get a pairing</span>
<span class="sd">    {&quot;group&quot;:[&quot;treat1&quot;, &quot;treat2&quot;], &quot;.value&quot;:[&quot;measure1&quot;, &quot;measure2&quot;]}. All</span>
<span class="sd">    the values associated with `.value` become new column names, while those</span>
<span class="sd">    not associated with `.value`(`treat1` and `treat2`) become values in a</span>
<span class="sd">    new column `group`. `values_to` is overridden during this process.</span>

<span class="sd">    Example 4: We can also pivot from wide to long using regular expressions</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">            n_1  n_2  n_3  pct_1  pct_2  pct_3</span>
<span class="sd">        0   10   20   30   0.1    0.2    0.3</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(names_to = (&quot;.value&quot;, &quot;name&quot;),</span>
<span class="sd">                            names_pattern = &quot;(.*)_(.)&quot;)</span>
<span class="sd">              )</span>

<span class="sd">            name    n  pct</span>
<span class="sd">        0     1  10.0  0.1</span>
<span class="sd">        1     2  20.0  0.2</span>
<span class="sd">        2     3  30.0  0.3</span>

<span class="sd">    The same idea of `.value` works here as well. Based on the capturing groups</span>
<span class="sd">    in the regex in `names_pattern`, we have two pairings --&gt;</span>
<span class="sd">    {&quot;.value&quot;:[&quot;n&quot;, &quot;pct&quot;], &quot;name&quot;:[1,2,3]}. Just like in the previous example,</span>
<span class="sd">    the values associated with `.value` become new column names, while those</span>
<span class="sd">    not associated with `.value` become values in the new column ``name``.</span>

<span class="sd">    Note that there are no limits to the pairing; however, you can only have</span>
<span class="sd">    one `.value` in ``names_to``.</span>

<span class="sd">    You can also take advantage of `janitor.patterns` function, which allows</span>
<span class="sd">    selection of columns via a regular expression; this can come in handy if</span>
<span class="sd">    you have a lot of column names to use as index, and do not wish to manually</span>
<span class="sd">    type them all.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">             name    wk1   wk2   wk3   wk4</span>
<span class="sd">        0    Alice     5     9    20    22</span>
<span class="sd">        1    Bob       7    11    17    33</span>
<span class="sd">        2    Carla     6    13    39    40</span>

<span class="sd">        df = pd.DataFrame(...).pivot_longer(janitor.patterns(&quot;^(?!wk)&quot;))</span>

<span class="sd">             name variable  value</span>
<span class="sd">        0   Alice      wk1      5</span>
<span class="sd">        1   Alice      wk2      9</span>
<span class="sd">        2   Alice      wk3     20</span>
<span class="sd">        3   Alice      wk4     22</span>
<span class="sd">        4     Bob      wk1      7</span>
<span class="sd">        5     Bob      wk2     11</span>
<span class="sd">        6     Bob      wk3     17</span>
<span class="sd">        7     Bob      wk4     33</span>
<span class="sd">        8   Carla      wk1      6</span>
<span class="sd">        9   Carla      wk2     13</span>
<span class="sd">        10  Carla      wk3     39</span>
<span class="sd">        11  Carla      wk4     40</span>

<span class="sd">    You can determine the data type of the resulting columns with</span>
<span class="sd">    the `dtypes` argument, which accepts a dictionary, pairing the column</span>
<span class="sd">    names with the expected types.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.pivot_longer(</span>
<span class="sd">            df = df,</span>
<span class="sd">            index = [column1, column2, ...],</span>
<span class="sd">            column_names = [column3, column4, ...],</span>
<span class="sd">            names_to = new_column_name,</span>
<span class="sd">            names_sep = string/regular expression,</span>
<span class="sd">            names_pattern = string/regular expression,</span>
<span class="sd">            value_name = new_column_name,</span>
<span class="sd">            dtypes = dtypes</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .pivot_longer(</span>
<span class="sd">                index = [column1, column2, ...],</span>
<span class="sd">                column_names = [column3, column4, ...],</span>
<span class="sd">                names_to = new_column_name,</span>
<span class="sd">                names_sep = string/regular expression,</span>
<span class="sd">                names_pattern = string/regular expression,</span>
<span class="sd">                value_name= new_column_name,</span>
<span class="sd">                dtypes = dtypes</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param index: Name(s) of columns to use as identifier variables.</span>
<span class="sd">        Should be either a single column name, or a list/tuple of</span>
<span class="sd">        column names. You can also dynamically select column names</span>
<span class="sd">        by using a regular expression with the `janitor.patterns`</span>
<span class="sd">        function.</span>
<span class="sd">    :param column_names: Name(s) of columns to unpivot. Should be either</span>
<span class="sd">        a single column name or a list/tuple of column names. You can also</span>
<span class="sd">        dynamically select column names by using a regular expression</span>
<span class="sd">        with the `janitor.patterns` function.</span>
<span class="sd">    :param names_to: Name of new column as a string that will contain</span>
<span class="sd">        what were previously the column names in `column_names`.</span>
<span class="sd">        The default is `variable` if no value is provided. It can</span>
<span class="sd">        also be a list/tuple of strings that will serve as new column</span>
<span class="sd">        names, if `name_sep` or `names_pattern` is provided.</span>
<span class="sd">        If `.value` is in `names_to`, new column names will be extracted</span>
<span class="sd">        from part of the existing column names and `values_to` will be</span>
<span class="sd">        replaced.</span>
<span class="sd">    :param names_sep: Determines how the column name is broken up, if</span>
<span class="sd">        `names_to` contains multiple values. It takes the same</span>
<span class="sd">        specification as pandas&#39; `str.split` method, and can be a string</span>
<span class="sd">        or regular expression.</span>
<span class="sd">    :param names_pattern: Determines how the column name is broken up.</span>
<span class="sd">        It can be a regular expression containing matching groups, or a</span>
<span class="sd">        list/tuple of regular expressions. For a list/tuple of</span>
<span class="sd">        regular expressions, ``names_to`` must also be a list/tuple and the</span>
<span class="sd">        lengths of both arguments must match. The entries in both arguments</span>
<span class="sd">        must also match positionally, i.e  if `regex1` in `names_pattern` is</span>
<span class="sd">        the first item, it will be aligned to `new_column_name_1` in `names_to`</span>
<span class="sd">        if `new_column_name_1` is the first item, and so on.</span>
<span class="sd">    :param values_to: Name of new column as a string that will contain what</span>
<span class="sd">        were previously the values of the columns in `column_names`.</span>
<span class="sd">    :param dtypes: A dictionary mapping data types to columns in the new</span>
<span class="sd">        dataframe.</span>
<span class="sd">    :returns: A pandas DataFrame that has been unpivoted from wide to long</span>
<span class="sd">        format.</span>
<span class="sd">    :raises TypeError: if `index` or `column_names` is not a string, or a</span>
<span class="sd">        list/tuple of strings, or a `janitor.patterns` function.</span>
<span class="sd">    :raises TypeError: if `names_to` or `column_names` is not a string, or a</span>
<span class="sd">        list/tuple of strings.</span>
<span class="sd">    :raises TypeError: if `values_to` is not a string.</span>
<span class="sd">    :raises TypeError: if `dtypes` is not a dictionary.</span>
<span class="sd">    :raises ValueError: if `names_to` is a list/tuple, and both `names_sep` and</span>
<span class="sd">        `names_pattern` are provided.</span>
<span class="sd">    :raises ValueError: if `names_to` is a string or a list/tuple of length 1,</span>
<span class="sd">        and `names_sep` is provided.</span>
<span class="sd">    :raises TypeError: if `names_sep` or `names_pattern` is not a string or</span>
<span class="sd">        regular expression.</span>
<span class="sd">    :raises ValueError: if `names_to` is a list/tuple, and its length does not</span>
<span class="sd">        match the number of extracted columns.</span>
<span class="sd">    :raises ValueError: if `df` is a MultiIndex dataframe.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># this code builds on the wonderful work of @benjaminjackâ€™s PR</span>
    <span class="c1"># https://github.com/benjaminjack/pyjanitor/commit/e3df817903c20dd21634461c8a92aec137963ed0</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">column_names</span><span class="p">,</span>
        <span class="n">names_to</span><span class="p">,</span>
        <span class="n">values_to</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">names_pattern</span><span class="p">,</span>
        <span class="n">dtypes</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_data_checks_pivot_longer</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">column_names</span><span class="p">,</span>
        <span class="n">names_to</span><span class="p">,</span>
        <span class="n">values_to</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">names_pattern</span><span class="p">,</span>
        <span class="n">dtypes</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">df</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">column_names</span> <span class="o">=</span> <span class="n">_pivot_longer_pattern_match</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">column_names</span>
    <span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">_computations_pivot_longer</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">column_names</span><span class="p">,</span>
        <span class="n">names_to</span><span class="p">,</span>
        <span class="n">values_to</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">names_pattern</span><span class="p">,</span>
        <span class="n">dtypes</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="pivot_wider"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.pivot_wider.html#janitor.pivot_wider">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">pivot_wider</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_from</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">values_from</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_sort</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">flatten_levels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">values_from_first</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">names_prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_sep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reshapes data from long to wide form. The number of columns are</span>
<span class="sd">    increased, while decreasing the number of rows. It is the inverse</span>
<span class="sd">    of the `pivot_longer` method, and is a wrapper around</span>
<span class="sd">    `pd.DataFrame.unstack`</span>
<span class="sd">    method.</span>
<span class="sd">    This method does not mutate the original DataFrame.</span>
<span class="sd">    Reshaping to wide form :</span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">             name variable  value</span>
<span class="sd">        0   Alice      wk1      5</span>
<span class="sd">        1   Alice      wk2      9</span>
<span class="sd">        2   Alice      wk3     20</span>
<span class="sd">        3   Alice      wk4     22</span>
<span class="sd">        4     Bob      wk1      7</span>
<span class="sd">        5     Bob      wk2     11</span>
<span class="sd">        6     Bob      wk3     17</span>
<span class="sd">        7     Bob      wk4     33</span>
<span class="sd">        8   Carla      wk1      6</span>
<span class="sd">        9   Carla      wk2     13</span>
<span class="sd">        10  Carla      wk3     39</span>
<span class="sd">        11  Carla      wk4     40</span>
<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .pivot_wider(</span>
<span class="sd">                index=&quot;name&quot;,</span>
<span class="sd">                names_from=&quot;variable&quot;,</span>
<span class="sd">                values_from=&quot;value&quot;</span>
<span class="sd">            )</span>
<span class="sd">             name    wk1   wk2   wk3   wk4</span>
<span class="sd">        0    Alice     5     9    20    22</span>
<span class="sd">        1    Bob       7    11    17    33</span>
<span class="sd">        2    Carla     6    13    39    40</span>
<span class="sd">    Pivoting on multiple columns is possible :</span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">            name    n  pct</span>
<span class="sd">        0     1  10.0  0.1</span>
<span class="sd">        1     2  20.0  0.2</span>
<span class="sd">        2     3  30.0  0.3</span>
<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .assign(num=0)</span>
<span class="sd">            .pivot_wider(</span>
<span class="sd">                index=&#39;num&#39;,</span>
<span class="sd">                names_from=&quot;name&quot;,</span>
<span class="sd">                values_from=[&quot;n&quot;, &quot;pct&quot;]</span>
<span class="sd">             )</span>
<span class="sd">         )</span>
<span class="sd">            num n_1  n_2  n_3  pct_1  pct_2  pct_3</span>
<span class="sd">        0   0   10   20   30   0.1    0.2    0.3</span>
<span class="sd">    .. note:: You may choose not to collapse the levels by passing `False`</span>
<span class="sd">        to the ``collapse_levels`` argument.</span>
<span class="sd">    .. note:: An error is raised if the index is not unique.</span>
<span class="sd">    Functional usage syntax:</span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>
<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.pivot_wider(</span>
<span class="sd">            df = df,</span>
<span class="sd">            index = [column1, column2, ...],</span>
<span class="sd">            names_from = [column3, column4, ...],</span>
<span class="sd">            value_from = [column5, column6, ...],</span>
<span class="sd">            names_sort = True/False,</span>
<span class="sd">            names_prefix = string,</span>
<span class="sd">            names_sep = string,</span>
<span class="sd">            flatten_levels=True/False,</span>
<span class="sd">            values_from_first=True/False,</span>
<span class="sd">            fill_value=fill_value</span>
<span class="sd">        )</span>
<span class="sd">    Method chaining syntax:</span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .pivot_wider(</span>
<span class="sd">                index = [column1, column2, ...],</span>
<span class="sd">                names_from = [column3, column4, ...],</span>
<span class="sd">                value_from = [column5, column6, ...],</span>
<span class="sd">                names_sort = True/False,</span>
<span class="sd">                names_prefix = string,</span>
<span class="sd">                names_sep = string,</span>
<span class="sd">                flatten_levels=True/False,</span>
<span class="sd">                values_from_first=True/False,</span>
<span class="sd">                fill_value=fill_value</span>
<span class="sd">                )</span>
<span class="sd">        )</span>
<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param index: Name(s) of columns to use as identifier variables.</span>
<span class="sd">        Should be either a single column name, or a list of column names.</span>
<span class="sd">        If `index` is not provided, the current frame&#39;s index is used.</span>
<span class="sd">    :param names_from: Name(s) of columns to pivot. Should be either</span>
<span class="sd">        a single column name, or a list of column names. A label or labels</span>
<span class="sd">        must be provided for ``names_from``.</span>
<span class="sd">    :param values_from: Name of column that will be used for populating new</span>
<span class="sd">        frame&#39;s values. Should be either a single column name, or a list of</span>
<span class="sd">        column names. By default, if ``values_from`` is a list, the value</span>
<span class="sd">        will be added to the front of the output column; you can turn this</span>
<span class="sd">        off with the `values_from_first` argument. If ``values_from`` is not</span>
<span class="sd">        specified, all remaining columns will be used.</span>
<span class="sd">    :param names_sort: Default is `False`. Sorts columns by order of</span>
<span class="sd">        appearance. Applicable only if ``flatten_levels`` is `True`.</span>
<span class="sd">    :param flatten_levels: Default is `True`. Determines if the reshaped</span>
<span class="sd">        dataframe stays as a MultiIndex.</span>
<span class="sd">    :param values_from_first: Determines if the values in ``values_from`` will</span>
<span class="sd">        be at the front of the output column. This applies if ``values_from``</span>
<span class="sd">        is a list, and the levels are flattened. Default is True.</span>
<span class="sd">    :param names_prefix: String to be added to the front of each output column.</span>
<span class="sd">        Can be handy if the values in ``names_from`` are numeric data types.</span>
<span class="sd">        Applicable only if the levels are flattened.</span>
<span class="sd">    :param names_sep: If ``names_from`` or ``values_from`` contain multiple</span>
<span class="sd">        variables, this will be used to join their values into a single string</span>
<span class="sd">        to use as a column name. Default is ``_``. Applicable only if the</span>
<span class="sd">        levels are flattened.</span>
<span class="sd">    :param fill_value: Value to replace missing values with (after pivoting).</span>
<span class="sd">        It can be a number, string, or a dictionary, where the keys are the</span>
<span class="sd">        column_names, while the values are the values to replace the missing</span>
<span class="sd">        values with.</span>
<span class="sd">    :returns: A pandas DataFrame that has been unpivoted from long to wide</span>
<span class="sd">        form.</span>
<span class="sd">    :raises TypeError: if `index` or `names_from` is not a string, or a list of</span>
<span class="sd">        strings.</span>
<span class="sd">    :raises ValueError: if `names_from` is None.</span>
<span class="sd">    :raises TypeError: if `names_sep` is not a string.</span>
<span class="sd">    :raises TypeError: if `values_from` is not a string or a list of strings.</span>
<span class="sd">    :raises TypeError: if `names_sort` is not a boolean.</span>
<span class="sd">    :raises TypeError: if `flatten_levels` is not a boolean.</span>
<span class="sd">    :raises ValueError: if values in `index` or `names_from` or `values_from`</span>
<span class="sd">        do not exist in the dataframe.</span>
<span class="sd">    :raises ValueError: if the combination of `index` and `names_from` is not</span>
<span class="sd">        unique.</span>


<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">names_from</span><span class="p">,</span>
        <span class="n">values_from</span><span class="p">,</span>
        <span class="n">names_sort</span><span class="p">,</span>
        <span class="n">flatten_levels</span><span class="p">,</span>
        <span class="n">values_from_first</span><span class="p">,</span>
        <span class="n">names_prefix</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_data_checks_pivot_wider</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">names_from</span><span class="p">,</span>
        <span class="n">values_from</span><span class="p">,</span>
        <span class="n">names_sort</span><span class="p">,</span>
        <span class="n">flatten_levels</span><span class="p">,</span>
        <span class="n">values_from_first</span><span class="p">,</span>
        <span class="n">names_prefix</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">_computations_pivot_wider</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">names_from</span><span class="p">,</span>
        <span class="n">values_from</span><span class="p">,</span>
        <span class="n">names_sort</span><span class="p">,</span>
        <span class="n">flatten_levels</span><span class="p">,</span>
        <span class="n">values_from_first</span><span class="p">,</span>
        <span class="n">names_prefix</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo_title.svg" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Contributors</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, PyJanitor devs.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>