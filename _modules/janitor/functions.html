
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>janitor.functions &#8212; pyjanitor  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for janitor.functions</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; General purpose data cleaning functions. &quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">unicodedata</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">NamedTuple</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Pattern</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pandas_flavor</span> <span class="k">as</span> <span class="nn">pf</span>
<span class="kn">from</span> <span class="nn">multipledispatch</span> <span class="kn">import</span> <span class="n">dispatch</span>
<span class="kn">from</span> <span class="nn">natsort</span> <span class="kn">import</span> <span class="n">index_natsorted</span>
<span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span>
    <span class="n">union_categoricals</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="n">OutOfBoundsDatetime</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">mode</span>

<span class="kn">from</span> <span class="nn">.errors</span> <span class="kn">import</span> <span class="n">JanitorError</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_clean_accounting_column</span><span class="p">,</span>
    <span class="n">_computations_as_categorical</span><span class="p">,</span>
    <span class="n">_computations_complete</span><span class="p">,</span>
    <span class="n">_computations_expand_grid</span><span class="p">,</span>
    <span class="n">_computations_pivot_longer</span><span class="p">,</span>
    <span class="n">_computations_pivot_wider</span><span class="p">,</span>
    <span class="n">_currency_column_to_numeric</span><span class="p">,</span>
    <span class="n">_data_checks_pivot_longer</span><span class="p">,</span>
    <span class="n">_data_checks_pivot_wider</span><span class="p">,</span>
    <span class="n">_process_text</span><span class="p">,</span>
    <span class="n">_replace_empty_string_with_none</span><span class="p">,</span>
    <span class="n">_replace_original_empty_string_with_none</span><span class="p">,</span>
    <span class="n">_select_columns</span><span class="p">,</span>
    <span class="n">_strip_underscores</span><span class="p">,</span>
    <span class="n">asCategorical</span><span class="p">,</span>
    <span class="n">check</span><span class="p">,</span>
    <span class="n">check_column</span><span class="p">,</span>
    <span class="n">deprecated_alias</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="unionize_dataframe_categories"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.unionize_dataframe_categories.html#janitor.unionize_dataframe_categories">[docs]</a><span class="k">def</span> <span class="nf">unionize_dataframe_categories</span><span class="p">(</span>
    <span class="o">*</span><span class="n">dataframes</span><span class="p">,</span> <span class="n">column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a group of dataframes which contain some categorical columns, for</span>
<span class="sd">    each categorical column present, find all the possible categories across</span>
<span class="sd">    all the dataframes which have that column.</span>
<span class="sd">    Update each dataframes&#39; corresponding column with a new categorical object</span>
<span class="sd">    that contains the original data</span>
<span class="sd">    but has labels for all the possible categories from all dataframes.</span>
<span class="sd">    This is useful when concatenating a list of dataframes which all have the</span>
<span class="sd">    same categorical columns into one dataframe.</span>

<span class="sd">    If, for a given categorical column, all input dataframes do not have at</span>
<span class="sd">    least one instance of all the possible categories,</span>
<span class="sd">    Pandas will change the output dtype of that column from ``category`` to</span>
<span class="sd">    ``object``, losing out on dramatic speed gains you get from the former</span>
<span class="sd">    format.</span>

<span class="sd">    Usage example for concatenation of categorical column-containing</span>
<span class="sd">    dataframes:</span>

<span class="sd">    Instead of:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        concatenated_df = pd.concat([df1, df2, df3], ignore_index=True)</span>

<span class="sd">    which in your case has resulted in ``category`` -&gt; ``object`` conversion,</span>
<span class="sd">    use:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        unionized_dataframes = unionize_dataframe_categories(df1, df2, df2)</span>
<span class="sd">        concatenated_df = pd.concat(unionized_dataframes, ignore_index=True)</span>

<span class="sd">    :param dataframes: The dataframes you wish to unionize the categorical</span>
<span class="sd">        objects for.</span>
<span class="sd">    :param column_names: If supplied, only unionize this subset of columns.</span>
<span class="sd">    :returns: A list of the category-unioned dataframes in the same order they</span>
<span class="sd">        were provided.</span>
<span class="sd">    :raises TypeError: if any inputs are not pandas DataFrames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Inputs must all be dataframes.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">column_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Find all columns across all dataframes that are categorical</span>

        <span class="n">column_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="p">:</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="n">column_names</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">column_name</span>
                    <span class="k">for</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">column_names</span><span class="p">]</span>
    <span class="c1"># For each categorical column, find all possible values across the DFs</span>

    <span class="n">category_unions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">column_name</span><span class="p">:</span> <span class="n">union_categoricals</span><span class="p">(</span>
            <span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span> <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">column_names</span>
    <span class="p">}</span>

    <span class="c1"># Make a shallow copy of all DFs and modify the categorical columns</span>
    <span class="c1"># such that they can encode the union of all possible categories for each.</span>

    <span class="n">refactored_dfs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">categorical</span> <span class="ow">in</span> <span class="n">category_unions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">categories</span><span class="o">=</span><span class="n">categorical</span><span class="o">.</span><span class="n">categories</span>
                <span class="p">)</span>

        <span class="n">refactored_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">refactored_dfs</span></div>


<div class="viewcode-block" id="move"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.move.html#janitor.move">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">move</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">source</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;before&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Move column or row to a position adjacent to another column or row in</span>
<span class="sd">    dataframe. Must have unique column names or indices.</span>

<span class="sd">    This operation does not reset the index of the dataframe. User must</span>
<span class="sd">    explicitly do so.</span>

<span class="sd">    Does not apply to multilevel dataframes.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = move(df, source=3, target=15, position=&#39;after&#39;, axis=0)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).move(source=3, target=15, position=&#39;after&#39;,</span>
<span class="sd">        axis=0)</span>

<span class="sd">    :param df: The pandas Dataframe object.</span>
<span class="sd">    :param source: column or row to move</span>
<span class="sd">    :param target: column or row to move adjacent to</span>
<span class="sd">    :param position: Specifies whether the Series is moved to before or</span>
<span class="sd">        after the adjacent Series. Values can be either &#39;before&#39; or &#39;after&#39;;</span>
<span class="sd">        defaults to &#39;before&#39;.</span>
<span class="sd">    :param axis: Axis along which the function is applied. 0 to move a</span>
<span class="sd">        row, 1 to move a column.</span>
<span class="sd">    :returns: The dataframe with the Series moved.</span>
<span class="sd">    :raises ValueError: if ``axis`` is not ``0`` or ``1``.</span>
<span class="sd">    :raises ValueError: if ``position`` is not ``before`` or ``after``.</span>
<span class="sd">    :raises ValueError: if  ``source`` row or column is not in dataframe.</span>
<span class="sd">    :raises ValueError: if ``target`` row or column is not in dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid axis &#39;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&#39;. Can only be 0 or 1.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;before&quot;</span><span class="p">,</span> <span class="s2">&quot;after&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid position &#39;</span><span class="si">{</span><span class="n">position</span><span class="si">}</span><span class="s2">&#39;. Can only be &#39;before&#39; or &#39;after&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Source row &#39;</span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&#39; not in dataframe.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target row &#39;</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&#39; not in dataframe.&quot;</span><span class="p">)</span>

        <span class="n">names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;after&quot;</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">names</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">names</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Source column &#39;</span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">&#39; not in dataframe.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target column &#39;</span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&#39; not in dataframe.&quot;</span><span class="p">)</span>

        <span class="n">names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">position</span> <span class="o">==</span> <span class="s2">&quot;after&quot;</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">names</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">names</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="clean_names"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.clean_names.html#janitor.clean_names">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">clean_names</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">strip_underscores</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">case_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span>
    <span class="n">remove_special</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">strip_accents</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">preserve_original_columns</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">enforce_string</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">truncate_limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clean column names.</span>

<span class="sd">    Takes all column names, converts them to lowercase,</span>
<span class="sd">    then replaces all spaces with underscores.</span>

<span class="sd">    By default, column names are converted to string types.</span>
<span class="sd">    This can be switched off by passing in ``enforce_string=False``.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = clean_names(df)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).clean_names()</span>

<span class="sd">    :Example of transformation:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        Columns before: First Name, Last Name, Employee Status, Subject</span>
<span class="sd">        Columns after: first_name, last_name, employee_status, subject</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param strip_underscores: (optional) Removes the outer underscores from all</span>
<span class="sd">        column names. Default None keeps outer underscores. Values can be</span>
<span class="sd">        either &#39;left&#39;, &#39;right&#39; or &#39;both&#39; or the respective shorthand &#39;l&#39;, &#39;r&#39;</span>
<span class="sd">        and True.</span>
<span class="sd">    :param case_type: (optional) Whether to make columns lower or uppercase.</span>
<span class="sd">        Current case may be preserved with &#39;preserve&#39;,</span>
<span class="sd">        while snake case conversion (from CamelCase or camelCase only)</span>
<span class="sd">        can be turned on using &quot;snake&quot;.</span>
<span class="sd">        Default &#39;lower&#39; makes all characters lowercase.</span>
<span class="sd">    :param remove_special: (optional) Remove special characters from columns.</span>
<span class="sd">        Only letters, numbers and underscores are preserved.</span>
<span class="sd">    :param strip_accents: Whether or not to remove accents from</span>
<span class="sd">        columns names.</span>
<span class="sd">    :param preserve_original_columns: (optional) Preserve original names.</span>
<span class="sd">        This is later retrievable using `df.original_columns`.</span>
<span class="sd">    :param enforce_string: Whether or not to convert all column names</span>
<span class="sd">        to string type. Defaults to True, but can be turned off.</span>
<span class="sd">        Columns with &gt;1 levels will not be converted by default.</span>
<span class="sd">    :param truncate_limit: (optional) Truncates formatted column names to</span>
<span class="sd">        the specified length. Default None does not truncate.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_column_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">enforce_string</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_change_case</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">case_type</span><span class="p">))</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">_normalize_1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_special</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">_remove_special</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">strip_accents</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">_strip_accents</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;_+&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>  <span class="c1"># noqa: PD005</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">_strip_underscores</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">strip_underscores</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[:</span><span class="n">truncate_limit</span><span class="p">])</span>

    <span class="c1"># Store the original column names, if enabled by user</span>
    <span class="k">if</span> <span class="n">preserve_original_columns</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;original_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_column_names</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="k">def</span> <span class="nf">_change_case</span><span class="p">(</span><span class="n">col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">case_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Change case of a column name.&quot;&quot;&quot;</span>

    <span class="n">case_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;preserve&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;snake&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">case_types</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;case_type must be one of: </span><span class="si">{</span><span class="n">case_types</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;preserve&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">case_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;snake&quot;</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">_camel2snake</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">col</span>


<span class="k">def</span> <span class="nf">_remove_special</span><span class="p">(</span><span class="n">col_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Remove special characters from column name.&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="ow">or</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">item</span>
    <span class="p">)</span>


<span class="n">_underscorer1</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.)([A-Z][a-z]+)&quot;</span><span class="p">)</span>
<span class="n">_underscorer2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;([a-z0-9])([A-Z])&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_camel2snake</span><span class="p">(</span><span class="n">col_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert camelcase names to snake case.</span>

<span class="sd">    Implementation taken from: https://gist.github.com/jaytaylor/3660565</span>
<span class="sd">    by @jtaylor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subbed</span> <span class="o">=</span> <span class="n">_underscorer1</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\1_\2&quot;</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span>  <span class="c1"># noqa: PD005</span>
    <span class="k">return</span> <span class="n">_underscorer2</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\1_\2&quot;</span><span class="p">,</span> <span class="n">subbed</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="c1"># noqa: PD005</span>


<span class="n">FIXES</span> <span class="o">=</span> <span class="p">[(</span><span class="sa">r</span><span class="s2">&quot;[ /:,?()\.-]&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">),</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[&#39;’]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[\xa0]&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_normalize_1</span><span class="p">(</span><span class="n">col_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Perform normalization of column name.&quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">search</span><span class="p">,</span> <span class="n">replace</span> <span class="ow">in</span> <span class="n">FIXES</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">search</span><span class="p">,</span> <span class="n">replace</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>  <span class="c1"># noqa: PD005</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_strip_accents</span><span class="p">(</span><span class="n">col_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Remove accents from a DataFrame column name.</span>
<span class="sd">    .. _StackOverflow: https://stackoverflow.com/questions/517923/what-is-the-best-way-to-remove-accents-in-a-python-unicode-strin</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">letter</span>
        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s2">&quot;NFD&quot;</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unicodedata</span><span class="o">.</span><span class="n">combining</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
    <span class="p">)</span>


<div class="viewcode-block" id="remove_empty"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.remove_empty.html#janitor.remove_empty">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">remove_empty</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Drop all rows and columns that are completely null.</span>

<span class="sd">    This method also resets the index(by default) since it doesn&#39;t make sense</span>
<span class="sd">    to preserve the index of a completely empty row.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Implementation is inspired from `StackOverflow`_.</span>

<span class="sd">    .. _StackOverflow: https://stackoverflow.com/questions/38884538/python-pandas-find-all-rows-where-all-values-are-nan</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = remove_empty(df)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).remove_empty()</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>

<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">nanrows</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">nanrows</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">nancols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">nancols</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="get_dupes"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.get_dupes.html#janitor.get_dupes">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_dupes</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return all duplicate rows.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = get_dupes(df)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).get_dupes()</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param column_names: (optional) A column name or an iterable</span>
<span class="sd">        (list or tuple) of column names. Following pandas API, this only</span>
<span class="sd">        considers certain columns for identifying duplicates. Defaults to using</span>
<span class="sd">        all columns.</span>
<span class="sd">    :returns: The duplicate rows, as a pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dupes</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">column_names</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">dupes</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>  <span class="c1"># noqa: E712</span></div>


<span class="k">def</span> <span class="nf">As_Categorical</span><span class="p">(</span>
    <span class="n">categories</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NamedTuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for `encode_categorical`. It makes creating the</span>
<span class="sd">    `categories` and `order` more explicit. Inspired by pd.NamedAgg.</span>
<span class="sd">    :param categories: list-like object to create new categorical column.</span>
<span class="sd">    :param order: string object that can be either &quot;sort&quot; or &quot;appearance&quot;.</span>
<span class="sd">        If &quot;sort&quot;, the `categories` argument will be sorted with np.sort;</span>
<span class="sd">        if &quot;apperance&quot;, the `categories` argument will be used as is.</span>
<span class="sd">    :returns: A namedtuple of (`categories`, `order`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">asCategorical</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="n">categories</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<div class="viewcode-block" id="encode_categorical"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.encode_categorical.html#janitor.encode_categorical">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">encode_categorical</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Encode the specified columns with Pandas&#39;</span>
<span class="sd">    `category dtype &lt;http://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html&gt;`_.</span>

<span class="sd">    Categories and order can be explicitly specified via the `kwargs` option, which is a</span>
<span class="sd">    pairing of column name and a tuple of (categories, order).</span>

<span class="sd">    The `janitor.As_Categorical` function is provided to make it clearer what the arguments</span>
<span class="sd">    to the function are.</span>

<span class="sd">    It is syntactic sugar around `pd.Categorical`.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    .. note:: In versions &lt; 0.20.11, this method mutates the original DataFrame.</span>

<span class="sd">    **Examples:**</span>


<span class="sd">    .. code-block:: python</span>

<span class="sd">               col1	col2	col3</span>
<span class="sd">        0	2.0	a	2020-01-01</span>
<span class="sd">        1	1.0	b	2020-01-02</span>
<span class="sd">        2	3.0	c	2020-01-03</span>
<span class="sd">        3	1.0	d	2020-01-04</span>
<span class="sd">        4	NaN	a	2020-01-05</span>

<span class="sd">        df.dtypes</span>

<span class="sd">        col1           float64</span>
<span class="sd">        col2            object</span>
<span class="sd">        col3    datetime64[ns]</span>
<span class="sd">        dtype: object</span>

<span class="sd">    Specific columns can be converted to category type:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">                .encode_categorical(</span>
<span class="sd">                    column_names=[&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;]</span>
<span class="sd">                    )</span>
<span class="sd">            )</span>

<span class="sd">        df.dtypes</span>

<span class="sd">        col1    category</span>
<span class="sd">        col2    category</span>
<span class="sd">        col3    category</span>
<span class="sd">        dtype: object</span>

<span class="sd">    Note that for the code above, the categories were inferred from</span>
<span class="sd">    the columns, and is unordered::</span>

<span class="sd">        df[&#39;col3&#39;]</span>
<span class="sd">        0   2020-01-01</span>
<span class="sd">        1   2020-01-02</span>
<span class="sd">        2   2020-01-03</span>
<span class="sd">        3   2020-01-04</span>
<span class="sd">        4   2020-01-05</span>
<span class="sd">        Name: col3, dtype: category</span>
<span class="sd">        Categories (5, datetime64[ns]):</span>
<span class="sd">        [2020-01-01, 2020-01-02, 2020-01-03, 2020-01-04, 2020-01-05]</span>


<span class="sd">    Explicit categories can be provided, and ordered via the ``kwargs``</span>
<span class="sd">    parameter::</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">                .encode_categorical(</span>
<span class="sd">                    col1 = ([3, 2, 1, 4], &quot;appearance&quot;),</span>
<span class="sd">                    col2 = ([&#39;a&#39;,&#39;d&#39;,&#39;c&#39;,&#39;b&#39;], &quot;sort&quot;)</span>
<span class="sd">                    )</span>
<span class="sd">            )</span>

<span class="sd">        df[&#39;col1&#39;]</span>
<span class="sd">        0      2</span>
<span class="sd">        1      1</span>
<span class="sd">        2      3</span>
<span class="sd">        3      1</span>
<span class="sd">        4    NaN</span>
<span class="sd">        Name: col1, dtype: category</span>
<span class="sd">        Categories (4, int64): [3 &lt; 2 &lt; 1 &lt; 4]</span>

<span class="sd">        df[&#39;col2&#39;]</span>
<span class="sd">        0    a</span>
<span class="sd">        1    b</span>
<span class="sd">        2    c</span>
<span class="sd">        3    d</span>
<span class="sd">        4    a</span>
<span class="sd">        Name: col2, dtype: category</span>
<span class="sd">        Categories (4, object): [a &lt; b &lt; c &lt; d]</span>

<span class="sd">    When the `order` parameter is &quot;appearance&quot;, the categories argument is used as-is;</span>
<span class="sd">    if the `order` is &quot;sort&quot;, the categories argument is sorted in ascending order;</span>
<span class="sd">    if `order` is ``None``, then the categories argument is applied unordered.</span>

<span class="sd">    The ``janitor.As_Categorical`` function can also be used to make clearer</span>
<span class="sd">    what the arguments to the function are::</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">                .encode_categorical(</span>
<span class="sd">                    col1 = As_Categorical(</span>
<span class="sd">                                categories = [3, 2, 1, 4],</span>
<span class="sd">                                order = &quot;appearance&quot;</span>
<span class="sd">                                ),</span>
<span class="sd">                    col2 = As_Categorical(</span>
<span class="sd">                                categories = [&#39;a&#39;,&#39;d&#39;,&#39;c&#39;,&#39;b&#39;],</span>
<span class="sd">                                order = &quot;sort&quot;</span>
<span class="sd">                                )</span>
<span class="sd">                    )</span>
<span class="sd">            )</span>

<span class="sd">    A User Warning will be generated if some or all of the unique values</span>
<span class="sd">    in the column are not present in the provided `categories` argument.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">                .encode_categorical(</span>
<span class="sd">                    col1 = As_Categorical(</span>
<span class="sd">                            categories = [4, 5, 6],</span>
<span class="sd">                            order = &quot;appearance&quot;</span>
<span class="sd">                            )</span>
<span class="sd">            )</span>

<span class="sd">        UserWarning: None of the values in col1 are in [4, 5, 6];</span>
<span class="sd">                     this might create nulls for all your values</span>
<span class="sd">                     in the new categorical column.</span>

<span class="sd">        df[&#39;col1&#39;]</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    NaN</span>
<span class="sd">        3    NaN</span>
<span class="sd">        4    NaN</span>
<span class="sd">        Name: col1, dtype: category</span>
<span class="sd">        Categories (3, int64): [4 &lt; 5 &lt; 6]</span>


<span class="sd">    .. note:: if ``categories`` is None in the ``kwargs`` tuple, then the</span>
<span class="sd">        values for `categories` are inferred from the column; if `order`</span>
<span class="sd">        is None, then the values for categories are applied unordered.</span>

<span class="sd">    .. note:: ``column_names`` and ``kwargs`` parameters cannot be used at</span>
<span class="sd">        the same time.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">    - With ``column_names``::</span>

<span class="sd">        categorical_cols = [&#39;col1&#39;, &#39;col2&#39;, &#39;col4&#39;]</span>
<span class="sd">        df = jn.encode_categorical(</span>
<span class="sd">                    df,</span>
<span class="sd">                    columns = categorical_cols)  # one way</span>

<span class="sd">    - With ``kwargs``::</span>

<span class="sd">        df = jn.encode_categorical(</span>
<span class="sd">                    df,</span>
<span class="sd">                    col1 = (categories, order),</span>
<span class="sd">                    col2 = jn.As_Categorical(</span>
<span class="sd">                                categories = [values],</span>
<span class="sd">                                order=&quot;sort&quot;/&quot;appearance&quot;/None</span>
<span class="sd">                                )</span>
<span class="sd">                )</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    - With ``column_names``::</span>

<span class="sd">        categorical_cols = [&#39;col1&#39;, &#39;col2&#39;, &#39;col4&#39;]</span>
<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">                .encode_categorical(columns=categorical_cols)</span>
<span class="sd">            )</span>

<span class="sd">    - With ``kwargs``::</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .encode_categorical(</span>
<span class="sd">                col1 = (categories, order),</span>
<span class="sd">                col2 = jn.As_Categorical(</span>
<span class="sd">                            categories = [values]/None,</span>
<span class="sd">                            order=&quot;sort&quot;/&quot;appearance&quot;/None</span>
<span class="sd">                            )</span>
<span class="sd">        )</span>


<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param column_names: A column name or an iterable (list or</span>
<span class="sd">        tuple) of column names.</span>
<span class="sd">    :param kwargs: A pairing of column name to a tuple of (`categories`, `order`).</span>
<span class="sd">        There is also the `janitor.As_Categorical` function, which creates a</span>
<span class="sd">        namedtuple of (`categories`, `order`) to make it clearer what the arguments</span>
<span class="sd">        are. This is useful in creating categorical columns that are ordered, or</span>
<span class="sd">        if the user needs to explicitly specify the categories.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    :raises JanitorError: if a column specified within ``column_names``</span>
<span class="sd">        is not found in the DataFrame.</span>
<span class="sd">    :raises JanitorError: if ``column_names`` is not hashable</span>
<span class="sd">        nor iterable.</span>
<span class="sd">    :raises ValueError: if both ``column_names`` and ``kwargs`` are provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">column_names</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Only one of `column_names` or `kwargs`</span>
<span class="sd">            can be provided.</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span>
    <span class="c1"># column_names deal with only category dtype (unordered)</span>
    <span class="c1"># kwargs takes care of scenarios where user wants an ordered category</span>
    <span class="c1"># or user supplies specific categories to create the categorical</span>
    <span class="k">if</span> <span class="n">column_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> missing from DataFrame columns!&quot;</span>
                    <span class="p">)</span>
                <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">column_names</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_names</span><span class="si">}</span><span class="s2"> missing from DataFrame columns!&quot;</span>
                <span class="p">)</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_names</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_names</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
                <span class="s2">&quot;kwarg `column_names` must be hashable or iterable!&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">_computations_as_categorical</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="label_encode"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.label_encode.html#janitor.label_encode">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">label_encode</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert labels into numerical data.</span>

<span class="sd">    This method will create a new column with the string &quot;_enc&quot; appended</span>
<span class="sd">    after the original column&#39;s name. Consider this to be syntactic sugar.</span>

<span class="sd">    This method behaves differently from `encode_categorical`. This method</span>
<span class="sd">    creates a new column of numeric data. `encode_categorical` replaces the</span>
<span class="sd">    dtype of the original column with a &quot;categorical&quot; dtype.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = label_encode(df, column_names=&quot;my_categorical_column&quot;)  # one way</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        categorical_cols = [&#39;col1&#39;, &#39;col2&#39;, &#39;col4&#39;]</span>
<span class="sd">        df = pd.DataFrame(...).label_encode(column_names=categorical_cols)</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param column_names: A column name or an iterable (list</span>
<span class="sd">        or tuple) of column names.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;label_encode will be deprecated in a 1.x release. </span><span class="se">\</span>
<span class="s2">        Please use factorize_columns instead&quot;</span>
    <span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">_factorize</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="s2">&quot;_enc&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">factorize_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">],</span>
    <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_enc&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Converts labels into numerical data</span>

<span class="sd">    This method will create a new column with the string &quot;_enc&quot; appended</span>
<span class="sd">    after the original column&#39;s name.</span>
<span class="sd">    This can be overriden with the suffix parameter</span>

<span class="sd">    Internally this method uses pandas factorize method.</span>
<span class="sd">    It takes in optional suffix and keyword arguments also.</span>
<span class="sd">    An empty string as suffix will override the existing column</span>

<span class="sd">    This method mutates the original DataFrame</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = factorize_columns(df, column_names=&quot;my_categorical_column&quot;,</span>
<span class="sd">                                        suffix=&quot;_enc&quot;)  # one way</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        categorical_cols = [&#39;col1&#39;, &#39;col2&#39;, &#39;col4&#39;]</span>
<span class="sd">        df = pd.DataFrame(...).factorize_columns(</span>
<span class="sd">                                column_names=categorical_cols,</span>
<span class="sd">                                suffix=&quot;_enc&quot;)</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param column_names: A column name or an iterable (list</span>
<span class="sd">        or tuple) of column names.</span>
<span class="sd">    :param suffix: Suffix to be used for the new column. Default value is _enc.</span>
<span class="sd">        An empty string suffix means, it will override the existing column</span>
<span class="sd">    :param **kwargs: Keyword arguments. It takes any of the keyword arguments,</span>
<span class="sd">        which the pandas factorize method takes like sort,na_sentinel,size_hint</span>

<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">_factorize</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>


<span class="nd">@dispatch</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span> <span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_factorize</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="n">column_names</span><span class="p">,</span> <span class="n">present</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">df</span>


<span class="nd">@dispatch</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_factorize</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># noqa: F811</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="n">column_name</span><span class="p">,</span> <span class="n">present</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">df</span>


<div class="viewcode-block" id="rename_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.rename_column.html#janitor.rename_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">old</span><span class="o">=</span><span class="s2">&quot;old_column_name&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="s2">&quot;new_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rename_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">old_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">new_column_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Rename a column in place.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = rename_column(df, &quot;old_column_name&quot;, &quot;new_column_name&quot;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).rename_column(&quot;old_column_name&quot;, &quot;new_column_name&quot;)</span>

<span class="sd">    This is just syntactic sugar/a convenience function for renaming one column</span>
<span class="sd">    at a time. If you are convinced that there are multiple columns in need of</span>
<span class="sd">    changing, then use the :py:meth:`pandas.DataFrame.rename` method.</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param old_column_name: The old column name.</span>
<span class="sd">    :param new_column_name: The new column name.</span>
<span class="sd">    :returns: A pandas DataFrame with renamed columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="n">old_column_name</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">old_column_name</span><span class="p">:</span> <span class="n">new_column_name</span><span class="p">})</span></div>


<div class="viewcode-block" id="rename_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.rename_columns.html#janitor.rename_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">rename_columns</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">new_column_names</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Rename columns in place.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = rename_columns(df, {&quot;old_column_name&quot;: &quot;new_column_name&quot;})</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).rename_columns({&quot;old_column_name&quot;: &quot;new_column_name&quot;})</span>

<span class="sd">    This is just syntactic sugar/a convenience function for renaming one column</span>
<span class="sd">    at a time. If you are convinced that there are multiple columns in need of</span>
<span class="sd">    changing, then use the :py:meth:`pandas.DataFrame.rename` method.</span>

<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param new_column_names: A dictionary of old and new column names.</span>
<span class="sd">    :returns: A pandas DataFrame with renamed columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_column_names</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_column_names</span><span class="p">)</span></div>


<div class="viewcode-block" id="reorder_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.reorder_columns.html#janitor.reorder_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">reorder_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_order</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Reorder DataFrame columns by specifying desired order as list of col names.</span>

<span class="sd">    Columns not specified retain their order and follow after specified cols.</span>

<span class="sd">    Validates column_order to ensure columns are all present in DataFrame.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    Given `DataFrame` with column names `col1`, `col2`, `col3`:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = reorder_columns(df, [&#39;col2&#39;, &#39;col3&#39;])</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).reorder_columns([&#39;col2&#39;, &#39;col3&#39;])</span>

<span class="sd">    The column order of `df` is now `col2`, `col3`, `col1`.</span>

<span class="sd">    Internally, this function uses `DataFrame.reindex` with `copy=False`</span>
<span class="sd">    to avoid unnecessary data duplication.</span>

<span class="sd">    :param df: `DataFrame` to reorder</span>
<span class="sd">    :param column_order: A list of column names or Pandas `Index`</span>
<span class="sd">        specifying their order in the returned `DataFrame`.</span>
<span class="sd">    :returns: A pandas DataFrame with reordered columns.</span>
<span class="sd">    :raises IndexError: if a column within ``column_order`` is not found</span>
<span class="sd">        within the DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_order&quot;</span><span class="p">,</span> <span class="n">column_order</span><span class="p">,</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_order</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
            <span class="s2">&quot;A column in ``column_order`` was not found in the DataFrame.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># if column_order is a Pandas index, needs conversion to list:</span>
    <span class="n">column_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">column_order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">(</span>
            <span class="n">column_order</span>
            <span class="o">+</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">column_order</span><span class="p">]</span>
        <span class="p">),</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="coalesce"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.coalesce.html#janitor.coalesce">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">,</span> <span class="n">new_column_name</span><span class="o">=</span><span class="s2">&quot;target_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">coalesce</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="n">target_column_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coalesce two or more columns of data in order of column names provided.</span>

<span class="sd">    This finds the first non-missing value at each position.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame({&quot;A&quot;: [1, 2, np.nan],</span>
<span class="sd">                           &quot;B&quot;: [np.nan, 10, np.nan],</span>
<span class="sd">                           &quot;C&quot;: [5, 10, 7]})</span>

<span class="sd">             A     B   C</span>
<span class="sd">        0  1.0   NaN   5</span>
<span class="sd">        1  2.0  10.0  10</span>
<span class="sd">        2  NaN   NaN   7</span>

<span class="sd">        df.coalesce(column_names = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="sd">                    target_column_name = &#39;D&#39;)</span>

<span class="sd">            A     B   C    D</span>
<span class="sd">        0  1.0   NaN   5  1.0</span>
<span class="sd">        1  2.0  10.0  10  2.0</span>
<span class="sd">        2  NaN   NaN   7  7.0</span>

<span class="sd">    If no target column is provided, then the first column is updated,</span>
<span class="sd">    with the null values removed::</span>

<span class="sd">        df.coalesce(column_names = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>

<span class="sd">            A     B   C</span>
<span class="sd">        0  1.0   NaN   5</span>
<span class="sd">        1  2.0  10.0  10</span>
<span class="sd">        2  7.0   NaN   7</span>

<span class="sd">    If nulls remain, you can fill it with the `default_value`::</span>

<span class="sd">        df = pd.DataFrame({&#39;s1&#39;:[np.nan,np.nan,6,9,9],</span>
<span class="sd">                           &#39;s2&#39;:[np.nan,8,7,9,9]})</span>

<span class="sd">            s1   s2</span>
<span class="sd">        0  NaN  NaN</span>
<span class="sd">        1  NaN  8.0</span>
<span class="sd">        2  6.0  7.0</span>
<span class="sd">        3  9.0  9.0</span>
<span class="sd">        4  9.0  9.0</span>

<span class="sd">        df.coalesce(column_names = [&#39;s1&#39;, &#39;s2&#39;],</span>
<span class="sd">                    target_column_name = &#39;s3&#39;,</span>
<span class="sd">                    default_value = 0)</span>

<span class="sd">            s1   s2   s3</span>
<span class="sd">        0  NaN  NaN  0.0</span>
<span class="sd">        1  NaN  8.0  8.0</span>
<span class="sd">        2  6.0  7.0  6.0</span>
<span class="sd">        3  9.0  9.0  9.0</span>
<span class="sd">        4  9.0  9.0  9.0</span>


<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = coalesce(df, columns=[&#39;col1&#39;, &#39;col2&#39;], &#39;col3&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).coalesce([&#39;col1&#39;, &#39;col2&#39;])</span>

<span class="sd">    The first example will create a new column called &#39;col3&#39; with values from</span>
<span class="sd">    &#39;col2&#39; inserted where values from &#39;col1&#39; are NaN.</span>
<span class="sd">    The second example will update the values of &#39;col1&#39;,</span>
<span class="sd">    since it is the first column in `column_names`.</span>

<span class="sd">    This is more syntactic diabetes! For R users, this should look familiar to</span>
<span class="sd">    `dplyr`&#39;s `coalesce` function; for Python users, the interface</span>
<span class="sd">    should be more intuitive than the :py:meth:`pandas.Series.combine_first`</span>
<span class="sd">    method.</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_names: A list of column names.</span>
<span class="sd">    :param target_column_name: The new column name after combining.</span>
<span class="sd">        If `None`, then the first column in `column_names` is updated,</span>
<span class="sd">        with the Null values replaced.</span>
<span class="sd">    :param default_value: A scalar to replace any remaining nulls</span>
<span class="sd">        after coalescing.</span>
<span class="sd">    :returns: A pandas DataFrame with coalesced columns.</span>
<span class="sd">    :raises ValueError: if length of `column_names` is less than 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_names&quot;</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="p">[</span><span class="nb">list</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">target_column_name</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;target_column_name&quot;</span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">default_value</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;default_value&quot;</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">column_names</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The number of columns to coalesce</span>
<span class="sd">            should be a minimum of 2.</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">target_column_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_column_name</span> <span class="o">=</span> <span class="n">column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># bfill/ffill combo is faster than combine_first</span>
    <span class="n">outcome</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">column_names</span><span class="p">)</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">outcome</span><span class="o">.</span><span class="n">hasnans</span> <span class="ow">and</span> <span class="p">(</span><span class="n">default_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">outcome</span> <span class="o">=</span> <span class="n">outcome</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">default_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">target_column_name</span><span class="p">:</span> <span class="n">outcome</span><span class="p">})</span></div>


<div class="viewcode-block" id="convert_excel_date"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.convert_excel_date.html#janitor.convert_excel_date">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convert_excel_date</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert Excel&#39;s serial date format into Python datetime format.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Implementation is also from `Stack Overflow`.</span>

<span class="sd">    .. _Stack Overflow: https://stackoverflow.com/questions/38454403/convert-excel-style-date-with-pandas</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = convert_excel_date(df, column_name=&#39;date&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).convert_excel_date(&#39;date&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: A column name.</span>
<span class="sd">    :returns: A pandas DataFrame with corrected dates.</span>
<span class="sd">    :raises ValueError: if There are non numeric values in the column.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;There are non-numeric values in the column. </span><span class="se">\</span>
<span class="s2">    All values must be numeric&quot;</span>
        <span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;d&quot;</span>
    <span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
        <span class="mi">1899</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">30</span>
    <span class="p">)</span>  <span class="c1"># noqa: W503</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="convert_matlab_date"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.convert_matlab_date.html#janitor.convert_matlab_date">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convert_matlab_date</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert Matlab&#39;s serial date number into Python datetime format.</span>

<span class="sd">    Implementation is also from `StackOverflow`_.</span>

<span class="sd">    .. _StackOverflow: https://stackoverflow.com/questions/13965740/converting-matlabs-datenum-format-to-python</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = convert_matlab_date(df, column_name=&#39;date&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).convert_matlab_date(&#39;date&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: A column name.</span>
<span class="sd">    :returns: A pandas DataFrame with corrected dates.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">days</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]])</span>
    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromordinal</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">days</span>
        <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">366</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="convert_unix_date"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.convert_unix_date.html#janitor.convert_unix_date">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convert_unix_date</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert unix epoch time into Python datetime format.</span>

<span class="sd">    Note that this ignores local tz and convert all timestamps to naive</span>
<span class="sd">    datetime based on UTC!</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = convert_unix_date(df, column_name=&#39;date&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).convert_unix_date(&#39;date&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: A column name.</span>
<span class="sd">    :returns: A pandas DataFrame with corrected dates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">OutOfBoundsDatetime</span><span class="p">:</span>  <span class="c1"># Indicates time is in milliseconds.</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ms&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="fill_empty"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.fill_empty.html#janitor.fill_empty">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fill_empty</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">],</span> <span class="n">value</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Fill `NaN` values in specified columns with a given value.</span>

<span class="sd">    Super sugary syntax that wraps :py:meth:`pandas.DataFrame.fillna`.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = fill_empty(df, column_names=[&#39;col1&#39;, &#39;col2&#39;], value=0)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).fill_empty(column_names=&#39;col1&#39;, value=0)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_names: column_names: A column name or an iterable (list</span>
<span class="sd">        or tuple) of column names If a single column name is passed in, then</span>
<span class="sd">        only that column will be filled; if a list or tuple is passed in, then</span>
<span class="sd">        those columns will all be filled with the same value.</span>
<span class="sd">    :param value: The value that replaces the `NaN` values.</span>
<span class="sd">    :returns: A pandas DataFrame with `Nan` values filled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_fill_empty</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


<span class="nd">@dispatch</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_fill_empty</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fill empty function for the case that column_names is list or tuple.&quot;&quot;&quot;</span>
    <span class="n">fill_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">fill_mapping</span><span class="p">)</span>


<span class="nd">@dispatch</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>  <span class="c1"># noqa: F811</span>
<span class="k">def</span> <span class="nf">_fill_empty</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: F811</span>
    <span class="sd">&quot;&quot;&quot;Fill empty function for the case that column_names is a string.&quot;&quot;&quot;</span>
    <span class="n">fill_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">column_names</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">fill_mapping</span><span class="p">)</span>


<div class="viewcode-block" id="expand_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.expand_column.html#janitor.expand_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">expand_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">concat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Expand a categorical column with multiple labels into dummy-coded columns.</span>

<span class="sd">    Super sugary syntax that wraps :py:meth:`pandas.Series.str.get_dummies`.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = expand_column(df,</span>
<span class="sd">                           column_name=&#39;col_name&#39;,</span>
<span class="sd">                           sep=&#39;, &#39;)  # note space in sep</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).expand_column(column_name=&#39;col_name&#39;,</span>
<span class="sd">                                             sep=&#39;, &#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: Which column to expand.</span>
<span class="sd">    :param sep: The delimiter. Example delimiters include `|`, `, `, `,` etc.</span>
<span class="sd">    :param concat: Whether to return the expanded column concatenated to</span>
<span class="sd">        the original dataframe (`concat=True`), or to return it standalone</span>
<span class="sd">        (`concat=False`).</span>
<span class="sd">    :returns: A pandas DataFrame with an expanded column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expanded_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">concat</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">expanded_df</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">return</span> <span class="n">expanded_df</span></div>


<div class="viewcode-block" id="concatenate_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.concatenate_columns.html#janitor.concatenate_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">concatenate_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span>
    <span class="n">new_column_name</span><span class="p">,</span>
    <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Concatenates the set of columns into a single column.</span>

<span class="sd">    Used to quickly generate an index based on a group of columns.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = concatenate_columns(df,</span>
<span class="sd">                                 column_names=[&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">                                 new_column_name=&#39;id&#39;,</span>
<span class="sd">                                 sep=&#39;-&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...).</span>
<span class="sd">              concatenate_columns(column_names=[&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">                                  new_column_name=&#39;id&#39;,</span>
<span class="sd">                                  sep=&#39;-&#39;))</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_names: A list of columns to concatenate together.</span>
<span class="sd">    :param new_column_name: The name of the new column.</span>
<span class="sd">    :param sep: The separator between each column&#39;s data.</span>
<span class="sd">    :returns: A pandas DataFrame with concatenated columns.</span>
<span class="sd">    :raises JanitorError: if at least two columns are not provided</span>
<span class="sd">        within ``column_names``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span><span class="s2">&quot;At least two columns must be specified&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">+</span> <span class="n">sep</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="deconcatenate_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.deconcatenate_column.html#janitor.deconcatenate_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">deconcatenate_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">sep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">new_column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">autoname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">preserve_position</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;De-concatenates a single column into multiple columns.</span>

<span class="sd">    The column to de-concatenate can be either a collection (list, tuple, ...)</span>
<span class="sd">    which can be separated out with ``pd.Series.tolist()``,</span>
<span class="sd">    or a string to slice based on ``sep``.</span>

<span class="sd">    To determine this behaviour automatically,</span>
<span class="sd">    the first element in the column specified is inspected.</span>

<span class="sd">    If it is a string, then ``sep`` must be specified.</span>
<span class="sd">    Else, the function assumes that it is an iterable type</span>
<span class="sd">    (e.g. ``list`` or ``tuple``),</span>
<span class="sd">    and will attempt to deconcatenate by splitting the list.</span>

<span class="sd">    Given a column with string values, this is the inverse of the</span>
<span class="sd">    ``concatenate_columns`` function.</span>

<span class="sd">    Used to quickly split columns out of a single column.</span>

<span class="sd">    The keyword argument ``preserve_position``</span>
<span class="sd">    takes ``True`` or ``False`` boolean</span>
<span class="sd">    that controls whether the ``new_column_names``</span>
<span class="sd">    will take the original position</span>
<span class="sd">    of the to-be-deconcatenated ``column_name``:</span>

<span class="sd">    - When `preserve_position=False` (default), `df.columns` change from</span>
<span class="sd">      `[..., column_name, ...]` to `[..., column_name, ..., new_column_names]`.</span>
<span class="sd">      In other words, the deconcatenated new columns are appended to the right</span>
<span class="sd">      of the original dataframe and the original `column_name` is NOT dropped.</span>
<span class="sd">    - When `preserve_position=True`, `df.column` change from</span>
<span class="sd">      `[..., column_name, ...]` to `[..., new_column_names, ...]`.</span>
<span class="sd">      In other words, the deconcatenated new column will REPLACE the original</span>
<span class="sd">      `column_name` at its original position, and `column_name` itself</span>
<span class="sd">      is dropped.</span>

<span class="sd">    The keyword argument ``autoname`` accepts a base string</span>
<span class="sd">    and then automatically creates numbered column names</span>
<span class="sd">    based off the base string.</span>
<span class="sd">    For example, if ``col`` is passed in</span>
<span class="sd">    as the argument to ``autoname``,</span>
<span class="sd">    and 4 columns are created,</span>
<span class="sd">    then the resulting columns will be named</span>
<span class="sd">    ``col1, col2, col3, col4``.</span>
<span class="sd">    Numbering is always 1-indexed, not 0-indexed,</span>
<span class="sd">    in order to make the column names human-friendly.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = deconcatenate_column(</span>
<span class="sd">                df, column_name=&#39;id&#39;, new_column_names=[&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">                sep=&#39;-&#39;, preserve_position=True</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...).</span>
<span class="sd">                deconcatenate_column(</span>
<span class="sd">                    column_name=&#39;id&#39;, new_column_names=[&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">                    sep=&#39;-&#39;, preserve_position=True</span>
<span class="sd">                ))</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column to split.</span>
<span class="sd">    :param sep: The separator delimiting the column&#39;s data.</span>
<span class="sd">    :param new_column_names: A list of new column names post-splitting.</span>
<span class="sd">    :param autoname: A base name for automatically naming the new columns.</span>
<span class="sd">        Takes precedence over ``new_column_names`` if both are provided.</span>
<span class="sd">    :param preserve_position: Boolean for whether or not to preserve original</span>
<span class="sd">        position of the column upon de-concatenation, default to False</span>
<span class="sd">    :returns: A pandas DataFrame with a deconcatenated column.</span>
<span class="sd">    :raises ValueError: if ``column_name`` is not present in the</span>
<span class="sd">        DataFrame.</span>
<span class="sd">    :raises ValueError: if ``sep`` is not provided and the column values</span>
<span class="sd">        are of type ``str``.</span>
<span class="sd">    :raises ValueError: if either ``new_column_names`` or ``autoname``</span>
<span class="sd">        is not supplied.</span>
<span class="sd">    :raises JanitorError: if incorrect number of names is provided</span>
<span class="sd">        within ``new_column_names``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;column name </span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2"> not present in DataFrame&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`sep` must be specified if the column values &quot;</span>
                <span class="s2">&quot;are of type `str`.&quot;</span>
            <span class="p">)</span>
        <span class="n">df_deconcat</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df_deconcat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span><span class="n">new_column_names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">new_column_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">autoname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;One of `new_column_names` or `autoname` must be supplied.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">autoname</span><span class="p">:</span>
        <span class="n">new_column_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">autoname</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">df_deconcat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_column_names</span><span class="p">)</span> <span class="o">==</span> <span class="n">df_deconcat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">JanitorError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;you need to provide </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df_deconcat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2"> names &quot;</span>
            <span class="s2">&quot;to `new_column_names`&quot;</span>
        <span class="p">)</span>

    <span class="n">df_deconcat</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">new_column_names</span>
    <span class="n">df_new</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">df_deconcat</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">preserve_position</span><span class="p">:</span>
        <span class="n">df_original</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df_original</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">index_original</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col_new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_column_names</span><span class="p">):</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index_original</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">col_new</span><span class="p">)</span>

        <span class="n">df_new</span> <span class="o">=</span> <span class="n">df_new</span><span class="o">.</span><span class="n">select_columns</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">column_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_new</span></div>


<div class="viewcode-block" id="filter_string"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.filter_string.html#janitor.filter_string">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">filter_string</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">search_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">complement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Filter a string-based column according to whether it contains a substring.</span>

<span class="sd">    This is super sugary syntax that builds on top of</span>
<span class="sd">    `pandas.Series.str.contains`.</span>

<span class="sd">    Because this uses internally `pandas.Series.str.contains`, which allows a</span>
<span class="sd">    regex string to be passed into it, thus `search_string` can also be a regex</span>
<span class="sd">    pattern.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    This function allows us to method chain filtering operations:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .filter_string(&#39;column&#39;, search_string=&#39;pattern&#39;, complement=False)</span>
<span class="sd">              ...)  # chain on more data preprocessing.</span>

<span class="sd">    This stands in contrast to the in-place syntax that is usually used:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = df[df[&#39;column&#39;].str.contains(&#39;pattern&#39;)]]</span>

<span class="sd">    As can be seen here, the API design allows for a more seamless flow in</span>
<span class="sd">    expressing the filtering operations.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = filter_string(df,</span>
<span class="sd">                           column_name=&#39;column&#39;,</span>
<span class="sd">                           search_string=&#39;pattern&#39;,</span>
<span class="sd">                           complement=False)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .filter_string(column_name=&#39;column&#39;,</span>
<span class="sd">                             search_string=&#39;pattern&#39;,</span>
<span class="sd">                             complement=False)</span>
<span class="sd">              ...)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column to filter. The column should contain strings.</span>
<span class="sd">    :param search_string: A regex pattern or a (sub-)string to search.</span>
<span class="sd">    :param complement: Whether to return the complement of the filter or not.</span>
<span class="sd">    :returns: A filtered pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">search_string</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">complement</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">criteria</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">criteria</span><span class="p">]</span></div>


<div class="viewcode-block" id="filter_on"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.filter_on.html#janitor.filter_on">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">filter_on</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">criteria</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">complement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return a dataframe filtered on a particular criteria.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    This is super-sugary syntax that wraps the pandas `.query()` API, enabling</span>
<span class="sd">    users to use strings to quickly specify filters for filtering their</span>
<span class="sd">    dataframe. The intent is that `filter_on` as a verb better matches the</span>
<span class="sd">    intent of a pandas user than the verb `query`.</span>

<span class="sd">    Let&#39;s say we wanted to filter students based on whether they failed an exam</span>
<span class="sd">    or not, which is defined as their score (in the &quot;score&quot; column) being less</span>
<span class="sd">    than 50.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .filter_on(&#39;score &lt; 50&#39;, complement=False)</span>
<span class="sd">              ...)  # chain on more data preprocessing.</span>

<span class="sd">    This stands in contrast to the in-place syntax that is usually used:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = df[df[&#39;score&#39;] &lt; 3]</span>

<span class="sd">    As with the `filter_string` function, a more seamless flow can be expressed</span>
<span class="sd">    in the code.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = filter_on(df,</span>
<span class="sd">                       &#39;score &lt; 50&#39;,</span>
<span class="sd">                       complement=False)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .filter_on(&#39;score &lt; 50&#39;, complement=False))</span>

<span class="sd">    Credit to Brant Peterson for the name.</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param criteria: A filtering criteria that returns an array or Series of</span>
<span class="sd">        booleans, on which pandas can filter on.</span>
<span class="sd">    :param complement: Whether to return the complement of the filter or not.</span>
<span class="sd">    :returns: A filtered pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">complement</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;not &quot;</span> <span class="o">+</span> <span class="n">criteria</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">criteria</span><span class="p">)</span></div>


<div class="viewcode-block" id="filter_date"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.filter_date.html#janitor.filter_date">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="s2">&quot;start_date&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;end_date&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">filter_date</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">start_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">end_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">dt</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">years</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">months</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">days</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">column_date_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="nb">format</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># skipcq: PYL-W0622</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Filter a date-based column based on certain criteria.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Dates may be finicky and this function builds on top of the &quot;magic&quot; from</span>
<span class="sd">    the pandas `to_datetime` function that is able to parse dates well.</span>

<span class="sd">    Additional options to parse the date type of your column may be found at</span>
<span class="sd">    the official pandas documentation:</span>

<span class="sd">    pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html</span>

<span class="sd">    **Note:** This method will cast your column to a Timestamp!</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: The column which to apply the fraction transformation.</span>
<span class="sd">    :param start_date: The beginning date to use to filter the DataFrame.</span>
<span class="sd">    :param end_date: The end date to use to filter the DataFrame.</span>
<span class="sd">    :param years: The years to use to filter the DataFrame.</span>
<span class="sd">    :param months: The months to use to filter the DataFrame.</span>
<span class="sd">    :param days: The days to use to filter the DataFrame.</span>
<span class="sd">    :param column_date_options: &#39;Special options to use when parsing the date</span>
<span class="sd">        column in the original DataFrame. The options may be found at the</span>
<span class="sd">        official Pandas documentation.&#39;</span>
<span class="sd">    :param format: &#39;If you&#39;re using a format for `start_date` or `end_date`</span>
<span class="sd">        that is not recognized natively by pandas&#39; to_datetime function, you</span>
<span class="sd">        may supply the format yourself. Python date and time formats may be</span>
<span class="sd">        found at http://strftime.org/.&#39;</span>
<span class="sd">    :returns: A filtered pandas DataFrame.</span>

<span class="sd">    **Note:** This only affects the format of the `start_date` and `end_date`</span>
<span class="sd">    parameters. If there&#39;s an issue with the format of the DataFrame being</span>
<span class="sd">    parsed, you would pass `{&#39;format&#39;: your_format}` to `column_date_options`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: need to convert this to notebook.</span>
    <span class="c1">#     :Setup:</span>
    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>

    <span class="c1">#     date_list = [</span>
    <span class="c1">#         [1, &quot;01/28/19&quot;], [2, &quot;01/29/19&quot;], [3, &quot;01/30/19&quot;],</span>
    <span class="c1">#         [4, &quot;01/31/19&quot;], [5, &quot;02/01/19&quot;], [6, &quot;02/02/19&quot;],</span>
    <span class="c1">#         [7, &quot;02/03/19&quot;], [8, &quot;02/04/19&quot;], [9, &quot;02/05/19&quot;],</span>
    <span class="c1">#         [10, &quot;02/06/19&quot;], [11, &quot;02/07/20&quot;], [12, &quot;02/08/20&quot;],</span>
    <span class="c1">#         [13, &quot;02/09/20&quot;], [14, &quot;02/10/20&quot;], [15, &quot;02/11/20&quot;],</span>
    <span class="c1">#         [16, &quot;02/12/20&quot;], [17, &quot;02/07/20&quot;], [18, &quot;02/08/20&quot;],</span>
    <span class="c1">#         [19, &quot;02/09/20&quot;], [20, &quot;02/10/20&quot;], [21, &quot;02/11/20&quot;],</span>
    <span class="c1">#         [22, &quot;02/12/20&quot;], [23, &quot;03/08/20&quot;], [24, &quot;03/09/20&quot;],</span>
    <span class="c1">#         [25, &quot;03/10/20&quot;], [26, &quot;03/11/20&quot;], [27, &quot;03/12/20&quot;]]</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(date_list,</span>
    <span class="c1">#                                      columns = [&#39;AMOUNT&#39;, &#39;DATE&#39;])</span>

    <span class="c1"># :Example 1: Filter dataframe between two dates</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     start_date = &quot;01/29/19&quot;</span>
    <span class="c1">#     end_date = &quot;01/30/19&quot;</span>

    <span class="c1">#     example_dataframe.filter_date(</span>
    <span class="c1">#         &#39;DATE&#39;, start_date=start_date, end_date=end_date</span>
    <span class="c1">#     )</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        AMOUNT       DATE</span>
    <span class="c1">#     1       2 2019-01-29</span>
    <span class="c1">#     2       3 2019-01-30</span>

    <span class="c1"># :Example 2: Using a different date format for filtering</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     end_date = &quot;01$$$30$$$19&quot;</span>
    <span class="c1">#     format = &quot;%m$$$%d$$$%y&quot;</span>

    <span class="c1">#     example_dataframe.filter_date(</span>
    <span class="c1">#         &#39;DATE&#39;, end_date=end_date, format=format</span>
    <span class="c1">#     )</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        AMOUNT       DATE</span>
    <span class="c1">#     0       1 2019-01-28</span>
    <span class="c1">#     1       2 2019-01-29</span>
    <span class="c1">#     2       3 2019-01-30</span>

    <span class="c1"># :Example 3: Filtering by year</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     years = [2019]</span>

    <span class="c1">#     example_dataframe.filter_date(&#39;DATE&#39;, years=years)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        AMOUNT       DATE</span>
    <span class="c1">#     0       1 2019-01-28</span>
    <span class="c1">#     1       2 2019-01-29</span>
    <span class="c1">#     2       3 2019-01-30</span>
    <span class="c1">#     3       4 2019-01-31</span>
    <span class="c1">#     4       5 2019-02-01</span>
    <span class="c1">#     5       6 2019-02-02</span>
    <span class="c1">#     6       7 2019-02-03</span>
    <span class="c1">#     7       8 2019-02-04</span>
    <span class="c1">#     8       9 2019-02-05</span>
    <span class="c1">#     9      10 2019-02-06</span>

    <span class="c1"># :Example 4: Filtering by year and month</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     years = [2020]</span>
    <span class="c1">#     months = [3]</span>

    <span class="c1">#     example_dataframe.filter_date(&#39;DATE&#39;, years=years, months=months)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#         AMOUNT       DATE</span>
    <span class="c1">#     22      23 2020-03-08</span>
    <span class="c1">#     23      24 2020-03-09</span>
    <span class="c1">#     24      25 2020-03-10</span>
    <span class="c1">#     25      26 2020-03-11</span>
    <span class="c1">#     26      27 2020-03-12</span>

    <span class="c1"># :Example 5: Filtering by year and day</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     years = [2020]</span>
    <span class="c1">#     days = range(10,12)</span>

    <span class="c1">#     example_dataframe.filter_date(&#39;DATE&#39;, years=years, days=days)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#         AMOUNT       DATE</span>
    <span class="c1">#     13      14 2020-02-10</span>
    <span class="c1">#     14      15 2020-02-11</span>
    <span class="c1">#     19      20 2020-02-10</span>
    <span class="c1">#     20      21 2020-02-11</span>
    <span class="c1">#     24      25 2020-03-10</span>
    <span class="c1">#     25      26 2020-03-11</span>

    <span class="k">def</span> <span class="nf">_date_filter_conditions</span><span class="p">(</span><span class="n">conditions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Taken from: https://stackoverflow.com/a/13616382.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span> <span class="n">conditions</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">column_date_options</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">],</span> <span class="o">**</span><span class="n">column_date_options</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">])</span>

    <span class="n">_filter_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">start_date</span><span class="p">:</span>
        <span class="n">start_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_date</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">end_date</span><span class="p">:</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">end_date</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end_date</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">years</span><span class="p">:</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">years</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">months</span><span class="p">:</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">months</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">days</span><span class="p">:</span>
        <span class="n">_filter_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">day</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">days</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">start_date</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">and</span> <span class="n">start_date</span> <span class="o">&gt;</span> <span class="n">end_date</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Your start date of </span><span class="si">{</span><span class="n">start_date</span><span class="si">}</span><span class="s2"> is after your end date of &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">end_date</span><span class="si">}</span><span class="s2">. Is this intended?&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">_date_filter_conditions</span><span class="p">(</span><span class="n">_filter_list</span><span class="p">),</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="filter_column_isin"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.filter_column_isin.html#janitor.filter_column_isin">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">filter_column_isin</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">iterable</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">complement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Filter a dataframe for values in a column that exist in another iterable.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Assumes exact matching; fuzzy matching not implemented.</span>

<span class="sd">    The below example syntax will filter the DataFrame such that we only get</span>
<span class="sd">    rows for which the &quot;names&quot; are exactly &quot;James&quot; and &quot;John&quot;.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .clean_names()</span>
<span class="sd">            .filter_column_isin(column_name=&quot;names&quot;, iterable=[&quot;James&quot;, &quot;John&quot;]</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    This is the method chaining alternative to:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = df[df[&#39;names&#39;].isin([&#39;James&#39;, &#39;John&#39;])]</span>

<span class="sd">    If &quot;complement&quot; is true, then we will only get rows for which the names</span>
<span class="sd">    are not James or John.</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param column_name: The column on which to filter.</span>
<span class="sd">    :param iterable: An iterable. Could be a list, tuple, another pandas</span>
<span class="sd">        Series.</span>
<span class="sd">    :param complement: Whether to return the complement of the selection or</span>
<span class="sd">        not.</span>
<span class="sd">    :returns: A filtered pandas DataFrame.</span>
<span class="sd">    :raises ValueError: if ``iterable`` does not have a length of ``1``</span>
<span class="sd">        or greater.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;`iterable` kwarg must be given an iterable of length 1 or greater&quot;</span>
        <span class="p">)</span>
    <span class="n">criteria</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">complement</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">criteria</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">criteria</span><span class="p">]</span></div>


<div class="viewcode-block" id="remove_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.remove_columns.html#janitor.remove_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">remove_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Remove the set of columns specified in `column_names`.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Intended to be the method-chaining alternative to `del df[col]`.</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).remove_columns(column_names=[&#39;col1&#39;, &#39;col2&#39;])</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param column_names: The columns to remove.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">column_names</span><span class="p">)</span></div>


<div class="viewcode-block" id="change_type"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.change_type.html#janitor.change_type">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">change_type</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span>
    <span class="n">ignore_exception</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Change the type of a column.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Exceptions that are raised can be ignored. For example, if one has a mixed</span>
<span class="sd">    dtype column that has non-integer strings and integers, and you want to</span>
<span class="sd">    coerce everything to integers, you can optionally ignore the non-integer</span>
<span class="sd">    strings and replace them with ``NaN`` or keep the original value</span>

<span class="sd">    Intended to be the method-chaining alternative to:</span>

<span class="sd">        df[col] = df[col].astype(dtype)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).change_type(&#39;col1&#39;, str)</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: A column in the dataframe.</span>
<span class="sd">    :param dtype: The datatype to convert to. Should be one of the standard</span>
<span class="sd">        Python types, or a numpy datatype.</span>
<span class="sd">    :param ignore_exception: one of ``{False, &quot;fillna&quot;, &quot;keep_values&quot;}``.</span>
<span class="sd">    :returns: A pandas DataFrame with changed column types.</span>
<span class="sd">    :raises ValueError: if unknown option provided for</span>
<span class="sd">        ``ignore_exception``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_exception</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ignore_exception</span> <span class="o">==</span> <span class="s2">&quot;keep_values&quot;</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ignore_exception</span> <span class="o">==</span> <span class="s2">&quot;fillna&quot;</span><span class="p">:</span>
        <span class="c1"># returns None when conversion</span>
        <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">convert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown option for ignore_exception&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.add_column.html#janitor.add_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">fill_remaining</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add a column to the dataframe.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Intended to be the method-chaining alternative to::</span>

<span class="sd">        df[column_name] = value</span>

<span class="sd">    Method chaining syntax adding a column with only a single value:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # This will add a column with only one value.</span>
<span class="sd">        df = pd.DataFrame(...).add_column(column_name=&quot;new_column&quot;, 2)</span>

<span class="sd">    Method chaining syntax adding a column with more than one value:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # This will add a column with an iterable of values.</span>
<span class="sd">        vals = [1, 2, 5, ..., 3, 4]  # of same length as the dataframe.</span>
<span class="sd">        df = pd.DataFrame(...).add_column(column_name=&quot;new_column&quot;, vals)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: Name of the new column. Should be a string, in order</span>
<span class="sd">        for the column name to be compatible with the Feather binary</span>
<span class="sd">        format (this is a useful thing to have).</span>
<span class="sd">    :param value: Either a single value, or a list/tuple of values.</span>
<span class="sd">    :param fill_remaining: If value is a tuple or list that is smaller than</span>
<span class="sd">        the number of rows in the DataFrame, repeat the list or tuple</span>
<span class="sd">        (R-style) to the end of the DataFrame.</span>
<span class="sd">    :returns: A pandas DataFrame with an added column.</span>
<span class="sd">    :raises ValueError: if attempting to add a column that already exists.</span>
<span class="sd">    :raises ValueError: if ``value`` has more elements that number of</span>
<span class="sd">        rows in the DataFrame.</span>
<span class="sd">    :raises ValueError: if attempting to add an iterable of values with</span>
<span class="sd">        a length not equal to the number of DataFrame rows.</span>
<span class="sd">    :raises ValueError: if ``value`` has length of ``0``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Convert examples to notebook.</span>
    <span class="c1"># :Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data = {</span>
    <span class="c1">#         &quot;a&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;Bell__Chart&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;decorated-elephant&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;animals&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
    <span class="c1">#         &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3,</span>
    <span class="c1">#     }</span>
    <span class="c1">#     df = pd.DataFrame(data)</span>

    <span class="c1"># :Example 1: Create a new column with a single value:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.add_column(&quot;city_pop&quot;, 100000)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        a  Bell__Chart  decorated-elephant  animals     cities  city_pop</span>
    <span class="c1">#     0  1            1                   1   rabbit  Cambridge    100000</span>
    <span class="c1">#     1  2            2                   2  leopard   Shanghai    100000</span>
    <span class="c1">#     2  3            3                   3     lion      Basel    100000</span>
    <span class="c1">#     3  1            1                   1   rabbit  Cambridge    100000</span>
    <span class="c1">#     4  2            2                   2  leopard   Shanghai    100000</span>
    <span class="c1">#     5  3            3                   3     lion      Basel    100000</span>
    <span class="c1">#     6  1            1                   1   rabbit  Cambridge    100000</span>
    <span class="c1">#     7  2            2                   2  leopard   Shanghai    100000</span>
    <span class="c1">#     8  3            3                   3     lion      Basel    100000</span>

    <span class="c1"># :Example 2: Create a new column with an iterator which fills to the</span>
    <span class="c1"># column</span>
    <span class="c1"># size:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.add_column(&quot;city_pop&quot;, range(3), fill_remaining=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        a  Bell__Chart  decorated-elephant  animals     cities  city_pop</span>
    <span class="c1">#     0  1            1                   1   rabbit  Cambridge         0</span>
    <span class="c1">#     1  2            2                   2  leopard   Shanghai         1</span>
    <span class="c1">#     2  3            3                   3     lion      Basel         2</span>
    <span class="c1">#     3  1            1                   1   rabbit  Cambridge         0</span>
    <span class="c1">#     4  2            2                   2  leopard   Shanghai         1</span>
    <span class="c1">#     5  3            3                   3     lion      Basel         2</span>
    <span class="c1">#     6  1            1                   1   rabbit  Cambridge         0</span>
    <span class="c1">#     7  2            2                   2  leopard   Shanghai         1</span>
    <span class="c1">#     8  3            3                   3     lion      Basel         2</span>

    <span class="c1"># :Example 3: Add new column based on mutation of other columns:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.add_column(&quot;city_pop&quot;, df.Bell__Chart - 2 * df.a)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        a  Bell__Chart  decorated-elephant  animals     cities  city_pop</span>
    <span class="c1">#     0  1            1                   1   rabbit  Cambridge        -1</span>
    <span class="c1">#     1  2            2                   2  leopard   Shanghai        -2</span>
    <span class="c1">#     2  3            3                   3     lion      Basel        -3</span>
    <span class="c1">#     3  1            1                   1   rabbit  Cambridge        -1</span>
    <span class="c1">#     4  2            2                   2  leopard   Shanghai        -2</span>
    <span class="c1">#     5  3            3                   3     lion      Basel        -3</span>
    <span class="c1">#     6  1            1                   1   rabbit  Cambridge        -1</span>
    <span class="c1">#     7  2            2                   2  leopard   Shanghai        -2</span>
    <span class="c1">#     8  3            3                   3     lion      Basel        -3</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Attempted to add column that already exists: &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="n">nrows</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="c1"># if `value` is a list, ndarray, etc.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nrows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`value` has more elements than number of rows &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;in your `DataFrame`. vals: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;df: </span><span class="si">{</span><span class="n">nrows</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nrows</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fill_remaining</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Attempted to add iterable of values with length&quot;</span>
                <span class="s2">&quot; not equal to number of DataFrame rows&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`value` has to be an iterable of minimum length 1&quot;</span>
            <span class="p">)</span>
        <span class="n">len_value</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fill_remaining</span><span class="p">:</span>
        <span class="c1"># relevant if a scalar val was passed, yet fill_remaining == True</span>
        <span class="n">len_value</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="n">nrows</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">fill_remaining</span><span class="p">:</span>
        <span class="n">times_to_loop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nrows</span> <span class="o">/</span> <span class="n">len_value</span><span class="p">))</span>

        <span class="n">fill_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="n">times_to_loop</span>

        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_values</span><span class="p">[:</span><span class="n">nrows</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="add_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.add_columns.html#janitor.add_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">add_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">fill_remaining</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add multiple columns to the dataframe.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Method to augment `add_column` with ability to add multiple columns in</span>
<span class="sd">    one go. This replaces the need for multiple `add_column` calls.</span>

<span class="sd">    Usage is through supplying kwargs where the key is the col name and the</span>
<span class="sd">    values correspond to the values of the new DataFrame column.</span>

<span class="sd">    Values passed can be scalar or iterable (list, ndarray, etc.)</span>

<span class="sd">    Usage example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        x = 3</span>
<span class="sd">        y = np.arange(0, 10)</span>
<span class="sd">        df = pd.DataFrame(...).add_columns(x=x, y=y)</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param fill_remaining: If value is a tuple or list that is smaller than</span>
<span class="sd">        the number of rows in the DataFrame, repeat the list or tuple</span>
<span class="sd">        (R-style) to the end of the DataFrame. (Passed to `add_column`)</span>
<span class="sd">    :param kwargs: column, value pairs which are looped through in</span>
<span class="sd">        `add_column` calls.</span>
<span class="sd">    :returns: A pandas DataFrame with added columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: error checking can pretty much be handled in `add_column`</span>

    <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">fill_remaining</span><span class="o">=</span><span class="n">fill_remaining</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="limit_column_characters"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.limit_column_characters.html#janitor.limit_column_characters">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">limit_column_characters</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">col_separator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Truncate column sizes to a specific length.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Method chaining will truncate all columns to a given length and append</span>
<span class="sd">    a given separator character with the index of duplicate columns, except</span>
<span class="sd">    for the first distinct column name.</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_length: Character length for which to truncate all columns.</span>
<span class="sd">        The column separator value and number for duplicate column name does</span>
<span class="sd">        not contribute. Therefore, if all columns are truncated to 10</span>
<span class="sd">        characters, the first distinct column will be 10 characters and the</span>
<span class="sd">        remaining will be 12 characters (assuming a column separator of one</span>
<span class="sd">        character).</span>
<span class="sd">    :param col_separator: The separator to use for counting distinct column</span>
<span class="sd">        values. I think an underscore looks nicest, however a period is a</span>
<span class="sd">        common option as well. Supply an empty string (i.e. &#39;&#39;) to remove the</span>
<span class="sd">        separator.</span>
<span class="sd">    :returns: A pandas DataFrame with truncated column lengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># :Example Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data_dict = {</span>
    <span class="c1">#         &quot;really_long_name_for_a_column&quot;: range(10),</span>
    <span class="c1">#         &quot;another_really_long_name_for_a_column&quot;: \</span>
    <span class="c1">#         [2 * item for item in range(10)],</span>
    <span class="c1">#         &quot;another_really_longer_name_for_a_column&quot;: list(&quot;lllongname&quot;),</span>
    <span class="c1">#         &quot;this_is_getting_out_of_hand&quot;: list(&quot;longername&quot;),</span>
    <span class="c1">#     }</span>

    <span class="c1"># :Example: Standard truncation:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.limit_column_characters(7)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#            really_  another another_1 this_is</span>
    <span class="c1">#     0        0        0         l       l</span>
    <span class="c1">#     1        1        2         l       o</span>
    <span class="c1">#     2        2        4         l       n</span>
    <span class="c1">#     3        3        6         o       g</span>
    <span class="c1">#     4        4        8         n       e</span>
    <span class="c1">#     5        5       10         g       r</span>
    <span class="c1">#     6        6       12         n       n</span>
    <span class="c1">#     7        7       14         a       a</span>
    <span class="c1">#     8        8       16         m       m</span>
    <span class="c1">#     9        9       18         e       e</span>

    <span class="c1"># :Example: Standard truncation with different separator character:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe2 = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe2.limit_column_characters(7, &quot;.&quot;)</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#            really_  another another.1 this_is</span>
    <span class="c1">#     0        0        0         l       l</span>
    <span class="c1">#     1        1        2         l       o</span>
    <span class="c1">#     2        2        4         l       n</span>
    <span class="c1">#     3        3        6         o       g</span>
    <span class="c1">#     4        4        8         n       e</span>
    <span class="c1">#     5        5       10         g       r</span>
    <span class="c1">#     6        6       12         n       n</span>
    <span class="c1">#     7        7       14         a       a</span>
    <span class="c1">#     8        8       16         m       m</span>
    <span class="c1">#     9        9       18         e       e</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_length&quot;</span><span class="p">,</span> <span class="n">column_length</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">])</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;col_separator&quot;</span><span class="p">,</span> <span class="n">col_separator</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>

    <span class="n">col_names</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_name</span><span class="p">[:</span><span class="n">column_length</span><span class="p">]</span> <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">col_names</span><span class="p">]</span>

    <span class="n">col_name_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span>
    <span class="n">col_name_count</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># If no columns are duplicates, we can skip the loops below.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_name_set</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
        <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">col_names</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">for</span> <span class="n">col_name_to_check</span> <span class="ow">in</span> <span class="n">col_name_set</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">col_name_to_check</span> <span class="o">==</span> <span class="n">col_name</span><span class="p">:</span>
                <span class="n">col_name_count</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">final_col_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col_names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">col_name_count</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">col_name_to_append</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">col_name</span> <span class="o">+</span> <span class="n">col_separator</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_name_count</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">final_col_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name_to_append</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_col_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>

    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">final_col_names</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="row_to_names"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.row_to_names.html#janitor.row_to_names">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">row_to_names</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">row_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">remove_row</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">remove_rows_above</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">reset_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Elevates a row to be the column names of a DataFrame.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Contains options to remove the elevated row from the DataFrame along with</span>
<span class="sd">    removing the rows above the selected row.</span>

<span class="sd">    Method chaining usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .row_to_names(</span>
<span class="sd">                row_number=0,</span>
<span class="sd">                remove_row=False,</span>
<span class="sd">                remove_rows_above=False,</span>
<span class="sd">                reset_index=False,</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param row_number: The row containing the variable names</span>
<span class="sd">    :param remove_row: Whether the row should be removed from the DataFrame.</span>
<span class="sd">        Defaults to False.</span>
<span class="sd">    :param remove_rows_above: Whether the rows above the selected row should</span>
<span class="sd">        be removed from the DataFrame. Defaults to False.</span>
<span class="sd">    :param reset_index: Whether the index should be reset on the returning</span>
<span class="sd">        DataFrame. Defaults to False.</span>
<span class="sd">    :returns: A pandas DataFrame with set column names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># :Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data_dict = {</span>
    <span class="c1">#         &quot;a&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;Bell__Chart&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;decorated-elephant&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;animals&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
    <span class="c1">#         &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3</span>
    <span class="c1">#     }</span>

    <span class="c1"># :Example: Move first row to column names:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.row_to_names(0)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     0  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     1  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     2  3  3  3     lion      Basel</span>
    <span class="c1">#     3  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     4  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     5  3  3  3     lion      Basel</span>
    <span class="c1">#     6  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     7  2  2  2  leopard   Shanghai</span>

    <span class="c1"># :Example: Move first row to column names and</span>
    <span class="c1">#  remove row while resetting the index:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.row_to_names(0, remove_row=True,\</span>
    <span class="c1">#       reset_index=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#       1   1   1   rabbit  Cambridge</span>
    <span class="c1">#   0   2   2   2   leopard Shanghai</span>
    <span class="c1">#   1   3   3   3   lion    Basel</span>
    <span class="c1">#   2   1   1   1   rabbit  Cambridge</span>
    <span class="c1">#   3   2   2   2   leopard Shanghai</span>
    <span class="c1">#   4   3   3   3   lion    Basel</span>
    <span class="c1">#   5   1   1   1   rabbit  Cambridge</span>
    <span class="c1">#   6   2   2   2   leopard Shanghai</span>
    <span class="c1">#   7   3   3   3   lion    Basel</span>

    <span class="c1"># :Example: Move first row to column names and remove</span>
    <span class="c1">#   row without resetting the index:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.row_to_names(0, remove_row=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     1  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     2  3  3  3     lion      Basel</span>
    <span class="c1">#     3  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     4  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     5  3  3  3     lion      Basel</span>
    <span class="c1">#     6  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     7  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     8  3  3  3     lion      Basel</span>

    <span class="c1"># :Example: Move first row to column names, remove row</span>
    <span class="c1">#   and remove rows above selected row without resetting</span>
    <span class="c1">#   index:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.row_to_names(2, remove_row=True, \</span>
    <span class="c1">#       remove_rows_above=True, reset_index= True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#       3   3   3   lion    Basel</span>
    <span class="c1">#   0   1   1   1   rabbit  Cambridge</span>
    <span class="c1">#   1   2   2   2   leopard Shanghai</span>
    <span class="c1">#   2   3   3   3   lion    Basel</span>
    <span class="c1">#   3   1   1   1   rabbit  Cambridge</span>
    <span class="c1">#   4   2   2   2   leopard Shanghai</span>
    <span class="c1">#   5   3   3   3   lion    Basel</span>

    <span class="c1"># :Example: Move first row to column names, remove row,</span>
    <span class="c1"># and remove rows above selected row without resetting</span>
    <span class="c1"># index:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe.row_to_names(2, remove_row=True, \</span>
    <span class="c1">#       remove_rows_above=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#        3  3  3     lion      Basel</span>
    <span class="c1">#     3  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     4  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     5  3  3  3     lion      Basel</span>
    <span class="c1">#     6  1  1  1   rabbit  Cambridge</span>
    <span class="c1">#     7  2  2  2  leopard   Shanghai</span>
    <span class="c1">#     8  3  3  3     lion      Basel</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;row_number&quot;</span><span class="p">,</span> <span class="n">row_number</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">])</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;The function row_to_names will, in the official 1.0 release, &quot;</span>
        <span class="s2">&quot;change its behaviour to reset the dataframe&#39;s index by default. &quot;</span>
        <span class="s2">&quot;You can prepare for this change right now by explicitly setting &quot;</span>
        <span class="s2">&quot;`reset_index=True` when calling on `row_to_names`.&quot;</span>
    <span class="p">)</span>

    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row_number</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">remove_row</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">row_number</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">remove_rows_above</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">row_number</span><span class="p">)])</span>

    <span class="k">if</span> <span class="n">reset_index</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="round_to_fraction"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.round_to_fraction.html#janitor.round_to_fraction">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">round_to_fraction</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">denominator</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">digits</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Round all values in a column to a fraction.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Taken from https://github.com/sfirke/janitor/issues/235.</span>

<span class="sd">    Also, optionally round to a specified number of digits.</span>

<span class="sd">    Method-chaining usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # Round to two decimal places</span>
<span class="sd">        df = pd.DataFrame(...).round_to_fraction(&#39;a&#39;, 2)</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: Name of column to round to fraction.</span>
<span class="sd">    :param denominator: The denominator of the fraction for rounding</span>
<span class="sd">    :param digits: The number of digits for rounding after rounding to the</span>
<span class="sd">        fraction. Default is np.inf (i.e. no subsequent rounding)</span>
<span class="sd">    :returns: A pandas DataFrame with a column&#39;s values rounded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: THESE EXAMPLES SHOULD BE MOVED TO NOTEBOOKS.</span>
    <span class="c1">#     :Example Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data_dict = {</span>
    <span class="c1">#         &quot;a&quot;: [1.23452345, 2.456234, 3.2346125] * 3,</span>
    <span class="c1">#         &quot;Bell__Chart&quot;: [1/3, 2/7, 3/2] * 3,</span>
    <span class="c1">#         &quot;decorated-elephant&quot;: [1/234, 2/13, 3/167] * 3,</span>
    <span class="c1">#         &quot;animals&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
    <span class="c1">#         &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3,</span>
    <span class="c1">#     }</span>

    <span class="c1"># :Example: Rounding the first column to the nearest half:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#          a  Bell__Chart  decorated-elephant  animals     cities</span>
    <span class="c1">#     0  1.0     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     1  2.5     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     2  3.0     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     3  1.0     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     4  2.5     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     5  3.0     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     6  1.0     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     7  2.5     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     8  3.0     1.500000            0.017964     lion      Basel</span>

    <span class="c1"># :Example: Rounding the first column to nearest third:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe2 = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe2.round_to_fraction(&#39;a&#39;, 3)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#               a  Bell__Chart  decorated-elephant  animals     cities</span>
    <span class="c1">#     0  1.333333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     1  2.333333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     2  3.333333     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     3  1.333333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     4  2.333333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     5  3.333333     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     6  1.333333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     7  2.333333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     8  3.333333     1.500000            0.017964     lion      Basel</span>

    <span class="c1"># :Example 3: Rounding the first column to the nearest third and rounding \</span>
    <span class="c1"># each value to the 10,000th place:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     example_dataframe2 = pd.DataFrame(data_dict)</span>
    <span class="c1">#     example_dataframe2.round_to_fraction(&#39;a&#39;, 3, 4)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#             a  Bell__Chart  decorated-elephant  animals     cities</span>
    <span class="c1">#     0  1.3333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     1  2.3333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     2  3.3333     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     3  1.3333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     4  2.3333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     5  3.3333     1.500000            0.017964     lion      Basel</span>
    <span class="c1">#     6  1.3333     0.333333            0.004274   rabbit  Cambridge</span>
    <span class="c1">#     7  2.3333     0.285714            0.153846  leopard   Shanghai</span>
    <span class="c1">#     8  3.3333     1.500000            0.017964     lion      Basel</span>

    <span class="k">if</span> <span class="n">denominator</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;denominator&quot;</span><span class="p">,</span> <span class="n">denominator</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;digits&quot;</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span>

    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">*</span> <span class="n">denominator</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">digits</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">digits</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="transform_column"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.transform_column.html#janitor.transform_column">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="n">dest_col_name</span><span class="o">=</span><span class="s2">&quot;dest_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transform_column</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">dest_column_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">elementwise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Transform the given column in-place using the provided function.</span>

<span class="sd">    Functions can be applied one of two ways:</span>

<span class="sd">    - Element-wise (default; ``elementwise=True``)</span>
<span class="sd">    - Column-wise  (alternative; ``elementwise=False``)</span>

<span class="sd">    If the function is applied &quot;elementwise&quot;,</span>
<span class="sd">    then the first argument of the function signature</span>
<span class="sd">    should be the individual element of each function.</span>
<span class="sd">    This is the default behaviour of ``transform_column``,</span>
<span class="sd">    because it is easy to understand.</span>
<span class="sd">    For example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        def elemwise_func(x):</span>
<span class="sd">            modified_x = ... # do stuff here</span>
<span class="sd">            return modified_x</span>

<span class="sd">        df.transform_column(column_name=&quot;my_column&quot;, function=elementwise_func)</span>

<span class="sd">    On the other hand, columnwise application of a function</span>
<span class="sd">    behaves as if the function takes in a pandas Series</span>
<span class="sd">    and emits back a sequence that is of identical length to the original.</span>
<span class="sd">    One place where this is desirable</span>
<span class="sd">    is to gain access to `pandas` native string methods,</span>
<span class="sd">    which are super fast!</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        def columnwise_func(s: pd.Series) -&gt; pd.Series:</span>
<span class="sd">            return s.str[0:5]</span>

<span class="sd">        df.transform_column(</span>
<span class="sd">            column_name=&quot;my_column&quot;,</span>
<span class="sd">            lambda s: s.str[0:5],</span>
<span class="sd">            elementwise=False</span>
<span class="sd">        )</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Let&#39;s say we wanted to apply a log10 transform a column of data.</span>

<span class="sd">    Originally one would write code like this:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # YOU NO LONGER NEED TO WRITE THIS!</span>
<span class="sd">        df[column_name] = df[column_name].apply(np.log10)</span>

<span class="sd">    With the method chaining syntax, we can do the following instead:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .transform_column(column_name, np.log10)</span>
<span class="sd">        )</span>

<span class="sd">    With the functional syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = transform_column(df, column_name, np.log10)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column to transform.</span>
<span class="sd">    :param function: A function to apply on the column.</span>
<span class="sd">    :param dest_column_name: The column name to store the transformation result</span>
<span class="sd">        in. Defaults to None, which will result in the original column</span>
<span class="sd">        name being overwritten. If a name is provided here, then a new column</span>
<span class="sd">        with the transformed values will be created.</span>
<span class="sd">    :param elementwise: Whether to apply the function elementwise or not.</span>
<span class="sd">        If elementwise is True, then the function&#39;s first argument</span>
<span class="sd">        should be the data type of each datum in the column of data,</span>
<span class="sd">        and should return a transformed datum.</span>
<span class="sd">        If elementwise is False, then the function&#39;s should expect</span>
<span class="sd">        a pandas Series passed into it, and return a pandas Series.</span>

<span class="sd">    :returns: A pandas DataFrame with a transformed column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dest_column_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dest_column_name</span> <span class="o">=</span> <span class="n">column_name</span>

    <span class="k">if</span> <span class="n">elementwise</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">])</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">dest_column_name</span><span class="p">:</span> <span class="n">result</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="transform_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.transform_columns.html#janitor.transform_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;column_names&quot;</span><span class="p">,</span> <span class="n">new_names</span><span class="o">=</span><span class="s2">&quot;new_column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transform_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">elementwise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">new_column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Transform multiple columns through the same transformation.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Super syntactic sugar!</span>

<span class="sd">    Basically wraps `transform_column` and calls it repeatedly over all column</span>
<span class="sd">    names provided.</span>

<span class="sd">    User can optionally supply either a suffix to create a new set of columns</span>
<span class="sd">    with the specified suffix, or provide a dictionary mapping each original</span>
<span class="sd">    column name to its corresponding new column name. Note that all column</span>
<span class="sd">    names must be strings.</span>

<span class="sd">    A few examples below. Firstly, to just log10 transform a list of columns</span>
<span class="sd">    without creating new columns to hold the transformed values:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .transform_columns([&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;], np.log10)</span>
<span class="sd">        )</span>

<span class="sd">    Secondly, to add a &#39;_log&#39; suffix when creating a new column, which we think</span>
<span class="sd">    is going to be the most common use case:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .transform_columns(</span>
<span class="sd">                [&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;],</span>
<span class="sd">                np.log10,</span>
<span class="sd">                suffix=&quot;_log&quot;</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    Finally, to provide new names explicitly:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .transform_column(</span>
<span class="sd">                [&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;],</span>
<span class="sd">                np.log10,</span>
<span class="sd">                new_column_names={</span>
<span class="sd">                    &#39;col1&#39;: &#39;transform1&#39;,</span>
<span class="sd">                    &#39;col2&#39;: &#39;transform2&#39;,</span>
<span class="sd">                    &#39;col3&#39;: &#39;transform3&#39;,</span>
<span class="sd">                    }</span>
<span class="sd">                )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_names: An iterable of columns to transform.</span>
<span class="sd">    :param function: A function to apply on each column.</span>
<span class="sd">    :param suffix: (optional) Suffix to use when creating new columns to hold</span>
<span class="sd">        the transformed values.</span>
<span class="sd">    :param elementwise: Passed on to `transform_column`; whether or not</span>
<span class="sd">        to apply the transformation function elementwise (True)</span>
<span class="sd">        or columnwise (False).</span>
<span class="sd">    :param new_column_names: (optional) An explicit mapping of old column names</span>
<span class="sd">        to new column names.</span>
<span class="sd">    :returns: A pandas DataFrame with transformed columns.</span>
<span class="sd">    :raises ValueError: if both ``suffix`` and ``new_column_names`` are</span>
<span class="sd">        specified</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dest_column_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">column_names</span><span class="p">,</span> <span class="n">column_names</span><span class="p">))</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_names&quot;</span><span class="p">,</span> <span class="n">column_names</span><span class="p">,</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_column_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;only one of suffix or new_column_names should be specified&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">suffix</span><span class="p">:</span>  <span class="c1"># If suffix is specified...</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;suffix&quot;</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
            <span class="n">dest_column_names</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">suffix</span>

    <span class="k">if</span> <span class="n">new_column_names</span><span class="p">:</span>  <span class="c1"># If new_column_names is specified...</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;new_column_names&quot;</span><span class="p">,</span> <span class="n">new_column_names</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">])</span>
        <span class="n">dest_column_names</span> <span class="o">=</span> <span class="n">new_column_names</span>

    <span class="c1"># Now, transform columns.</span>
    <span class="k">for</span> <span class="n">old_col</span><span class="p">,</span> <span class="n">new_col</span> <span class="ow">in</span> <span class="n">dest_column_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">transform_column</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">old_col</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">new_col</span><span class="p">,</span> <span class="n">elementwise</span><span class="o">=</span><span class="n">elementwise</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="min_max_scale"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.min_max_scale.html#janitor.min_max_scale">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">min_max_scale</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">old_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">old_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">column_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">new_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">new_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Scales data to between a minimum and maximum value.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    If `minimum` and `maximum` are provided, the true min/max of the</span>
<span class="sd">    `DataFrame` or column is ignored in the scaling process and replaced with</span>
<span class="sd">    these values, instead.</span>

<span class="sd">    One can optionally set a new target minimum and maximum value using the</span>
<span class="sd">    `new_min` and `new_max` keyword arguments. This will result in the</span>
<span class="sd">    transformed data being bounded between `new_min` and `new_max`.</span>

<span class="sd">    If a particular column name is specified, then only that column of data</span>
<span class="sd">    are scaled. Otherwise, the entire dataframe is scaled.</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).min_max_scale(column_name=&quot;a&quot;)</span>

<span class="sd">    Setting custom minimum and maximum:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .min_max_scale(</span>
<span class="sd">                column_name=&quot;a&quot;,</span>
<span class="sd">                new_min=2,</span>
<span class="sd">                new_max=10</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    Setting a min and max that is not based on the data, while applying to</span>
<span class="sd">    entire dataframe:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .min_max_scale(</span>
<span class="sd">                old_min=0,</span>
<span class="sd">                old_max=14,</span>
<span class="sd">                new_min=0,</span>
<span class="sd">                new_max=1,</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    The aforementioned example might be applied to something like scaling the</span>
<span class="sd">    isoelectric points of amino acids. While technically they range from</span>
<span class="sd">    approx 3-10, we can also think of them on the pH scale which ranges from</span>
<span class="sd">    1 to 14. Hence, 3 gets scaled not to 0 but approx. 0.15 instead, while 10</span>
<span class="sd">    gets scaled to approx. 0.69 instead.</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param old_min: (optional) Overrides for the current minimum</span>
<span class="sd">        value of the data to be transformed.</span>
<span class="sd">    :param old_max: (optional) Overrides for the current maximum</span>
<span class="sd">        value of the data to be transformed.</span>
<span class="sd">    :param new_min: (optional) The minimum value of the data after</span>
<span class="sd">        it has been scaled.</span>
<span class="sd">    :param new_max: (optional) The maximum value of the data after</span>
<span class="sd">        it has been scaled.</span>
<span class="sd">    :param column_name: (optional) The column on which to perform scaling.</span>
<span class="sd">    :returns: A pandas DataFrame with scaled data.</span>
<span class="sd">    :raises ValueError: if ``old_max`` is not greater than ``old_min``.</span>
<span class="sd">    :raises ValueError: if ``new_max`` is not greater than ``new_min``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">old_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="n">old_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="n">old_max</span> <span class="o">&lt;=</span> <span class="n">old_min</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`old_max` should be greater than `old_min`&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">new_max</span> <span class="o">&lt;=</span> <span class="n">new_min</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`new_max` should be greater than `new_min`&quot;</span><span class="p">)</span>

    <span class="n">new_range</span> <span class="o">=</span> <span class="n">new_max</span> <span class="o">-</span> <span class="n">new_min</span>

    <span class="k">if</span> <span class="n">column_name</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">old_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_min</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">old_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_max</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">old_range</span> <span class="o">=</span> <span class="n">old_max</span> <span class="o">-</span> <span class="n">old_min</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_min</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">new_range</span> <span class="o">/</span> <span class="n">old_range</span> <span class="o">+</span> <span class="n">new_min</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">old_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_min</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">old_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_max</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">old_range</span> <span class="o">=</span> <span class="n">old_max</span> <span class="o">-</span> <span class="n">old_min</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span> <span class="o">-</span> <span class="n">old_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">new_range</span> <span class="o">/</span> <span class="n">old_range</span> <span class="o">+</span> <span class="n">new_min</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="collapse_levels"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.collapse_levels.html#janitor.collapse_levels">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">collapse_levels</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Flatten multi-level column dataframe to a single level.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Given a `DataFrame` containing multi-level columns, flatten to single-</span>
<span class="sd">    level by string-joining the column labels in each level.</span>

<span class="sd">    After a `groupby` / `aggregate` operation where `.agg()` is passed a</span>
<span class="sd">    list of multiple aggregation functions, a multi-level `DataFrame` is</span>
<span class="sd">    returned with the name of the function applied in the second level.</span>

<span class="sd">    It is sometimes convenient for later indexing to flatten out this</span>
<span class="sd">    multi-level configuration back into a single level. This function does</span>
<span class="sd">    this through a simple string-joining of all the names across different</span>
<span class="sd">    levels in a single column.</span>

<span class="sd">    Method chaining syntax given two value columns `[&#39;max_speed&#39;, &#39;type&#39;]`:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        data = {&quot;class&quot;: [&quot;bird&quot;, &quot;bird&quot;, &quot;bird&quot;, &quot;mammal&quot;, &quot;mammal&quot;],</span>
<span class="sd">                &quot;max_speed&quot;: [389, 389, 24, 80, 21],</span>
<span class="sd">                &quot;type&quot;: [&quot;falcon&quot;, &quot;falcon&quot;, &quot;parrot&quot;, &quot;Lion&quot;, &quot;Monkey&quot;]}</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(data)</span>
<span class="sd">                .groupby(&#39;class&#39;)</span>
<span class="sd">                .agg([&#39;mean&#39;, &#39;median&#39;])</span>
<span class="sd">                .collapse_levels(sep=&#39;_&#39;)</span>
<span class="sd">        )</span>

<span class="sd">    Before applying ``.collapse_levels``, the ``.agg`` operation returns a</span>
<span class="sd">    multi-level column `DataFrame` whose columns are (level 1, level 2):</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        [(&#39;class&#39;, &#39;&#39;), (&#39;max_speed&#39;, &#39;mean&#39;), (&#39;max_speed&#39;, &#39;median&#39;),</span>
<span class="sd">        (&#39;type&#39;, &#39;mean&#39;), (&#39;type&#39;, &#39;median&#39;)]</span>

<span class="sd">    ``.collapse_levels`` then flattens the column names to:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        [&#39;class&#39;, &#39;max_speed_mean&#39;, &#39;max_speed_median&#39;,</span>
<span class="sd">        &#39;type_mean&#39;, &#39;type_median&#39;]</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param sep: String separator used to join the column level names</span>
<span class="sd">    :returns: A flattened pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;sep&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>

    <span class="c1"># if already single-level, just return the DataFrame</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># noqa: PD011</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">tup</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># noqa: PD011</span>
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="currency_column_to_numeric"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.currency_column_to_numeric.html#janitor.currency_column_to_numeric">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;cleaning_style&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">currency_column_to_numeric</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">,</span>
    <span class="n">cleaning_style</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cast_non_numeric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_all_non_numeric</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">remove_non_numeric</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert currency column to numeric.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    This method allows one to take a column containing currency values,</span>
<span class="sd">    inadvertently imported as a string, and cast it as a float. This is</span>
<span class="sd">    usually the case when reading CSV files that were modified in Excel.</span>
<span class="sd">    Empty strings (i.e. `&#39;&#39;`) are retained as `NaN` values.</span>

<span class="sd">    :param df: The DataFrame</span>
<span class="sd">    :param column_name: The column to modify</span>
<span class="sd">    :param cleaning_style: What style of cleaning to perform. If None, standard</span>
<span class="sd">        cleaning is applied. Options are:</span>

<span class="sd">            * &#39;accounting&#39;:</span>
<span class="sd">            Replaces numbers in parentheses with negatives, removes commas.</span>

<span class="sd">    :param cast_non_numeric: A dict of how to coerce certain strings. For</span>
<span class="sd">        example, if there are values of &#39;REORDER&#39; in the DataFrame,</span>
<span class="sd">        {&#39;REORDER&#39;: 0} will cast all instances of &#39;REORDER&#39; to 0.</span>
<span class="sd">    :param fill_all_non_numeric: Similar to `cast_non_numeric`, but fills all</span>
<span class="sd">        strings to the same value. For example,  fill_all_non_numeric=1, will</span>
<span class="sd">        make everything that doesn&#39;t coerce to a currency 1.</span>
<span class="sd">    :param remove_non_numeric: Will remove rows of a DataFrame that contain</span>
<span class="sd">        non-numeric values in the `column_name` column. Defaults to `False`.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Convert this to a notebook.</span>
    <span class="c1"># :Example Setup:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     import pandas as pd</span>
    <span class="c1">#     import janitor</span>
    <span class="c1">#     data = {</span>
    <span class="c1">#         &quot;a&quot;: [&quot;-$1.00&quot;, &quot;&quot;, &quot;REPAY&quot;] * 2 + [&quot;$23.00&quot;, &quot;&quot;,</span>
    <span class="c1"># &quot;Other Account&quot;],</span>
    <span class="c1">#         &quot;Bell__Chart&quot;: [1.234_523_45, 2.456_234, 3.234_612_5] * 3,</span>
    <span class="c1">#         &quot;decorated-elephant&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;animals@#$%^&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
    <span class="c1">#         &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3,</span>
    <span class="c1">#     }</span>
    <span class="c1">#     df = pd.DataFrame(data)</span>

    <span class="c1"># :Example 1: Coerce numeric values in column to float:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2   NaN     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5   NaN     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     8   NaN     3.234612                   3         lion      Basel</span>

    <span class="c1"># :Example 2: Coerce numeric values in column to float, and replace a</span>
    <span class="c1"># string\</span>
    <span class="c1"># value with a specific value:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     cast_non_numeric = {&quot;REPAY&quot;: 22}</span>
    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, cast_non_numeric=cast_non_numeric)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     8   NaN     3.234612                   3         lion      Basel</span>

    <span class="c1"># :Example 3: Coerce numeric values in column to float, and replace all\</span>
    <span class="c1">#     string value with a specific value:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, fill_all_non_numeric=35)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2  35.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5  35.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     8  35.0     3.234612                   3         lion      Basel</span>

    <span class="c1"># :Example 4: Coerce numeric values in column to float, replace a string\</span>
    <span class="c1">#     value with a specific value, and replace remaining string values</span>
    <span class="c1"># with\</span>
    <span class="c1">#     a specific value:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, cast_non_numeric=cast_non_numeric,</span>
    <span class="c1">#     fill_all_non_numeric=35)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     8  35.0     3.234612                   3         lion      Basel</span>

    <span class="c1"># :Example 5: Coerce numeric values in column to float, and remove string\</span>
    <span class="c1">#     values:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, remove_non_numeric=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>

    <span class="c1"># :Example 6: Coerce numeric values in column to float, replace a string\</span>
    <span class="c1">#     value with a specific value, and remove remaining string values:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.currency_column_to_numeric(&quot;a&quot;, cast_non_numeric=cast_non_numeric,</span>
    <span class="c1">#     remove_non_numeric=True)</span>

    <span class="c1"># :Output:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#           a  Bell__Chart  decorated-elephant animals@#$%^     cities</span>
    <span class="c1">#     0  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     1   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     2  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     3  -1.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     4   NaN     2.456234                   2      leopard   Shanghai</span>
    <span class="c1">#     5  22.0     3.234612                   3         lion      Basel</span>
    <span class="c1">#     6  23.0     1.234523                   1       rabbit  Cambridge</span>
    <span class="c1">#     7   NaN     2.456234                   2      leopard   Shanghai</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>

    <span class="n">column_series</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cleaning_style</span> <span class="o">==</span> <span class="s2">&quot;accounting&quot;</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="n">_clean_accounting_column</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">if</span> <span class="n">cast_non_numeric</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;cast_non_numeric&quot;</span><span class="p">,</span> <span class="n">cast_non_numeric</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">])</span>

    <span class="n">_make_cc_patrial</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">_currency_column_to_numeric</span><span class="p">,</span> <span class="n">cast_non_numeric</span><span class="o">=</span><span class="n">cast_non_numeric</span>
    <span class="p">)</span>

    <span class="n">column_series</span> <span class="o">=</span> <span class="n">column_series</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">_make_cc_patrial</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_non_numeric</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">column_series</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># _replace_empty_string_with_none is applied here after the check on</span>
    <span class="c1"># remove_non_numeric since &quot;&quot; is our indicator that a string was coerced</span>
    <span class="c1"># in the original column</span>
    <span class="n">column_series</span> <span class="o">=</span> <span class="n">_replace_empty_string_with_none</span><span class="p">(</span><span class="n">column_series</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fill_all_non_numeric</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;fill_all_non_numeric&quot;</span><span class="p">,</span> <span class="n">fill_all_non_numeric</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
        <span class="n">column_series</span> <span class="o">=</span> <span class="n">column_series</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_all_non_numeric</span><span class="p">)</span>

    <span class="n">column_series</span> <span class="o">=</span> <span class="n">_replace_original_empty_string_with_none</span><span class="p">(</span><span class="n">column_series</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">column_name</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">column_series</span><span class="p">)})</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="select_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.select_columns.html#janitor.select_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">search_cols</span><span class="o">=</span><span class="s2">&quot;search_column_names&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">select_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">invert</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method-chainable selection of columns.</span>

<span class="sd">    Not applicable to MultiIndex columns.</span>

<span class="sd">    It accepts a string, shell-like glob strings (*string*),</span>
<span class="sd">    regex, slice, array-like object, or a list of the previous options.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Optional ability to invert selection of columns available as well.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    ::</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        import numpy as np</span>
<span class="sd">        import datetime</span>
<span class="sd">        import re</span>
<span class="sd">        from janitor import patterns</span>

<span class="sd">        df = pd.DataFrame(</span>
<span class="sd">                {</span>
<span class="sd">                    &quot;id&quot;: [0, 1],</span>
<span class="sd">                    &quot;Name&quot;: [&quot;ABC&quot;, &quot;XYZ&quot;],</span>
<span class="sd">                    &quot;code&quot;: [1, 2],</span>
<span class="sd">                    &quot;code1&quot;: [4, np.nan],</span>
<span class="sd">                    &quot;code2&quot;: [&quot;8&quot;, 5],</span>
<span class="sd">                    &quot;type&quot;: [&quot;S&quot;, &quot;R&quot;],</span>
<span class="sd">                    &quot;type1&quot;: [&quot;E&quot;, np.nan],</span>
<span class="sd">                    &quot;type2&quot;: [&quot;T&quot;, &quot;U&quot;],</span>
<span class="sd">                    &quot;code3&quot;: pd.Series([&quot;a&quot;, &quot;b&quot;], dtype=&quot;category&quot;),</span>
<span class="sd">                    &quot;type3&quot;: pd.to_datetime([np.datetime64(&quot;2018-01-01&quot;),</span>
<span class="sd">                                            datetime.datetime(2018, 1, 1)]),</span>
<span class="sd">                }</span>
<span class="sd">            )</span>

<span class="sd">        df</span>

<span class="sd">           id Name  code  code1 code2 type type1 type2 code3    type3</span>
<span class="sd">        0   0  ABC     1    4.0     8    S     E     T     a 2018-01-01</span>
<span class="sd">        1   1  XYZ     2    NaN     5    R   NaN     U     b 2018-01-01</span>


<span class="sd">    - Select by string::</span>

<span class="sd">        df.select_columns(&quot;id&quot;)</span>
<span class="sd">           id</span>
<span class="sd">       0   0</span>
<span class="sd">       1   1</span>

<span class="sd">    Select via shell-like glob strings (*) is possible::</span>

<span class="sd">        df.select_columns(&quot;*type*&quot;)</span>

<span class="sd">           type type1 type2      type3</span>
<span class="sd">        0    S     E     T 2018-01-01</span>
<span class="sd">        1    R   NaN     U 2018-01-01</span>

<span class="sd">    - Select by slice::</span>

<span class="sd">        df.select_columns(slice(&quot;code1&quot;, &quot;type1&quot;))</span>

<span class="sd">           code1 code2 type type1</span>
<span class="sd">        0    4.0     8    S     E</span>
<span class="sd">        1    NaN     5    R   NaN</span>

<span class="sd">    - Select by callable (the callable is applied to every column</span>
<span class="sd">      and should return a single ``True`` or ``False`` per column)::</span>

<span class="sd">        df.select_columns(pd.api.types.is_datetime64_dtype)</span>

<span class="sd">               type3</span>
<span class="sd">        0 2018-01-01</span>
<span class="sd">        1 2018-01-01</span>

<span class="sd">        df.select_columns(lambda x: x.name.startswith(&quot;code&quot;) or</span>
<span class="sd">                                    x.name.endswith(&quot;1&quot;))</span>

<span class="sd">           code  code1 code2 type1 code3</span>
<span class="sd">        0     1    4.0     8     E     a</span>
<span class="sd">        1     2    NaN     5   NaN     b</span>

<span class="sd">        df.select_columns(lambda x: x.isna().any())</span>

<span class="sd">             code1 type1</span>
<span class="sd">        0    4.0     E</span>
<span class="sd">        1    NaN   NaN</span>

<span class="sd">    - Select by regular expression::</span>

<span class="sd">        df.select_columns(re.compile(&quot;\\d+&quot;))</span>

<span class="sd">           code1 code2 type1 type2 code3      type3</span>
<span class="sd">        0    4.0     8     E     T     a 2018-01-01</span>
<span class="sd">        1    NaN     5   NaN     U     b 2018-01-01</span>

<span class="sd">        # same as above, with janitor.patterns</span>
<span class="sd">        # simply a wrapper around re.compile</span>

<span class="sd">        df.select_columns(patterns(&quot;\\d+&quot;))</span>

<span class="sd">           code1 code2 type1 type2 code3      type3</span>
<span class="sd">        0    4.0     8     E     T     a 2018-01-01</span>
<span class="sd">        1    NaN     5   NaN     U     b 2018-01-01</span>

<span class="sd">    - Select a combination of the above</span>
<span class="sd">      (you can combine any of the previous options)::</span>

<span class="sd">        df.select_columns(&quot;id&quot;, &quot;code*&quot;, slice(&quot;code&quot;, &quot;code2&quot;))</span>

<span class="sd">           id  code  code1 code2 code3</span>
<span class="sd">        0   0     1    4.0     8     a</span>
<span class="sd">        1   1     2    NaN     5     b</span>

<span class="sd">    - You can also pass a sequence of booleans::</span>

<span class="sd">        df.select_columns([True, False, True, True, True,</span>
<span class="sd">                           False, False, False, True, False])</span>

<span class="sd">           id  code  code1 code2 code3</span>
<span class="sd">        0   0     1    4.0     8     a</span>
<span class="sd">        1   1     2    NaN     5     b</span>

<span class="sd">    - Setting ``invert`` to ``True``</span>
<span class="sd">      returns the complement of the columns provided::</span>

<span class="sd">        df.select_columns(&quot;id&quot;, &quot;code*&quot;, slice(&quot;code&quot;, &quot;code2&quot;),</span>
<span class="sd">                          invert = True)</span>

<span class="sd">           Name type type1 type2      type3</span>
<span class="sd">        0  ABC    S     E     T 2018-01-01</span>
<span class="sd">        1  XYZ    R   NaN     U 2018-01-01</span>

<span class="sd">    Functional usage example::</span>

<span class="sd">       import pandas as pd</span>
<span class="sd">       import janitor as jn</span>

<span class="sd">       df = pd.DataFrame(...)</span>

<span class="sd">       df = jn.select_columns(&#39;a&#39;, &#39;b&#39;, &#39;col_*&#39;,</span>
<span class="sd">                              invert=True)</span>

<span class="sd">    Method-chaining example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .select_columns(&#39;a&#39;, &#39;b&#39;, &#39;col_*&#39;,</span>
<span class="sd">              invert=True))</span>


<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param args: Valid inputs include:</span>

<span class="sd">        - an exact column name to look for</span>
<span class="sd">        - a shell-style glob string (e.g., `*_thing_*`)</span>
<span class="sd">        - a regular expression</span>
<span class="sd">        - a callable which is applicable to each Series in the dataframe</span>
<span class="sd">        - variable arguments of all the aforementioned.</span>
<span class="sd">        - a sequence of booleans.</span>
<span class="sd">    :param invert: Whether or not to invert the selection.</span>
<span class="sd">        This will result in the selection of the complement of the columns</span>
<span class="sd">        provided.</span>
<span class="sd">    :returns: A pandas DataFrame with the specified columns selected.</span>
<span class="sd">    :raises KeyError: if one or more of the specified column names or</span>
<span class="sd">        search strings are not found in DataFrame columns.</span>
<span class="sd">    :raises ValueError: if the columns is a MultiIndex.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># applicable for any</span>
    <span class="c1"># list-like object (ndarray, Series, pd.Index, ...)</span>
    <span class="c1"># excluding tuples, which are returned as is</span>
    <span class="n">search_column_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">search_column_names</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="o">*</span><span class="n">arg</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">search_column_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">search_column_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">search_column_names</span> <span class="o">=</span> <span class="n">search_column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">full_column_list</span> <span class="o">=</span> <span class="n">_select_columns</span><span class="p">(</span><span class="n">search_column_names</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">full_column_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">full_column_list</span><span class="p">]</span></div>


<div class="viewcode-block" id="impute"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.impute.html#janitor.impute">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">statistic</span><span class="o">=</span><span class="s2">&quot;statistic_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">impute</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">statistic_column_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Method-chainable imputation of values in a column.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Underneath the hood, this function calls the ``.fillna()`` method available</span>
<span class="sd">    to every pandas.Series object.</span>

<span class="sd">    Method-chaining example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        data = {</span>
<span class="sd">            &quot;a&quot;: [1, 2, 3],</span>
<span class="sd">            &quot;sales&quot;: np.nan,</span>
<span class="sd">            &quot;score&quot;: [np.nan, 3, 2]}</span>
<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(data)</span>
<span class="sd">            # Impute null values with 0</span>
<span class="sd">            .impute(column_name=&#39;sales&#39;, value=0.0)</span>
<span class="sd">            # Impute null values with median</span>
<span class="sd">            .impute(column_name=&#39;score&#39;, statistic_column_name=&#39;median&#39;)</span>
<span class="sd">        )</span>

<span class="sd">    Either one of ``value`` or ``statistic_column_name`` should be provided.</span>

<span class="sd">    If ``value`` is provided, then all null values in the selected column will</span>
<span class="sd">        take on the value provided.</span>

<span class="sd">    If ``statistic_column_name`` is provided, then all null values in the</span>
<span class="sd">    selected column will take on the summary statistic value of other non-null</span>
<span class="sd">    values.</span>

<span class="sd">    Currently supported statistics include:</span>

<span class="sd">    - ``mean`` (also aliased by ``average``)</span>
<span class="sd">    - ``median``</span>
<span class="sd">    - ``mode``</span>
<span class="sd">    - ``minimum`` (also aliased by ``min``)</span>
<span class="sd">    - ``maximum`` (also aliased by ``max``)</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param column_name: The name of the column on which to impute values.</span>
<span class="sd">    :param value: (optional) The value to impute.</span>
<span class="sd">    :param statistic_column_name: (optional) The column statistic to impute.</span>
<span class="sd">    :returns: An imputed pandas DataFrame.</span>
<span class="sd">    :raises ValueError: if both ``value`` and ``statistic`` are provided.</span>
<span class="sd">    :raises KeyError: if ``statistic`` is not one of ``mean``, ``average``</span>
<span class="sd">        ``median``, ``mode``, ``minimum``, ``min``, ``maximum``, or ``max``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Firstly, we check that only one of `value` or `statistic` are provided.</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">statistic_column_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Only one of `value` or `statistic` should be provided&quot;</span>
        <span class="p">)</span>

    <span class="c1"># If statistic is provided, then we compute the relevant summary statistic</span>
    <span class="c1"># from the other data.</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
        <span class="s2">&quot;average&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>  <span class="c1"># aliased</span>
        <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">,</span>
        <span class="s2">&quot;mode&quot;</span><span class="p">:</span> <span class="n">mode</span><span class="p">,</span>
        <span class="s2">&quot;minimum&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
        <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>  <span class="c1"># aliased</span>
        <span class="s2">&quot;maximum&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
        <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>  <span class="c1"># aliased</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">statistic_column_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check that the statistic keyword argument is one of the approved.</span>
        <span class="k">if</span> <span class="n">statistic_column_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`statistic` must be one of </span><span class="si">{</span><span class="n">funcs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="n">statistic_column_name</span><span class="p">](</span>
            <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="c1"># special treatment for mode, because scipy stats mode returns a</span>
        <span class="c1"># moderesult object.</span>
        <span class="k">if</span> <span class="n">statistic_column_name</span> <span class="o">==</span> <span class="s2">&quot;mode&quot;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># The code is architected this way - if `value` is not provided but</span>
    <span class="c1"># statistic is, we then overwrite the None value taken on by `value`, and</span>
    <span class="c1"># use it to set the imputation column.</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="then"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.then.html#janitor.then">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">then</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add an arbitrary function to run in the ``pyjanitor`` method chain.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param func: A function you would like to run in the method chain.</span>
<span class="sd">        It should take one parameter and return one parameter, each being the</span>
<span class="sd">        DataFrame object. After that, do whatever you want in the middle.</span>
<span class="sd">        Go crazy.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="also"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.also.html#janitor.also">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">also</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add an arbitrary function with no return value to run in the</span>
<span class="sd">    ``pyjanitor`` method chain. This returns the input dataframe instead,</span>
<span class="sd">    not the output of `func`.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .query(...)</span>
<span class="sd">            .also(lambda df: print(f&quot;DataFrame shape is: {df.shape}&quot;))</span>
<span class="sd">            .transform_column(...)</span>
<span class="sd">            .also(lambda df: df.to_csv(&quot;midpoint.csv&quot;))</span>
<span class="sd">            .also(</span>
<span class="sd">                lambda df: print(</span>
<span class="sd">                    f&quot;Column col_name has these values: {set(df[&#39;col_name&#39;].unique())}&quot;</span>
<span class="sd">                )</span>
<span class="sd">            )</span>
<span class="sd">            .group_add(...)</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param func: A function you would like to run in the method chain.</span>
<span class="sd">        It should take one DataFrame object as a parameter and have no return.</span>
<span class="sd">        If there is a return, it will be ignored.</span>
<span class="sd">    :param args: Optional arguments for ``func``.</span>
<span class="sd">    :param kwargs: Optional keyword arguments for ``func``.</span>
<span class="sd">    :returns: The input pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="n">func</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="dropnotnull"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.dropnotnull.html#janitor.dropnotnull">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dropnotnull</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Drop rows that do not have null values in the given column.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).dropnotnull(&#39;column3&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column name to drop rows from.</span>
<span class="sd">    :returns: A pandas DataFrame with dropped rows.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">])]</span></div>


<div class="viewcode-block" id="find_replace"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.find_replace.html#janitor.find_replace">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">find_replace</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;exact&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">mappings</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Perform a find-and-replace action on provided columns.</span>

<span class="sd">    Depending on use case, users can choose either exact, full-value matching,</span>
<span class="sd">    or regular-expression-based fuzzy matching</span>
<span class="sd">    (hence allowing substring matching in the latter case).</span>
<span class="sd">    For strings, the matching is always case sensitive.</span>

<span class="sd">    For instance, given a dataframe containing orders at a coffee shop:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame({</span>
<span class="sd">            &#39;customer&#39;: [&#39;Mary&#39;, &#39;Tom&#39;, &#39;Lila&#39;],</span>
<span class="sd">            &#39;order&#39;: [&#39;ice coffee&#39;, &#39;lemonade&#39;, &#39;regular coffee&#39;]</span>
<span class="sd">        })</span>

<span class="sd">    Our task is to replace values `&#39;ice coffee&#39;` and `&#39;regular coffee&#39;`</span>
<span class="sd">    of the `&#39;order&#39;` column into `&#39;latte&#39;`.</span>

<span class="sd">    Example 1 for exact matching</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # Functional usage</span>
<span class="sd">        df = find_replace(</span>
<span class="sd">            df,</span>
<span class="sd">            match=&#39;exact&#39;,</span>
<span class="sd">            order={&#39;ice coffee&#39;: &#39;latte&#39;, &#39;regular coffee&#39;: &#39;latte&#39;},</span>
<span class="sd">        )</span>

<span class="sd">        # Method chaining usage</span>
<span class="sd">        df = df.find_replace(</span>
<span class="sd">            match=&#39;exact&#39;</span>
<span class="sd">            order={&#39;ice coffee&#39;: &#39;latte&#39;, &#39;regular coffee&#39;: &#39;latte&#39;},</span>
<span class="sd">        )</span>

<span class="sd">    Example 2: Regular-expression-based matching</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        # Functional usage</span>
<span class="sd">        df = find_replace(</span>
<span class="sd">            df,</span>
<span class="sd">            match=&#39;regex&#39;,</span>
<span class="sd">            order={&#39;coffee$&#39;: &#39;latte&#39;},</span>
<span class="sd">        )</span>

<span class="sd">        # Method chaining usage</span>
<span class="sd">        df = df.find_replace(</span>
<span class="sd">            match=&#39;regex&#39;,</span>
<span class="sd">            order={&#39;coffee$&#39;: &#39;latte&#39;},</span>
<span class="sd">        )</span>

<span class="sd">    To perform a find and replace on the entire dataframe,</span>
<span class="sd">    pandas&#39; ``df.replace()`` function provides the appropriate functionality.</span>
<span class="sd">    You can find more detail on the replace_ docs.</span>

<span class="sd">    This function only works with column names that have no spaces</span>
<span class="sd">    or punctuation in them.</span>
<span class="sd">    For example, a column name ``item_name`` would work with ``find_replace``,</span>
<span class="sd">    because it is a contiguous string that can be parsed correctly,</span>
<span class="sd">    but ``item name`` would not be parsed correctly by the Python interpreter.</span>

<span class="sd">    If you have column names that might not be compatible,</span>
<span class="sd">    we recommend calling on ``clean_names()`` as the first method call.</span>
<span class="sd">    If, for whatever reason, that is not possible,</span>
<span class="sd">    then ``_find_replace()`` is available as a function</span>
<span class="sd">    that you can do a pandas pipe_ call on.</span>

<span class="sd">    .. _replace: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.replace.html</span>
<span class="sd">    .. _pipe: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pipe.html</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param match: Whether or not to perform an exact match or not.</span>
<span class="sd">        Valid values are &quot;exact&quot; or &quot;regex&quot;.</span>
<span class="sd">    :param mappings: keyword arguments corresponding to column names</span>
<span class="sd">        that have dictionaries passed in indicating what to find (keys)</span>
<span class="sd">        and what to replace with (values).</span>
<span class="sd">    :returns: A pandas DataFrame with replaced values.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="k">for</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">mapper</span> <span class="ow">in</span> <span class="n">mappings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">_find_replace</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">match</span><span class="o">=</span><span class="n">match</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="k">def</span> <span class="nf">_find_replace</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mapper</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;exact&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Utility function for ``find_replace``.</span>

<span class="sd">    The code in here was the original implementation of ``find_replace``,</span>
<span class="sd">    but we decided to change out the front-facing API to accept</span>
<span class="sd">    kwargs + dictionaries for readability,</span>
<span class="sd">    and instead dispatch underneath to this function.</span>
<span class="sd">    This implementation was kept</span>
<span class="sd">    because it has a number of validations that are quite useful.</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column on which the find/replace action is to be</span>
<span class="sd">        made. Must be a string.</span>
<span class="sd">    :param mapper: A dictionary that maps &quot;thing to find&quot; -&gt; &quot;thing to</span>
<span class="sd">        replace&quot;.  Note: Does not support null-value replacement.</span>
<span class="sd">    :param match: A string that dictates whether exact match or</span>
<span class="sd">        regular-expression-based fuzzy match will be used for finding patterns.</span>
<span class="sd">        Default to &quot;exact&quot;. Can only be &quot;exact&quot; or &quot;regex&quot;.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    :raises ValueError: is trying to use null replacement. Kindly use</span>
<span class="sd">        ``.fillna()`` instead.</span>
<span class="sd">    :raises ValueError: if ``match`` is not one of &#39;exact&#39; or &#39;regex&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">,</span> <span class="n">mapper</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;find_replace() does not support null replacement. &quot;</span>
            <span class="s2">&quot;Use DataFrame.fillna() instead.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;exact&quot;</span><span class="p">,</span> <span class="s2">&quot;regex&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`match` can only be &#39;exact&#39; or &#39;regex&#39;.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;exact&quot;</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;regex&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">condition</span><span class="p">,</span> <span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">df</span>


<div class="viewcode-block" id="update_where"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.update_where.html#janitor.update_where">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">target_col</span><span class="o">=</span><span class="s2">&quot;target_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update_where</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">conditions</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">target_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">target_val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add multiple conditions to update a column in the dataframe.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        data = {</span>
<span class="sd">            &quot;a&quot;: [1, 2, 3, 4],</span>
<span class="sd">            &quot;b&quot;: [5, 6, 7, 8],</span>
<span class="sd">            &quot;c&quot;: [0, 0, 0, 0]</span>
<span class="sd">        }</span>
<span class="sd">        df = pd.DataFrame(data)</span>

<span class="sd">           a  b  c</span>
<span class="sd">        0  1  5  0</span>
<span class="sd">        1  2  6  0</span>
<span class="sd">        2  3  7  0</span>
<span class="sd">        3  4  8  0</span>

<span class="sd">        df.update_where(conditions = (df.a &gt; 2) &amp; (df.b &lt; 8),</span>
<span class="sd">                        target_column_name = &#39;c&#39;,</span>
<span class="sd">                        target_val = 10)</span>

<span class="sd">           a  b   c</span>
<span class="sd">        0  1  5   0</span>
<span class="sd">        1  2  6   0</span>
<span class="sd">        2  3  7  10</span>
<span class="sd">        3  4  8   0</span>

<span class="sd">    `update_where` also supports pandas *query* style string expressions::</span>

<span class="sd">        df.update_where(conditions = &quot;a &gt; 2 and b &lt; 8&quot;,</span>
<span class="sd">                        target_column_name = &#39;c&#39;,</span>
<span class="sd">                        target_val = 10)</span>

<span class="sd">           a  b   c</span>
<span class="sd">        0  1  5   0</span>
<span class="sd">        1  2  6   0</span>
<span class="sd">        2  3  7  10</span>
<span class="sd">        3  4  8   0</span>


<span class="sd">    :param df: The pandas DataFrame object.</span>
<span class="sd">    :param conditions: Conditions used to update a target column</span>
<span class="sd">        and target value.</span>
<span class="sd">    :param target_column_name: Column to be updated. If column does not exist</span>
<span class="sd">        in dataframe, a new column will be created; note that entries that do</span>
<span class="sd">        not get set in the new column will be null.</span>
<span class="sd">    :param target_val: Value to be updated</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    :raises IndexError: if ``conditions`` does not have the same length as</span>
<span class="sd">        ``df``.</span>
<span class="sd">    :raises TypeError: if ``conditions`` is not a pandas-compatible string</span>
<span class="sd">        query.</span>
<span class="sd">    :raises ValueError: if ``conditions`` does not return a boolean array-like</span>
<span class="sd">        data structure.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># use query mode if a string expression is passed</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conditions</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">conditions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Kindly ensure that `conditions` passed</span>
<span class="sd">            evaluates to a Boolean dtype.</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">conditions</span><span class="p">,</span> <span class="n">target_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_val</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="to_datetime"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.to_datetime.html#janitor.to_datetime">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">to_datetime</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Method-chainable to_datetime.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = to_datetime(df, &#39;col1&#39;, format=&#39;%Y%m%d&#39;)</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).to_datetime(&#39;col1&#39;, format=&#39;%Y%m%d&#39;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: Column name.</span>
<span class="sd">    :param kwargs: provide any kwargs that pd.to_datetime can take.</span>
<span class="sd">    :returns: A pandas DataFrame with updated datetime data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">truncate_datetime_dataframe</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">datepart</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">truncate_datetime</span><span class="p">(</span><span class="n">datepart</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">return</span> <span class="n">df</span>


<span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">truncate_datetime</span><span class="p">(</span><span class="n">datepart</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">:</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Truncate times down to a user-specified precision of</span>
<span class="sd">    year, month, day, hour, minute, or second.</span>

<span class="sd">    Call on datetime object to truncate it.</span>
<span class="sd">    Calling on existing df will not alter the contents</span>
<span class="sd">    of said df.</span>

<span class="sd">    Note: Truncating down to a Month or Day will yields 0s,</span>
<span class="sd">    as there is no 0 month or 0 day in most datetime systems.</span>

<span class="sd">    :param datepart: Truncation precision, YEAR, MONTH, DAY,</span>
<span class="sd">        HOUR, MINUTE, SECOND. (String is automagically</span>
<span class="sd">        capitalized)</span>
<span class="sd">    :param timestamp: expecting a datetime from python datetime class (dt)</span>
<span class="sd">    :raises KeyError: if inappropriate precision is passed</span>

<span class="sd">    :returns: a truncated datetime object to</span>
<span class="sd">        the precision specified by datepart.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">recurrence</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># [YEAR, MONTH, DAY, HOUR, MINUTE, SECOND]</span>
    <span class="n">datepart</span> <span class="o">=</span> <span class="n">datepart</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="n">ENUM</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;YEAR&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;MONTH&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;DAY&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;HOUR&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;MINUTE:&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s2">&quot;SECOND&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">:</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">year</span><span class="p">,</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">month</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">day</span><span class="p">,</span>
        <span class="mi">3</span><span class="p">:</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
        <span class="mi">4</span><span class="p">:</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span>
        <span class="mi">5</span><span class="p">:</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">second</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ENUM</span><span class="p">[</span><span class="n">datepart</span><span class="p">]</span>
    <span class="c1"># Capture the error but replace it with explicit instructions.</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Invalid truncation. Please enter any one of &#39;year&#39;, &quot;</span>
            <span class="s2">&quot;&#39;month&#39;, &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39; or &#39;second&#39;.&quot;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ENUM</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">datepart</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">recurrence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENUM</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
        <span class="n">recurrence</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">recurrence</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">recurrence</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">recurrence</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="n">recurrence</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
        <span class="n">recurrence</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
    <span class="p">)</span>


<div class="viewcode-block" id="groupby_agg"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.groupby_agg.html#janitor.groupby_agg">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">new_column</span><span class="o">=</span><span class="s2">&quot;new_column_name&quot;</span><span class="p">,</span> <span class="n">agg_column</span><span class="o">=</span><span class="s2">&quot;agg_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">groupby_agg</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">by</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">new_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">agg_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">agg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shortcut for assigning a groupby-transform to a new column.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Without this function, we would have to write a verbose line:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = df.assign(...=df.groupby(...)[...].transform(...))</span>

<span class="sd">    Now, this function can be method-chained:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = pd.DataFrame(...).groupby_agg(by=&#39;group&#39;,</span>
<span class="sd">                                           agg=&#39;mean&#39;,</span>
<span class="sd">                                           agg_column_name=&quot;col1&quot;</span>
<span class="sd">                                           new_column_name=&#39;col1_mean_by_group&#39;,</span>
<span class="sd">                                           dropna = True/False)</span>

<span class="sd">    Examples::</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">            group  var1</span>
<span class="sd">        0      1     1</span>
<span class="sd">        1      1     1</span>
<span class="sd">        2      1     1</span>
<span class="sd">        3      1     1</span>
<span class="sd">        4      1     2</span>
<span class="sd">        5      2     1</span>
<span class="sd">        6      2     2</span>
<span class="sd">        7      2     2</span>
<span class="sd">        8      2     2</span>
<span class="sd">        9      2     3</span>

<span class="sd">    Let&#39;s get the count per `group` and `var1`::</span>

<span class="sd">        df.groupby_agg(</span>
<span class="sd">            by = [&#39;group&#39;, &#39;var1&#39;],</span>
<span class="sd">            agg = &#39;size&#39;,</span>
<span class="sd">            agg_column_name = &#39;var1&#39;,</span>
<span class="sd">            new_column_name = &#39;count&#39;</span>
<span class="sd">        )</span>

<span class="sd">            group  var1  size</span>
<span class="sd">        0      1     1     4</span>
<span class="sd">        1      1     1     4</span>
<span class="sd">        2      1     1     4</span>
<span class="sd">        3      1     1     4</span>
<span class="sd">        4      1     2     1</span>
<span class="sd">        5      2     1     1</span>
<span class="sd">        6      2     2     3</span>
<span class="sd">        7      2     2     3</span>
<span class="sd">        8      2     2     3</span>
<span class="sd">        9      2     3     1</span>

<span class="sd">    If the data has null values,</span>
<span class="sd">    you can include the null values by passing `False` to `dropna`;</span>
<span class="sd">    this feature was introduced in Pandas 1.1::</span>

<span class="sd">            name   type  num  nulls</span>
<span class="sd">        0  black  chair    4    1.0</span>
<span class="sd">        1  black  chair    5    1.0</span>
<span class="sd">        2  black   sofa   12    NaN</span>
<span class="sd">        3    red   sofa    4    NaN</span>
<span class="sd">        4    red  plate    3    3.0</span>

<span class="sd">    Let&#39;s get the count, including the null values,</span>
<span class="sd">    grouping on `nulls` column::</span>

<span class="sd">        df.groupby_agg(</span>
<span class="sd">            by=&quot;nulls&quot;,</span>
<span class="sd">            new_column_name=&quot;num_count&quot;,</span>
<span class="sd">            agg_column_name=&quot;num&quot;,</span>
<span class="sd">            agg=&quot;size&quot;,</span>
<span class="sd">            dropna=False,</span>
<span class="sd">        )</span>

<span class="sd">            name   type  num  nulls  num_count</span>
<span class="sd">        0  black  chair    4    1.0          2</span>
<span class="sd">        1  black  chair    5    1.0          2</span>
<span class="sd">        2  black   sofa   12    NaN          2</span>
<span class="sd">        3    red   sofa    4    NaN          2</span>
<span class="sd">        4    red  plate    3    3.0          1</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param by: Column(s) to groupby on, either a `str` or</span>
<span class="sd">               a `list` of `str`</span>
<span class="sd">    :param new_column_name: Name of the aggregation output column.</span>
<span class="sd">    :param agg_column_name: Name of the column to aggregate over.</span>
<span class="sd">    :param agg: How to aggregate.</span>
<span class="sd">    :param dropna: Whether or not to include null values,</span>
<span class="sd">        if present in the `by` column(s). Default is True.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">df</span><span class="p">[</span><span class="n">new_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)[</span>
        <span class="n">agg_column_name</span>
    <span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_accessor</span><span class="p">(</span><span class="s2">&quot;data_description&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DataDescription</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;High-level description of data present in this DataFrame.</span>

<span class="sd">    This is a custom data accessor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize DataDescription class.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_get_data_df</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;column_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;pct_missing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_desc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">df</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a table of descriptive information in a DataFrame format.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data_df</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Human-readable representation of the `DataDescription` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_data_df</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print the table of descriptive information about this DataFrame.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">desc</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Update the description for each of the columns in the DataFrame.</span>

<span class="sd">        :param desc: The structure containing the descriptions to update</span>
<span class="sd">        :raises ValueError: if length of description list does not match</span>
<span class="sd">            number of columns in DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Length of description list &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match number of columns in &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;DataFrame (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">desc</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="o">=</span> <span class="n">desc</span>


<div class="viewcode-block" id="bin_numeric"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.bin_numeric.html#janitor.bin_numeric">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">from_column</span><span class="o">=</span><span class="s2">&quot;from_column_name&quot;</span><span class="p">,</span> <span class="n">to_column</span><span class="o">=</span><span class="s2">&quot;to_column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bin_numeric</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">from_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">to_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">num_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generate a new column that labels bins for a specified numeric column.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    Makes use of pandas cut() function to bin data of one column, generating a</span>
<span class="sd">    new column with the results.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>
<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .bin_numeric(</span>
<span class="sd">                from_column_name=&#39;col1&#39;,</span>
<span class="sd">                to_column_name=&#39;col1_binned&#39;,</span>
<span class="sd">                num_bins=3,</span>
<span class="sd">                labels=[&#39;1-2&#39;, &#39;3-4&#39;, &#39;5-6&#39;]</span>
<span class="sd">                )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param from_column_name: The column whose data you want binned.</span>
<span class="sd">    :param to_column_name: The new column to be created with the binned data.</span>
<span class="sd">    :param num_bins: The number of bins to be utilized.</span>
<span class="sd">    :param labels: Optionally rename numeric bin ranges with labels. Number of</span>
<span class="sd">        label names must match number of bins specified.</span>
<span class="sd">    :return: A pandas DataFrame.</span>
<span class="sd">    :raises ValueError: if number of labels do not match number of bins.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">to_column_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">from_column_name</span><span class="p">)],</span> <span class="n">bins</span><span class="o">=</span><span class="n">num_bins</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_bins</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of labels must match number of bins.&quot;</span><span class="p">)</span>

        <span class="n">df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">to_column_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">from_column_name</span><span class="p">)],</span> <span class="n">bins</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="drop_duplicate_columns"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.drop_duplicate_columns.html#janitor.drop_duplicate_columns">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">drop_duplicate_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">nth_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Remove a duplicated column specified by column_name, its index.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Column order 0 is to remove the first column,</span>
<span class="sd">           order 1 is to remove the second column, and etc</span>

<span class="sd">    The corresponding tidyverse R&#39;s library is:</span>
<span class="sd">    `select(-&lt;column_name&gt;_&lt;nth_index + 1&gt;)`</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame({</span>
<span class="sd">            &quot;a&quot;: range(10),</span>
<span class="sd">            &quot;b&quot;: range(10),</span>
<span class="sd">            &quot;A&quot;: range(10, 20),</span>
<span class="sd">            &quot;a*&quot;: range(20, 30),</span>
<span class="sd">        }).clean_names(remove_special=True)</span>

<span class="sd">        # remove a duplicated second &#39;a&#39; column</span>
<span class="sd">        df.drop_duplicate_columns(column_name=&quot;a&quot;, nth_index=1)</span>



<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param column_name: Column to be removed</span>
<span class="sd">    :param nth_index: Among the duplicated columns,</span>
<span class="sd">        select the nth column to drop.</span>
<span class="sd">    :return: A pandas DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
    <span class="n">col_indexes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">col_idx</span>
        <span class="k">for</span> <span class="n">col_idx</span><span class="p">,</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col_name</span> <span class="o">==</span> <span class="n">column_name</span>
    <span class="p">]</span>

    <span class="c1"># given that a column could be duplicated,</span>
    <span class="c1"># user could opt based on its order</span>
    <span class="n">removed_col_idx</span> <span class="o">=</span> <span class="n">col_indexes</span><span class="p">[</span><span class="n">nth_index</span><span class="p">]</span>
    <span class="c1"># get the column indexes without column that is being removed</span>
    <span class="n">filtered_cols</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">c_i</span> <span class="k">for</span> <span class="n">c_i</span><span class="p">,</span> <span class="n">c_v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="k">if</span> <span class="n">c_i</span> <span class="o">!=</span> <span class="n">removed_col_idx</span>
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">filtered_cols</span><span class="p">]</span></div>


<div class="viewcode-block" id="take_first"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.take_first.html#janitor.take_first">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">take_first</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">subset</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]],</span>
    <span class="n">by</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Take the first row within each group specified by `subset`.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        data = {</span>
<span class="sd">            &quot;a&quot;: [&quot;x&quot;, &quot;x&quot;, &quot;y&quot;, &quot;y&quot;],</span>
<span class="sd">            &quot;b&quot;: [0, 1, 2, 3]</span>
<span class="sd">        }</span>
<span class="sd">        df = pd.DataFrame(data)</span>

<span class="sd">        df.take_first(subset=&quot;a&quot;, by=&quot;b&quot;)</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param subset: Column(s) defining the group.</span>
<span class="sd">    :param by: Column to sort by.</span>
<span class="sd">    :param ascending: Whether or not to sort in ascending order, `bool`.</span>
<span class="sd">    :returns: A pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">by</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span>
        <span class="n">subset</span><span class="o">=</span><span class="n">subset</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="shuffle"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.shuffle.html#janitor.shuffle">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reset_index</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Shuffle the rows of the DataFrame.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Super-sugary syntax! Underneath the hood, we use ``df.sample(frac=1)``,</span>
<span class="sd">    with the option to set the random state.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = pd.DataFrame(...).shuffle()</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param random_state: (optional) A seed for the random number generator.</span>
<span class="sd">    :param reset_index: (optional) Resets index to default integers</span>
<span class="sd">    :returns: A shuffled pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">reset_index</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="join_apply"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.join_apply.html#janitor.join_apply">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">join_apply</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">new_column_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Join the result of applying a function across dataframe rows.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    This is a convenience function that allows us to apply arbitrary functions</span>
<span class="sd">    that take any combination of information from any of the columns. The only</span>
<span class="sd">    requirement is that the function signature takes in a row from the</span>
<span class="sd">    DataFrame.</span>

<span class="sd">    The example below shows us how to sum the result of two columns into a new</span>
<span class="sd">    column.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame({&#39;a&#39;:[1, 2, 3], &#39;b&#39;: [2, 3, 4]})</span>
<span class="sd">            .join_apply(lambda x: 2 * x[&#39;a&#39;] + x[&#39;b&#39;], new_column_name=&quot;2a+b&quot;)</span>
<span class="sd">        )</span>

<span class="sd">    This following example shows us how to use conditionals in the same</span>
<span class="sd">    function.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        def take_a_if_even(x):</span>
<span class="sd">            if x[&#39;a&#39;] % 2:</span>
<span class="sd">                return x[&#39;a&#39;]</span>
<span class="sd">            else:</span>
<span class="sd">                return x[&#39;b&#39;]</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame({&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [2, 3, 4]})</span>
<span class="sd">            .join_apply(take_a_if_even, &#39;a_if_even&#39;)</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame</span>
<span class="sd">    :param func: A function that is applied elementwise across all rows of the</span>
<span class="sd">        DataFrame.</span>
<span class="sd">    :param new_column_name: New column name.</span>
<span class="sd">    :returns: A pandas DataFrame with new column appended.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">new_column_name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="flag_nulls"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.flag_nulls.html#janitor.flag_nulls">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">flag_nulls</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;null_flag&quot;</span><span class="p">,</span>
    <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Creates a new column to indicate whether you have null values in a given</span>
<span class="sd">    row. If the columns parameter is not set, looks across the entire</span>
<span class="sd">    DataFrame, otherwise will look only in the columns you set.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(</span>
<span class="sd">            {&#39;a&#39;: [1, 2, None, 4],</span>
<span class="sd">             &#39;b&#39;: [5.0, None, 7.0, 8.0]})</span>

<span class="sd">        df.flag_nulls()</span>
<span class="sd">        #  &#39;a&#39; | &#39;b&#39;  | &#39;null_flag&#39;</span>
<span class="sd">        #   1  | 5.0  |   0</span>
<span class="sd">        #   2  | NaN  |   1</span>
<span class="sd">        #  NaN | 7.0  |   1</span>
<span class="sd">        #   4  | 8.0  |   0</span>

<span class="sd">        jn.functions.flag_nulls(df)</span>
<span class="sd">        #  &#39;a&#39; | &#39;b&#39;  | &#39;null_flag&#39;</span>
<span class="sd">        #   1  | 5.0  |   0</span>
<span class="sd">        #   2  | NaN  |   1</span>
<span class="sd">        #  NaN | 7.0  |   1</span>
<span class="sd">        #   4  | 8.0  |   0</span>

<span class="sd">        df.flag_nulls(columns=[&#39;b&#39;])</span>
<span class="sd">        #  &#39;a&#39; | &#39;b&#39;  | &#39;null_flag&#39;</span>
<span class="sd">        #   1  | 5.0  |   0</span>
<span class="sd">        #   2  | NaN  |   1</span>
<span class="sd">        #  NaN | 7.0  |   0</span>
<span class="sd">        #   4  | 8.0  |   0</span>


<span class="sd">    :param df: Input Pandas dataframe.</span>
<span class="sd">    :param column_name: Name for the output column. Defaults to &#39;null_flag&#39;.</span>
<span class="sd">    :param columns: List of columns to look at for finding null values. If you</span>
<span class="sd">        only want to look at one column, you can simply give its name. If set</span>
<span class="sd">        to None (default), all DataFrame columns are used.</span>
<span class="sd">    :returns: Input dataframe with the null flag column.</span>
<span class="sd">    :raises ValueError: if ``column_name`` is already present in the</span>
<span class="sd">        DataFrame.</span>
<span class="sd">    :raises ValueError: if a column within ``columns`` is no present in</span>
<span class="sd">        the DataFrame.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Sort out columns input</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="c1"># catches other hashable types</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>

    <span class="c1"># Input sanitation checks</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="n">present</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># This algorithm works best for n_rows &gt;&gt; n_cols. See issue #501</span>
    <span class="n">null_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
        <span class="n">null_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">null_array</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]))</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">null_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">drop_constant_columns</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds and drops the constant columns from a Pandas data frame</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>
<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        data_dict = {</span>
<span class="sd">        &quot;a&quot;: [1, 1, 1] * 3,</span>
<span class="sd">        &quot;Bell__Chart&quot;: [1, 2, 3] * 3,</span>
<span class="sd">        &quot;decorated-elephant&quot;: [1, 1, 1] * 3,</span>
<span class="sd">        &quot;animals&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
<span class="sd">        &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3</span>
<span class="sd">        }</span>

<span class="sd">        df = pd.DataFrame(data_dict)</span>

<span class="sd">        df = jn.functions.drop_constant_columns(df)</span>

<span class="sd">    Method chaining usage example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = df.drop_constant_columns()</span>

<span class="sd">    :param df: Input Pandas dataframe</span>
<span class="sd">    :returns: The Pandas data frame with the constant columns dropped.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># :Example 1: Drop columns with a single value:</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#         import pandas as pd</span>
    <span class="c1">#         import janitor as jn</span>

    <span class="c1">#         data_dict = {</span>
    <span class="c1">#         &quot;a&quot;: [1, 1, 1] * 3,</span>
    <span class="c1">#         &quot;Bell&quot;: [1, 2, 3] * 3,</span>
    <span class="c1">#         &quot;decorated-elephant&quot;: [1, 1, 1] * 3,</span>
    <span class="c1">#         &quot;animals&quot;: [&quot;rabbit&quot;, &quot;leopard&quot;, &quot;lion&quot;] * 3,</span>
    <span class="c1">#         &quot;cities&quot;: [&quot;Cambridge&quot;, &quot;Shanghai&quot;, &quot;Basel&quot;] * 3</span>
    <span class="c1">#         }</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     df.drop_constant_columns()</span>

    <span class="c1"># .. code-block:: python</span>

    <span class="c1">#     Bell  animals cities</span>
    <span class="c1">#   0   1   rabbit  Cambridge</span>
    <span class="c1">#   1   2   leopard Shanghai</span>
    <span class="c1">#   2   3   lion    Basel</span>
    <span class="c1">#   3   1   rabbit  Cambridge</span>
    <span class="c1">#   4   2   leopard Shanghai</span>
    <span class="c1">#   5   3   lion    Basel</span>
    <span class="c1">#   6   1   rabbit  Cambridge</span>
    <span class="c1">#   7   2   leopard Shanghai</span>
    <span class="c1">#   8   3   lion    Basel</span>

    <span class="c1"># Find the constant columns</span>
    <span class="n">constant_columns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">constant_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

    <span class="c1"># Drop constant columns from df and return it</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">constant_columns</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="count_cumulative_unique"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.count_cumulative_unique.html#janitor.count_cumulative_unique">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">count_cumulative_unique</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">dest_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generates a running total of cumulative unique values in a given column.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = jn.functions.count_cumulative_unique(</span>
<span class="sd">            df=df,</span>
<span class="sd">            column_name=&#39;animals&#39;,</span>
<span class="sd">            dest_column_name=&#39;animals_unique_count&#39;,</span>
<span class="sd">            case_sensitive=True</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining usage example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = df.count_cumulative_unique(</span>
<span class="sd">            column_name=&#39;animals&#39;,</span>
<span class="sd">            dest_column_name=&#39;animals_unique_count&#39;,</span>
<span class="sd">            case_sensitive=True</span>
<span class="sd">        )</span>

<span class="sd">    A new column will be created containing a running</span>
<span class="sd">    count of unique values in the specified column.</span>
<span class="sd">    If `case_sensitive` is `True`, then the case of</span>
<span class="sd">    any letters will matter (i.e., &#39;a&#39; != &#39;A&#39;);</span>
<span class="sd">    otherwise, the case of any letters will not matter.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: Name of the column containing</span>
<span class="sd">        values from which a running count of unique values</span>
<span class="sd">        will be created.</span>
<span class="sd">    :param dest_column_name: The name of the new column containing the</span>
<span class="sd">        cumulative count of unique values that will be created.</span>
<span class="sd">    :param case_sensitive: Whether or not uppercase and lowercase letters</span>
<span class="sd">        will be considered equal (e.g., &#39;A&#39; != &#39;a&#39; if `True`).</span>

<span class="sd">    :returns: A pandas DataFrame with a new column containing a cumulative</span>
<span class="sd">        count of unique values from another column.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">case_sensitive</span><span class="p">:</span>
        <span class="c1"># Make it so that the the same uppercase and lowercase</span>
        <span class="c1"># letter are treated as one unique value</span>
        <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="n">dest_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span>
            <span class="n">df</span><span class="p">[[</span><span class="n">column_name</span><span class="p">]]</span>
            <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">dummyabcxyz</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">dummyabcxyz</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
        <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="toset"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.toset.html#janitor.toset">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_series_method</span>
<span class="k">def</span> <span class="nf">toset</span><span class="p">(</span><span class="n">series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return a set of the values.</span>

<span class="sd">    These are each a scalar type, which is a Python scalar</span>
<span class="sd">    (for str, int, float) or a pandas scalar</span>
<span class="sd">    (for Timestamp/Timedelta/Interval/Period)</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        series = pd.Series(...)</span>
<span class="sd">        s = jn.functions.toset(series=series)</span>

<span class="sd">    Method chaining usage example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        series = pd.Series(...)</span>
<span class="sd">        s = series.toset()</span>

<span class="sd">    :param series: A pandas series.</span>
<span class="sd">    :returns: A set of values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span></div>


<div class="viewcode-block" id="jitter"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.jitter.html#janitor.jitter">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">jitter</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">dest_column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span>
    <span class="n">clip</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Adds Gaussian noise (jitter) to the values of a column.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = jn.functions.jitter(</span>
<span class="sd">            df=df,</span>
<span class="sd">            column_name=&#39;values&#39;,</span>
<span class="sd">            dest_column_name=&#39;values_jitter&#39;,</span>
<span class="sd">            scale=1.0,</span>
<span class="sd">            clip=None,</span>
<span class="sd">            random_state=None,</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining usage example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = df.jitter(</span>
<span class="sd">            column_name=&#39;values&#39;,</span>
<span class="sd">            dest_column_name=&#39;values_jitter&#39;,</span>
<span class="sd">            scale=1.0,</span>
<span class="sd">            clip=None,</span>
<span class="sd">            random_state=None,</span>
<span class="sd">        )</span>

<span class="sd">    A new column will be created containing the values of the original column</span>
<span class="sd">    with Gaussian noise added.</span>
<span class="sd">    For each value in the column, a Gaussian distribution is created</span>
<span class="sd">    having a location (mean) equal to the value</span>
<span class="sd">    and a scale (standard deviation) equal to `scale`.</span>
<span class="sd">    A random value is then sampled from this distribution,</span>
<span class="sd">    which is the jittered value.</span>
<span class="sd">    If a tuple is supplied for `clip`,</span>
<span class="sd">    then any values of the new column less than `clip[0]`</span>
<span class="sd">    will be set to `clip[0]`,</span>
<span class="sd">    and any values greater than `clip[1]` will be set to `clip[1]`.</span>
<span class="sd">    Additionally, if a numeric value is supplied for `random_state`,</span>
<span class="sd">    this value will be used to set the random seed used for sampling.</span>
<span class="sd">    NaN values are ignored in this method.</span>

<span class="sd">    This method mutates the original DataFrame.</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: Name of the column containing</span>
<span class="sd">        values to add Gaussian jitter to.</span>
<span class="sd">    :param dest_column_name: The name of the new column containing the</span>
<span class="sd">        jittered values that will be created.</span>
<span class="sd">    :param scale: A positive value multiplied by the original</span>
<span class="sd">        column value to determine the scale (standard deviation) of the</span>
<span class="sd">        Gaussian distribution to sample from. (A value of zero results in</span>
<span class="sd">        no jittering.)</span>
<span class="sd">    :param clip: An iterable of two values (minimum and maximum) to clip</span>
<span class="sd">        the jittered values to, default to None.</span>
<span class="sd">    :param random_state: An integer or 1-d array value used to set the random</span>
<span class="sd">        seed, default to None.</span>

<span class="sd">    :returns: A pandas DataFrame with a new column containing Gaussian-</span>
<span class="sd">        jittered values from another column.</span>
<span class="sd">    :raises TypeError: if ``column_name`` is not numeric.</span>
<span class="sd">    :raises ValueError: if ``scale`` is not a numerical value</span>
<span class="sd">        greater than ``0``.</span>
<span class="sd">    :raises ValueError: if ``clip`` is not an iterable of length ``2``.</span>
<span class="sd">    :raises ValueError: if ``clip[0]`` is not less than ``clip[1]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check types</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>

    <span class="c1"># Check that `column_name` is a numeric column</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2"> must be a numeric column.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`scale` must be a numeric value greater than 0.&quot;</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
        <span class="c1"># Ensure `clip` has length 2</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clip</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`clip` must be an iterable of length 2.&quot;</span><span class="p">)</span>
        <span class="c1"># Ensure the values in `clip` are ordered as min, max</span>
        <span class="k">if</span> <span class="n">clip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">clip</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`clip[0]` must be less than `clip[1]`.&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">clip</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="n">dest_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="sort_naturally"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.sort_naturally.html#janitor.sort_naturally">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">sort_naturally</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">natsorted_kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Sort a DataFrame by a column using &quot;natural&quot; sorting.</span>

<span class="sd">    Natural sorting is distinct from</span>
<span class="sd">    the default lexiographical sorting provided by ``pandas``.</span>
<span class="sd">    For example, given the following list of items:</span>

<span class="sd">        [&quot;A1&quot;, &quot;A11&quot;, &quot;A3&quot;, &quot;A2&quot;, &quot;A10&quot;]</span>

<span class="sd">    lexicographical sorting would give us:</span>


<span class="sd">        [&quot;A1&quot;, &quot;A10&quot;, &quot;A11&quot;, &quot;A2&quot;, &quot;A3&quot;]</span>

<span class="sd">    By contrast, &quot;natural&quot; sorting would give us:</span>

<span class="sd">        [&quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A10&quot;, &quot;A11&quot;]</span>

<span class="sd">    This function thus provides &quot;natural&quot; sorting</span>
<span class="sd">    on a single column of a dataframe.</span>

<span class="sd">    To accomplish this, we do a natural sort</span>
<span class="sd">    on the unique values that are present in the dataframe.</span>
<span class="sd">    Then, we reconstitute the entire dataframe</span>
<span class="sd">    in the naturally sorted order.</span>

<span class="sd">    Natural sorting is provided by the Python package natsort_.</span>

<span class="sd">    .. _natsort: https://natsort.readthedocs.io/en/master/index.html</span>

<span class="sd">    All keyword arguments to ``natsort`` should be provided</span>
<span class="sd">    after the column name to sort by is provided.</span>
<span class="sd">    They are passed through to the ``natsorted`` function.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = jn.sort_naturally(</span>
<span class="sd">            df=df,</span>
<span class="sd">            column_name=&#39;alphanumeric_column&#39;,</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = df.sort_naturally(</span>
<span class="sd">            column_name=&#39;alphanumeric_column&#39;,</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas DataFrame.</span>
<span class="sd">    :param column_name: The column on which natural sorting should take place.</span>
<span class="sd">    :param natsorted_kwargs: Keyword arguments to be passed</span>
<span class="sd">        to natsort&#39;s ``natsorted`` function.</span>
<span class="sd">    :returns: A sorted pandas DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_order</span> <span class="o">=</span> <span class="n">index_natsorted</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">],</span> <span class="o">**</span><span class="n">natsorted_kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">new_order</span><span class="p">,</span> <span class="p">:]</span></div>


<span class="k">def</span> <span class="nf">sort_column_value_order</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">column_value_order</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function adds precedence to certain values in a specified column, then</span>
<span class="sd">    sorts based on that column and any other specified columns.</span>

<span class="sd">    Example:</span>
<span class="sd">                    SalesMonth	Company2	Company3</span>
<span class="sd">        Company1</span>
<span class="sd">        150.0	    Jan	        180.0	    400.0</span>
<span class="sd">        200.0	    Feb	        250.0	    500.0</span>
<span class="sd">        200.0	    Feb	        250.0	    500.0</span>
<span class="sd">        300.0	    Mar	        NaN	        600.0</span>
<span class="sd">        400.0	    April	    500.0	    675.0</span>

<span class="sd">        Given the current DataFrame, we want to order the sales month in desc</span>
<span class="sd">        order. To achieve this we would assign the later months with smaller</span>
<span class="sd">        values with the latest month, such as April with the precedence of 0.</span>

<span class="sd">        df = sort_column_value_order(</span>
<span class="sd">        df,</span>
<span class="sd">        &#39;SalesMonth&#39;,</span>
<span class="sd">        {&#39;April&#39;:1,&#39;Mar&#39;:2,&#39;Feb&#39;:3,&#39;Jan&#39;:4}</span>
<span class="sd">        )</span>

<span class="sd">        The returned DataFrame will look as follows.</span>

<span class="sd">                    SalesMonth	Company2	Company3</span>
<span class="sd">        Company1</span>
<span class="sd">        400.0	    April	    500.0	    675.0</span>
<span class="sd">        300.0	    Mar	        NaN	        600.0</span>
<span class="sd">        200.0	    Feb	        250.0	    500.0</span>
<span class="sd">        200.0	    Feb	        250.0	    500.0</span>
<span class="sd">        150.0	    Jan	        180.0	    400.0</span>

<span class="sd">    :param df: This is our DataFrame that we are manipulating</span>
<span class="sd">    :param column: This is a column name as a string we are using to specify</span>
<span class="sd">        which column to sort by</span>
<span class="sd">    :param column_value_order: This is a dictionary of values that will</span>
<span class="sd">        represent precedence of the values in the specified column</span>
<span class="sd">    :param columns: This is a list of additional columns that we can sort by</span>
<span class="sd">    :raises ValueError: raises error if chosen Column Name is not in</span>
<span class="sd">        Dataframe, or if column_value_order dictionary is empty.</span>
<span class="sd">    :return: This function returns a Pandas DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_value_order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;cond_order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">column_value_order</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;cond_order&quot;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">new_df</span><span class="p">[</span><span class="s2">&quot;cond_order&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">columns</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;cond_order&quot;</span><span class="p">])</span>
                <span class="k">del</span> <span class="n">new_df</span><span class="p">[</span><span class="s2">&quot;cond_order&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">new_df</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Column Name not in DataFrame&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;column_value_order dictionary cannot be empty&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="expand_grid"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.expand_grid.html#janitor.expand_grid">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">expand_grid</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">df_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">others</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a dataframe from a cartesian combination of all inputs.</span>

<span class="sd">    This works with a dictionary of name value pairs.</span>

<span class="sd">    It is also not restricted to dataframes;</span>
<span class="sd">    it can work with any list-like structure</span>
<span class="sd">    that is 1 or 2 dimensional.</span>

<span class="sd">    If method-chaining to a dataframe,</span>
<span class="sd">    a key to represent the column name in the output must be provided.</span>


<span class="sd">    Data types are preserved in this function,</span>
<span class="sd">    including Pandas&#39; extension array dtypes.</span>

<span class="sd">    The output will always be a dataframe.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame({&quot;x&quot;:range(1,3), &quot;y&quot;:[2,1]})</span>
<span class="sd">        others = {&quot;z&quot; : range(1,4)}</span>

<span class="sd">        df.expand_grid(df_key=&quot;df&quot;,others=others)</span>

<span class="sd">        # df_x |   df_y |   z</span>
<span class="sd">        #    1 |      2 |   1</span>
<span class="sd">        #    1 |      2 |   2</span>
<span class="sd">        #    1 |      2 |   3</span>
<span class="sd">        #    2 |      1 |   1</span>
<span class="sd">        #    2 |      1 |   2</span>
<span class="sd">        #    2 |      1 |   3</span>

<span class="sd">        # create a dataframe from all combinations in a dictionary</span>
<span class="sd">        data = {&quot;x&quot;:range(1,4), &quot;y&quot;:[1,2]}</span>

<span class="sd">        jn.expand_grid(others=data)</span>

<span class="sd">        #  x |   y</span>
<span class="sd">        #  1 |   1</span>
<span class="sd">        #  1 |   2</span>
<span class="sd">        #  2 |   1</span>
<span class="sd">        #  2 |   2</span>
<span class="sd">        #  3 |   1</span>
<span class="sd">        #  3 |   2</span>

<span class="sd">    .. note:: If a MultiIndex DataFrame or Series is passed, the index/columns</span>
<span class="sd">        will be discarded, and a single indexed dataframe will be returned.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.expand_grid(df=df, df_key=&quot;...&quot;, others={...})</span>

<span class="sd">    Method-chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...).expand_grid(df_key=&quot;bla&quot;,others={...})</span>

<span class="sd">    Usage independent of a dataframe</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        from janitor import expand_grid</span>

<span class="sd">        df = expand_grid({&quot;x&quot;:range(1,4), &quot;y&quot;:[1,2]})</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param df_key: name of key for the dataframe.</span>
<span class="sd">        It becomes part of the column names of the dataframe.</span>
<span class="sd">    :param others: A dictionary that contains the data</span>
<span class="sd">        to be combined with the dataframe.</span>
<span class="sd">        If no dataframe exists, all inputs</span>
<span class="sd">        in others will be combined to create a dataframe.</span>
<span class="sd">    :returns: A pandas dataframe of all combinations of name value pairs.</span>
<span class="sd">    :raises TypeError: if `others` is not a dictionary</span>
<span class="sd">    :raises KeyError: if there is a dataframe and no key is provided.</span>
<span class="sd">    :raises ValueError: if `others` is empty.</span>

<span class="sd">    .. # noqa: DAR402</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;others&quot;</span><span class="p">,</span> <span class="n">others</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">])</span>

    <span class="c1"># if there is a dataframe, for the method chaining,</span>
    <span class="c1"># it must have a key, to create a name value pair</span>
    <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">df_key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Using `expand_grid` as part of a DataFrame method chain</span>
<span class="sd">                requires that a string `df_key` be passed in.</span>
<span class="sd">                &quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;df_key&quot;</span><span class="p">,</span> <span class="n">df_key</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>

        <span class="n">others</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="n">df_key</span><span class="p">:</span> <span class="n">df</span><span class="p">},</span> <span class="o">**</span><span class="n">others</span><span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">others</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;`others` cannot be empty.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_computations_expand_grid</span><span class="p">(</span><span class="n">others</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_text"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.process_text.html#janitor.process_text">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="nd">@deprecated_alias</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s2">&quot;column_name&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">process_text</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">new_column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">merge_frame</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">string_function</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a Pandas string method to an existing column and return a dataframe.</span>

<span class="sd">    This function aims to make string cleaning easy, while chaining,</span>
<span class="sd">    by simply passing the string method name to the ``process_text`` function.</span>
<span class="sd">    This modifies an existing column and can also be used to create a new</span>
<span class="sd">    column.</span>

<span class="sd">    .. note:: In versions &lt; 0.20.11, this function did not support the</span>
<span class="sd">        creation of new columns.</span>

<span class="sd">    A list of all the string methods in Pandas can be accessed `here</span>
<span class="sd">    &lt;https://pandas.pydata.org/docs/user_guide/text.html#method-summary&gt;`__.</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame({&quot;text&quot; : [&quot;Ragnar&quot;,</span>
<span class="sd">                                    &quot;sammywemmy&quot;,</span>
<span class="sd">                                    &quot;ginger&quot;],</span>
<span class="sd">                           &quot;code&quot; : [1, 2, 3]})</span>

<span class="sd">        df.process_text(column_name = &quot;text&quot;,</span>
<span class="sd">                        string_function = &quot;lower&quot;)</span>

<span class="sd">          text          code</span>
<span class="sd">        0 ragnar         1</span>
<span class="sd">        1 sammywemmy     2</span>
<span class="sd">        2 ginger         3</span>

<span class="sd">    For string methods with parameters, simply pass the keyword arguments::</span>

<span class="sd">        df.process_text(</span>
<span class="sd">            column_name = &quot;text&quot;,</span>
<span class="sd">            string_function = &quot;extract&quot;,</span>
<span class="sd">            pat = r&quot;(ag)&quot;,</span>
<span class="sd">            expand = False,</span>
<span class="sd">            flags = re.IGNORECASE</span>
<span class="sd">            )</span>

<span class="sd">          text     code</span>
<span class="sd">        0 ag        1</span>
<span class="sd">        1 NaN       2</span>
<span class="sd">        2 NaN       3</span>

<span class="sd">    A new column can be created, leaving the existing column unmodified::</span>

<span class="sd">        df.process_text(</span>
<span class="sd">            column_name = &quot;text&quot;,</span>
<span class="sd">            new_column_names = &quot;new_text&quot;,</span>
<span class="sd">            string_function = &quot;extract&quot;,</span>
<span class="sd">            pat = r&quot;(ag)&quot;,</span>
<span class="sd">            flags = re.IGNORECASE</span>
<span class="sd">            )</span>

<span class="sd">          text           code     new_text</span>
<span class="sd">        0 Ragnar          1          ag</span>
<span class="sd">        1 sammywemmy      2          NaN</span>
<span class="sd">        2 ginger          3          NaN</span>


<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.process_text(</span>
<span class="sd">            df = df,</span>
<span class="sd">            column_name,</span>
<span class="sd">            new_column_names = None/string/list_of_strings,</span>
<span class="sd">            merge_frame = True/False,</span>
<span class="sd">            string_function = &quot;string_func_name_here&quot;,</span>
<span class="sd">            kwargs</span>
<span class="sd">            )</span>

<span class="sd">    Method-chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .process_text(</span>
<span class="sd">                column_name,</span>
<span class="sd">                new_column_names = None/string/list_of_strings,</span>
<span class="sd">                merge_frame = True/False</span>
<span class="sd">                string_function = &quot;string_func_name_here&quot;,</span>
<span class="sd">                kwargs</span>
<span class="sd">                )</span>
<span class="sd">        )</span>


<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param column_name: String column to be operated on.</span>
<span class="sd">    :param new_column_names: Name(s) to assign to the new column(s) created</span>
<span class="sd">        from the text processing. `new_column_names` can be a string, if</span>
<span class="sd">        the result of the text processing is a Series or string; if the</span>
<span class="sd">        result of the text processing is a dataframe, then `new_column_names`</span>
<span class="sd">        is treated as a prefix for each of the columns in the new dataframe.</span>
<span class="sd">        `new_column_names` can also be a list of strings to act as new</span>
<span class="sd">        column names for the new dataframe. The existing `column_name`</span>
<span class="sd">        stays unmodified if `new_column_names` is not None.</span>
<span class="sd">    :param merge_frame: This comes into play if the result of the text</span>
<span class="sd">        processing is a dataframe. If `True`, the resulting dataframe</span>
<span class="sd">        will be merged with the original dataframe, else the resulting</span>
<span class="sd">        dataframe, not the original dataframe, will be returned.</span>
<span class="sd">    :param string_function: Pandas string method to be applied.</span>
<span class="sd">    :param kwargs: Keyword arguments for parameters of the `string_function`.</span>
<span class="sd">    :returns: A pandas dataframe with modified column(s).</span>
<span class="sd">    :raises KeyError: if ``string_function`` is not a Pandas string method.</span>
<span class="sd">    :raises TypeError: if wrong ``arg`` or ``kwarg`` is supplied.</span>
<span class="sd">    :raises ValueError: if `column_name` not found in dataframe.</span>
<span class="sd">    :raises ValueError: if `new_column_names` is not None and is found in</span>
<span class="sd">        dataframe.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;column_name&quot;</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">])</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="n">column_name</span><span class="p">])</span>

    <span class="c1"># new_column_names should not already exist in the dataframe</span>
    <span class="k">if</span> <span class="n">new_column_names</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;new_column_names&quot;</span><span class="p">,</span> <span class="n">new_column_names</span><span class="p">,</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_column_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="n">new_column_names</span><span class="p">],</span> <span class="n">present</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">new_column_names</span><span class="p">,</span> <span class="n">present</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">merge_frame</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;merge_frame&quot;</span><span class="p">,</span> <span class="n">merge_frame</span><span class="p">,</span> <span class="p">[</span><span class="nb">bool</span><span class="p">])</span>

    <span class="n">pandas_string_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">string_function</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">if</span> <span class="n">string_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pandas_string_methods</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">string_function</span><span class="si">}</span><span class="s2"> is not a Pandas string method.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">string_function</span> <span class="o">==</span> <span class="s2">&quot;extractall&quot;</span> <span class="ow">and</span> <span class="n">merge_frame</span><span class="p">:</span>
        <span class="c1"># create unique indices</span>
        <span class="c1"># comes in handy for executing joins if there are</span>
        <span class="c1"># duplicated indices in the original dataframe</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)),</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># extra_index_line</span>

    <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="p">,</span> <span class="n">string_function</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># TODO: Support for str.cat with `join` parameter</span>
    <span class="c1"># need a robust way to handle the results</span>
    <span class="c1"># if there is a `join` parameter, as this could create more</span>
    <span class="c1"># or less rows with varying indices or even duplicate indices</span>

    <span class="k">return</span> <span class="n">_process_text</span><span class="p">(</span>
        <span class="n">result</span><span class="p">,</span>
        <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
        <span class="n">column_name</span><span class="o">=</span><span class="n">column_name</span><span class="p">,</span>
        <span class="n">new_column_names</span><span class="o">=</span><span class="n">new_column_names</span><span class="p">,</span>
        <span class="n">merge_frame</span><span class="o">=</span><span class="n">merge_frame</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fill_direction"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.fill_direction.html#janitor.fill_direction">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">fill_direction</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">directions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provide a method-chainable function for filling missing values</span>
<span class="sd">    in selected columns.</span>

<span class="sd">    Missing values are filled using the next or previous entry.</span>
<span class="sd">    The columns are paired with the directions in a dictionary.</span>
<span class="sd">    It is a wrapper for ``pd.Series.ffill`` and ``pd.Series.bfill``.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import numpy as np</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame({&quot;text&quot;: [&quot;ragnar&quot;, np.nan, &quot;sammywemmy&quot;,</span>
<span class="sd">                                    np.nan, &quot;ginger&quot;],</span>
<span class="sd">                           &quot;code&quot; : [np.nan, 2, 3, np.nan, 5]})</span>

<span class="sd">        df</span>

<span class="sd">           text          code</span>
<span class="sd">        0 ragnar         NaN</span>
<span class="sd">        1 NaN            2.0</span>
<span class="sd">        2 sammywemmy     3.0</span>
<span class="sd">        3 NaN            NaN</span>
<span class="sd">        4 ginger         5.0</span>



<span class="sd">    Fill on a single column::</span>

<span class="sd">        df.fill_direction({&quot;text&quot; : &quot;up&quot;})</span>

<span class="sd">           text          code</span>
<span class="sd">        0 ragnar         NaN</span>
<span class="sd">        1 sammywemmy     2.0</span>
<span class="sd">        2 sammywemmy     3.0</span>
<span class="sd">        3 ginger         NaN</span>
<span class="sd">        4 ginger         5.0</span>

<span class="sd">    Fill on multiple columns::</span>

<span class="sd">        df.fill_direction({&quot;text&quot; : &quot;down&quot;, &quot;code&quot; : &quot;down&quot;})</span>

<span class="sd">           text          code</span>
<span class="sd">        0 ragnar         NaN</span>
<span class="sd">        1 ragnar         2.0</span>
<span class="sd">        2 sammywemmy     3.0</span>
<span class="sd">        3 sammywemmy     3.0</span>
<span class="sd">        4 ginger         5.0</span>

<span class="sd">    Fill multiple columns in different directions::</span>

<span class="sd">        df.fill_direction({&quot;text&quot; : &quot;up&quot;, &quot;code&quot; : &quot;down&quot;})</span>

<span class="sd">           text          code</span>
<span class="sd">        0 ragnar         NaN</span>
<span class="sd">        1 sammywemmy     2.0</span>
<span class="sd">        2 sammywemmy     3.0</span>
<span class="sd">        3 ginger         3.0</span>
<span class="sd">        4 ginger         5.0</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.fill_direction(</span>
<span class="sd">            df = df,</span>
<span class="sd">            directions = {column_1 : direction_1,</span>
<span class="sd">                          column_2 : direction_2,</span>
<span class="sd">                          ...},</span>
<span class="sd">            limit = None # limit must be None or greater than 0</span>
<span class="sd">            )</span>

<span class="sd">    Method-chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .fill_direction(</span>
<span class="sd">            directions = {column_1 : direction_1,</span>
<span class="sd">                          column_2 : direction_2,</span>
<span class="sd">                          ...},</span>
<span class="sd">            limit = None # limit must be None or greater than 0</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param directions: Key - value pairs of columns and directions. Directions</span>
<span class="sd">        can be either `down` (default), `up`, `updown` (fill up then down) and</span>
<span class="sd">        `downup` (fill down then up).</span>
<span class="sd">    :param limit: number of consecutive null values to forward/backward fill.</span>
<span class="sd">        Value must `None` or greater than 0.</span>
<span class="sd">    :returns: A pandas dataframe with modified column(s).</span>
<span class="sd">    :raises ValueError: if column supplied is not in the dataframe.</span>
<span class="sd">    :raises ValueError: if direction supplied is not one of `down`, `up`,</span>
<span class="sd">        `updown`, or `downup`.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">directions</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;directions&quot;</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">check</span><span class="p">(</span><span class="s2">&quot;limit&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">])</span>
        <span class="c1"># pandas raises error if limit is not greater than zero</span>
        <span class="c1"># so no need for a check on pyjanitor&#39;s end</span>

    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">directions</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="s2">&quot;updown&quot;</span><span class="p">,</span> <span class="s2">&quot;downup&quot;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                The direction should be a string and should be one of</span>
<span class="sd">                `up`, `down`, `updown`, or `downup`.</span>
<span class="sd">                &quot;&quot;&quot;</span>
            <span class="p">)</span>

    <span class="c1"># TODO: option to specify limit per column; current implementation</span>
    <span class="c1"># is one `limit` for all the columns. Might need refactoring, or an</span>
    <span class="c1"># API change.</span>
    <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;up&quot;</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;down&quot;</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;updown&quot;</span><span class="p">:</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># downup</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="groupby_topk"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.groupby_topk.html#janitor.groupby_topk">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">groupby_topk</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">groupby_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">sort_column_name</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sort_values_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return top `k` rows from a groupby of a set of columns.</span>

<span class="sd">    Returns a dataframe that has the top `k` values grouped by `groupby_column_name`</span>
<span class="sd">    and sorted by `sort_column_name`.</span>
<span class="sd">    Additional parameters to the sorting (such as ascending=True)</span>
<span class="sd">    can be passed using `sort_values_kwargs`.</span>

<span class="sd">    List of all sort_values() parameters can be found here_.</span>

<span class="sd">    .. _here: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html</span>


<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame({&#39;age&#39; : [20, 22, 24, 23, 21, 22],</span>
<span class="sd">                           &#39;ID&#39; : [1,2,3,4,5,6],</span>
<span class="sd">                           &#39;result&#39; : [&quot;pass&quot;, &quot;fail&quot;, &quot;pass&quot;,</span>
<span class="sd">                                       &quot;pass&quot;, &quot;fail&quot;, &quot;pass&quot;]})</span>

<span class="sd">        # Ascending top 3:</span>
<span class="sd">        df.groupby_topk(&#39;result&#39;, &#39;age&#39;, 3)</span>
<span class="sd">        #       age  ID  result</span>
<span class="sd">        #result</span>
<span class="sd">        #fail   21   5   fail</span>
<span class="sd">        #       22   2   fail</span>
<span class="sd">        #pass   20   1   pass</span>
<span class="sd">        #       22   6   pass</span>
<span class="sd">        #       23   4   pass</span>

<span class="sd">        #Descending top 2:</span>
<span class="sd">        df.groupby_topk(&#39;result&#39;, &#39;age&#39;, 2, {&#39;ascending&#39;:False})</span>
<span class="sd">        #       age  ID result</span>
<span class="sd">        #result</span>
<span class="sd">        #fail   22   2   fail</span>
<span class="sd">        #       21   5   fail</span>
<span class="sd">        #pass   24   3   pass</span>
<span class="sd">        #       23   4   pass</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.groupby_topk(</span>
<span class="sd">            df = df,</span>
<span class="sd">            groupby_column_name = &#39;groupby_column&#39;,</span>
<span class="sd">            sort_column_name = &#39;sort_column&#39;,</span>
<span class="sd">            k = 5</span>
<span class="sd">            )</span>

<span class="sd">    Method-chaining usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .groupby_topk(</span>
<span class="sd">            df = df,</span>
<span class="sd">            groupby_column_name = &#39;groupby_column&#39;,</span>
<span class="sd">            sort_column_name = &#39;sort_column&#39;,</span>
<span class="sd">            k = 5</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param groupby_column_name: Column name to group input dataframe `df` by.</span>
<span class="sd">    :param sort_column_name: Name of the column to sort along the</span>
<span class="sd">        input dataframe `df`.</span>
<span class="sd">    :param k: Number of top rows to return from each group after sorting.</span>
<span class="sd">    :param sort_values_kwargs: Arguments to be passed to sort_values function.</span>
<span class="sd">    :returns: A pandas dataframe with top `k` rows that are grouped by</span>
<span class="sd">        `groupby_column_name` column with each group sorted along the</span>
<span class="sd">        column `sort_column_name`.</span>
<span class="sd">    :raises ValueError: if `k` is less than 1.</span>
<span class="sd">    :raises ValueError: if `groupby_column_name` not in dataframe `df`.</span>
<span class="sd">    :raises ValueError: if `sort_column_name` not in dataframe `df`.</span>
<span class="sd">    :raises KeyError: if `inplace:True` is present in `sort_values_kwargs`.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="c1"># Convert the default sort_values_kwargs from None to empty Dict</span>
    <span class="n">sort_values_kwargs</span> <span class="o">=</span> <span class="n">sort_values_kwargs</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="c1"># Check if groupby_column_name and sort_column_name exists in the dataframe</span>
    <span class="n">check_column</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="n">groupby_column_name</span><span class="p">,</span> <span class="n">sort_column_name</span><span class="p">])</span>

    <span class="c1"># Check if k is greater than 0.</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Numbers of rows per group to be returned must be greater than 0.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Check if inplace:True in sort values kwargs because it returns None</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="s2">&quot;inplace&quot;</span> <span class="ow">in</span> <span class="n">sort_values_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="ow">and</span> <span class="n">sort_values_kwargs</span><span class="p">[</span><span class="s2">&quot;inplace&quot;</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Cannot use `inplace=True` in `sort_values_kwargs`.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">groupby_column_name</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">sort_column_name</span><span class="p">,</span> <span class="o">**</span><span class="n">sort_values_kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="complete"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.complete.html#janitor.complete">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">complete</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">columns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">by</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function turns implicit missing values into explicit missing values.</span>

<span class="sd">    It is modeled after tidyr&#39;s `complete` function, and is a wrapper around</span>
<span class="sd">    `expand_grid`, `pd.DataFrame.reindex`, `pd.DataFrame.join`</span>
<span class="sd">    and `pd.DataFrame.fillna`.</span>

<span class="sd">    Combinations of column names or a list/tuple of column names, or even a</span>
<span class="sd">    dictionary of column names and new values are possible.</span>

<span class="sd">    It can also handle duplicated data.</span>

<span class="sd">    `Source &lt;https://tidyr.tidyverse.org/reference/complete.html#examples&gt;`_</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">            group	item_id	    item_name	value1	value2</span>
<span class="sd">        0	1	    1	        a	1	4</span>
<span class="sd">        1	2	    2	        b	2	5</span>
<span class="sd">        2	1	    2	        b	3	6</span>

<span class="sd">    To find all the unique combinations of `group`, `item_id`, and `item_name`,</span>
<span class="sd">    including combinations not present in the data, each variable should be</span>
<span class="sd">    passed in a list to the `columns` parameter::</span>

<span class="sd">        df.complete(columns = [&#39;group&#39;, &#39;item_id&#39;, &#39;item_name&#39;])</span>

<span class="sd">              group	item_id	    item_name	value1	value2</span>
<span class="sd">        0	1	    1	        a	1.0	4.0</span>
<span class="sd">        1	1	    1	        b	NaN	NaN</span>
<span class="sd">        2	1	    2	        a	NaN	NaN</span>
<span class="sd">        3	1	    2	        b	3.0	6.0</span>
<span class="sd">        4	2	    1	        a	NaN	NaN</span>
<span class="sd">        5	2	    1	        b	NaN	NaN</span>
<span class="sd">        6	2	    2	        a	NaN	NaN</span>
<span class="sd">        7	2	    2	        b	2.0	5.0</span>

<span class="sd">    To expose just the missing values based only on the existing data,</span>
<span class="sd">    `item_id` and `item_name` can be wrapped in a tuple, while `group`</span>
<span class="sd">    is passed in as a separate variable::</span>

<span class="sd">        df.complete(columns = [&quot;group&quot;, (&quot;item_id&quot;, &quot;item_name&quot;)])</span>
<span class="sd">            group	item_id	    item_name	value1	   value2</span>
<span class="sd">        0	1	    1	        a	  1.0	    4.0</span>
<span class="sd">        1	1	    2	        b	  3.0	    6.0</span>
<span class="sd">        2	2	    1	        a	  NaN 	    NaN</span>
<span class="sd">        3	2	    2	        b	  2.0	    5.0</span>

<span class="sd">    Let&#39;s look at another example:</span>

<span class="sd">    `Source Data &lt;http://imachordata.com/2016/02/05/you-complete-me/&gt;`_</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">            Year      Taxon         Abundance</span>
<span class="sd">        0   1999    Saccharina         4</span>
<span class="sd">        1   2000    Saccharina         5</span>
<span class="sd">        2   2004    Saccharina         2</span>
<span class="sd">        3   1999     Agarum            1</span>
<span class="sd">        4   2004     Agarum            8</span>

<span class="sd">    Note that Year 2000 and Agarum pairing is missing. Let&#39;s make it</span>
<span class="sd">    explicit::</span>

<span class="sd">        df.complete(columns = [&#39;Year&#39;, &#39;Taxon&#39;])</span>

<span class="sd">           Year      Taxon     Abundance</span>
<span class="sd">        0  1999     Agarum         1.0</span>
<span class="sd">        1  1999     Saccharina     4.0</span>
<span class="sd">        2  2000     Agarum         NaN</span>
<span class="sd">        3  2000     Saccharina     5.0</span>
<span class="sd">        4  2004     Agarum         8.0</span>
<span class="sd">        5  2004     Saccharina     2.0</span>

<span class="sd">    The null value can be replaced with the Pandas `fillna` argument::</span>

<span class="sd">        df.complete(columns = [&#39;Year&#39;, &#39;Taxon&#39;]).fillna(0)</span>

<span class="sd">           Year      Taxon     Abundance</span>
<span class="sd">        0  1999     Agarum         1.0</span>
<span class="sd">        1  1999     Saccharina     4.0</span>
<span class="sd">        2  2000     Agarum         0.0</span>
<span class="sd">        3  2000     Saccharina     5.0</span>
<span class="sd">        4  2004     Agarum         8.0</span>
<span class="sd">        5  2004     Saccharina     2.0</span>

<span class="sd">    What if we wanted the explicit missing values for all the years from</span>
<span class="sd">    1999 to 2004? Easy - simply pass a dictionary pairing the column name</span>
<span class="sd">    with the new values::</span>

<span class="sd">        new_year_values = lambda year: range(year.min(), year.max() + 1)</span>

<span class="sd">        df.complete(columns = [{&quot;Year&quot;: new_year_values}, &quot;Taxon&quot;])</span>

<span class="sd">            Year       Taxon  Abundance</span>
<span class="sd">        0   1999      Agarum        1.0</span>
<span class="sd">        1   1999  Saccharina        4.0</span>
<span class="sd">        2   2000      Agarum        NaN</span>
<span class="sd">        3   2000  Saccharina        5.0</span>
<span class="sd">        4   2001      Agarum        NaN</span>
<span class="sd">        5   2001  Saccharina        NaN</span>
<span class="sd">        6   2002      Agarum        NaN</span>
<span class="sd">        7   2002  Saccharina        NaN</span>
<span class="sd">        8   2003      Agarum        NaN</span>
<span class="sd">        9   2003  Saccharina        NaN</span>
<span class="sd">        10  2004      Agarum        8.0</span>
<span class="sd">        11  2004  Saccharina        2.0</span>

<span class="sd">    It is also possible to expose missing values within a groupby,</span>
<span class="sd">    by using the `by` parameter::</span>

<span class="sd">          state  year  value</span>
<span class="sd">        0    CA  2010      1</span>
<span class="sd">        1    CA  2013      3</span>
<span class="sd">        2    HI  2010      1</span>
<span class="sd">        3    HI  2012      2</span>
<span class="sd">        4    HI  2016      3</span>
<span class="sd">        5    NY  2009      2</span>
<span class="sd">        6    NY  2013      5</span>

<span class="sd">    Let&#39;s get all the missing years per state::</span>

<span class="sd">        df.complete(</span>

<span class="sd">            columns = [{&#39;year&#39;: new_year_values}],</span>
<span class="sd">            by=&#39;state&#39;</span>
<span class="sd">        )</span>

<span class="sd">            state  year  value</span>
<span class="sd">        0     CA  2010    1.0</span>
<span class="sd">        1     CA  2011    NaN</span>
<span class="sd">        2     CA  2012    NaN</span>
<span class="sd">        3     CA  2013    3.0</span>
<span class="sd">        4     HI  2010    1.0</span>
<span class="sd">        5     HI  2011    NaN</span>
<span class="sd">        6     HI  2012    2.0</span>
<span class="sd">        7     HI  2013    NaN</span>
<span class="sd">        8     HI  2014    NaN</span>
<span class="sd">        9     HI  2015    NaN</span>
<span class="sd">        10    HI  2016    3.0</span>
<span class="sd">        11    NY  2009    2.0</span>
<span class="sd">        12    NY  2010    NaN</span>
<span class="sd">        13    NY  2011    NaN</span>
<span class="sd">        14    NY  2012    NaN</span>
<span class="sd">        15    NY  2013    5.0</span>

<span class="sd">    .. note:: MultiIndex columns are not supported.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = jn.complete(</span>
<span class="sd">            df = df,</span>
<span class="sd">            columns= [</span>
<span class="sd">                column_label,</span>
<span class="sd">                (column1, column2, ...),</span>
<span class="sd">                {column1: new_values, ...}</span>
<span class="sd">            ],</span>
<span class="sd">            by = label/list_of_labels</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .complete(columns=[</span>
<span class="sd">                column_label,</span>
<span class="sd">                (column1, column2, ...),</span>
<span class="sd">                {column1: new_values, ...},</span>
<span class="sd">            ],</span>
<span class="sd">            by = label/list_of_labels</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param columns: This is a list containing the columns to be</span>
<span class="sd">        completed. It could be column labels (string type),</span>
<span class="sd">        a list/tuple of column labels, or a dictionary that pairs</span>
<span class="sd">        column labels with new values.</span>
<span class="sd">    :param by: label or list of labels to group by.</span>
<span class="sd">        The explicit missing values are returned per group.</span>
<span class="sd">    :returns: A pandas dataframe with modified column(s).</span>
<span class="sd">    :raises TypeError: if `columns` is not a list.</span>
<span class="sd">    :raises ValueError: if entry in `columns` is not a</span>
<span class="sd">        str/dict/list/tuple.</span>
<span class="sd">    :raises ValueError: if entry in `columns` is a dict/list/tuple</span>
<span class="sd">        and is empty.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">columns</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">_computations_complete</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">by</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="k">def</span> <span class="nf">patterns</span><span class="p">(</span><span class="n">regex_pattern</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Pattern</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function converts a string into a compiled regular expression;</span>
<span class="sd">    it can be used to select columns in the index or columns_names</span>
<span class="sd">    arguments of ``pivot_longer`` function.</span>

<span class="sd">    :param regex_pattern: string to be converted to compiled regular</span>
<span class="sd">        expression.</span>
<span class="sd">    :returns: A compile regular expression from provided</span>
<span class="sd">        ``regex_pattern``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">check</span><span class="p">(</span><span class="s2">&quot;regular expression&quot;</span><span class="p">,</span> <span class="n">regex_pattern</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex_pattern</span><span class="p">)</span>


<div class="viewcode-block" id="pivot_longer"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.pivot_longer.html#janitor.pivot_longer">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">pivot_longer</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">column_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span><span class="p">,</span>
    <span class="n">values_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
    <span class="n">column_level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_sep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_pattern</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sort_by_appearance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unpivots a DataFrame from &#39;wide&#39; to &#39;long&#39; format.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    It is a wrapper around `pd.melt` and is meant to serve as a single point</span>
<span class="sd">    for transformations that require `pd.melt` or `pd.wide_to_long`.</span>

<span class="sd">    It is modeled after the `pivot_longer` function in R&#39;s tidyr package, and</span>
<span class="sd">    offers more functionality and flexibility than `pd.wide_to_long`.</span>

<span class="sd">    This function is useful to massage a DataFrame into a format where</span>
<span class="sd">    one or more columns are considered measured variables, and all other</span>
<span class="sd">    columns are considered as identifier variables.</span>

<span class="sd">    All measured variables are “unpivoted” (and typically duplicated) along the</span>
<span class="sd">    row axis.</span>

<span class="sd">    See the `Example notebooks &lt;https://pyjanitor.readthedocs.io/notebooks/&gt;`_</span>
<span class="sd">    for a more in depth exploration of `pivot_longer`.</span>


<span class="sd">    Example 1: The following DataFrame contains heartrate data for patients</span>
<span class="sd">    treated with two different drugs, &#39;a&#39; and &#39;b&#39;.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">              name   a   b</span>
<span class="sd">        0   Wilbur  67  56</span>
<span class="sd">        1  Petunia  80  90</span>
<span class="sd">        2  Gregory  64  50</span>

<span class="sd">    The column names &#39;a&#39; and &#39;b&#39; are actually the names of a measured variable</span>
<span class="sd">    (i.e. the name of a drug), but the values are a different measured variable</span>
<span class="sd">    (heartrate). We would like to unpivot these &#39;a&#39; and &#39;b&#39; columns into a</span>
<span class="sd">    &#39;drug&#39; column and a &#39;heartrate&#39; column.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(</span>
<span class="sd">                  column_names = [&#39;a&#39;, &#39;b&#39;],</span>
<span class="sd">                  names_to = &#39;drug&#39;,</span>
<span class="sd">                  values_to = &#39;heartrate&#39;,</span>
<span class="sd">                  sort_by_appearance = True</span>
<span class="sd">                  )</span>
<span class="sd">            )</span>

<span class="sd">              name drug  heartrate</span>
<span class="sd">        0   Wilbur    a         67</span>
<span class="sd">        1   Wilbur    b         56</span>
<span class="sd">        2  Petunia    a         80</span>
<span class="sd">        3  Petunia    b         90</span>
<span class="sd">        4  Gregory    a         64</span>
<span class="sd">        5  Gregory    b         50</span>

<span class="sd">    Note how the data is stacked in order of first appearance. If, however,</span>
<span class="sd">    you do not care for order of appearance, and want to wring out some</span>
<span class="sd">    more performance, you can set `sort_by_appearance` to ``False`` (the</span>
<span class="sd">    default is ``False``).</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(</span>
<span class="sd">                  column_names = [&#39;a&#39;, &#39;b&#39;],</span>
<span class="sd">                  names_to = &#39;drug&#39;,</span>
<span class="sd">                  values_to = &#39;heartrate&#39;,</span>
<span class="sd">                  sort_by_appearance = False</span>
<span class="sd">                  )</span>
<span class="sd">            )</span>

<span class="sd">                name     drug  heartrate</span>
<span class="sd">        0	Wilbur	   a	67</span>
<span class="sd">        1	Petunia	   a	80</span>
<span class="sd">        2	Gregory    a	64</span>
<span class="sd">        3	Wilbur	   b	56</span>
<span class="sd">        4	Petunia	   b	90</span>
<span class="sd">        5	Gregory	   b	50</span>

<span class="sd">    You can set `ignore_index` to ``False``, if you wish to reuse the index</span>
<span class="sd">    from the source dataframe (the index will be repeated as many times as</span>
<span class="sd">    necessary):</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(</span>
<span class="sd">                  column_names = [&#39;a&#39;, &#39;b&#39;],</span>
<span class="sd">                  names_to = &#39;drug&#39;,</span>
<span class="sd">                  values_to = &#39;heartrate&#39;,</span>
<span class="sd">                  sort_by_appearance = False,</span>
<span class="sd">                  ignore_index = False</span>
<span class="sd">                  )</span>
<span class="sd">            )</span>

<span class="sd">                name     drug  heartrate</span>
<span class="sd">        0	Wilbur	   a	67</span>
<span class="sd">        1	Petunia	   a	80</span>
<span class="sd">        2	Gregory    a	64</span>
<span class="sd">        0	Wilbur	   b	56</span>
<span class="sd">        1	Petunia	   b	90</span>
<span class="sd">        2	Gregory	   b	50</span>

<span class="sd">    MultiIndex dataframes are unpivoted in the same form that you would</span>
<span class="sd">    expect from pandas&#39; `melt`:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">            A  B  C</span>
<span class="sd">            D  E  F</span>
<span class="sd">        0   a  1  2</span>
<span class="sd">        1   b  3  4</span>
<span class="sd">        2   c  5  6</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">               .pivot_longer(</span>
<span class="sd">                   index = [(&quot;A&quot;, &quot;D&quot;)],</span>
<span class="sd">                   names_to = [&quot;first&quot;, &quot;second&quot;]</span>
<span class="sd">                   )</span>
<span class="sd">            )</span>

<span class="sd">             (A, D)  first   second   value</span>
<span class="sd">        0	a	B	E	1</span>
<span class="sd">        1	b	B	E	3</span>
<span class="sd">        2	c	B	E	5</span>
<span class="sd">        3	a	C	F	2</span>
<span class="sd">        4	b	C	F	4</span>
<span class="sd">        5	c	C	F	6</span>

<span class="sd">    You can also unpivot on a specific level:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(</span>
<span class="sd">                  index = &quot;A&quot;,</span>
<span class="sd">                  names_to = &quot;first&quot;,</span>
<span class="sd">                  column_level = 0</span>
<span class="sd">                  )</span>
<span class="sd">            )</span>

<span class="sd">           A      first  value</span>
<span class="sd">        0  a        B      1</span>
<span class="sd">        1  b        B      3</span>
<span class="sd">        2  c        B      5</span>


<span class="sd">    Example 2: The dataframe below has year and month variables embedded within</span>
<span class="sd">    the column names.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">              col1	    2019-12	 2020-01	 2020-02</span>
<span class="sd">        0	a	   -1.085631	-1.506295	-2.426679</span>
<span class="sd">        1	b	    0.997345	-0.578600	-0.428913</span>
<span class="sd">        2	c	    0.282978	 1.651437	 1.265936</span>

<span class="sd">    Pivot_longer can conveniently reshape the dataframe into long format, with</span>
<span class="sd">    new columns for the year and month. You simply pass in the new column names</span>
<span class="sd">    to `names_to`, and pass the hyphen &#39;-&#39; to the `names_sep` argument.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(</span>
<span class="sd">                  index = &#39;col1&#39;,</span>
<span class="sd">                  names_to = (&#39;year&#39;, &#39;month&#39;),</span>
<span class="sd">                  names_sep = &#39;-&#39;,</span>
<span class="sd">                  sort_by_appearance = True</span>
<span class="sd">                  )</span>
<span class="sd">            )</span>

<span class="sd">           col1 year   month      value</span>
<span class="sd">        0    a  2019     12     -1.085631</span>
<span class="sd">        1    a  2020     01     -1.506295</span>
<span class="sd">        2    a  2020     02     -2.426679</span>
<span class="sd">        3    b  2019     12      0.997345</span>
<span class="sd">        4    b  2020     01     -0.578600</span>
<span class="sd">        5    b  2020     02     -0.428913</span>
<span class="sd">        6    c  2019     12      0.282978</span>
<span class="sd">        7    c  2020     01      1.651437</span>
<span class="sd">        8    c  2020     02      1.265936</span>

<span class="sd">    Example 3: The dataframe below has names embedded in it</span>
<span class="sd">    (‘measure1’, ‘measure2’) that we would love to reuse as column names.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">            treat1-measure1     treat1-measure2 treat2-measure1 treat2-measure2</span>
<span class="sd">        0                1              4                   2               5</span>
<span class="sd">        1                2              5                   3               4</span>

<span class="sd">    For this, we use the `.value` variable, which signals to `pivot_longer`</span>
<span class="sd">    to treat the part of the column names corresponding to `.value` as new</span>
<span class="sd">    column names. The `.value` variable is similar to `stubnames` in pandas&#39;</span>
<span class="sd">    ``wide_to_long`` function, but with more flexibility.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(</span>
<span class="sd">                  names_to = (&quot;group&quot;, &#39;.value&#39;),</span>
<span class="sd">                  names_sep = &#39;-&#39;,</span>
<span class="sd">                  sort_by_appearance = True</span>
<span class="sd">                  )</span>
<span class="sd">            )</span>

<span class="sd">            group  measure1  measure2</span>
<span class="sd">        0  treat1         1         4</span>
<span class="sd">        1  treat2         2         5</span>
<span class="sd">        2  treat1         2         5</span>
<span class="sd">        3  treat2         3         4</span>

<span class="sd">    Let&#39;s break down the `.value` idea. When `.value` is used, `pivot_longer`</span>
<span class="sd">    creates a pairing. In the example above, we get a pairing</span>
<span class="sd">    ``{&quot;group&quot;:[&quot;treat1&quot;, &quot;treat2&quot;], &quot;.value&quot;:[&quot;measure1&quot;, &quot;measure2&quot;]}``. All</span>
<span class="sd">    the values associated with `.value` become new column names, while those</span>
<span class="sd">    not associated with `.value`(`treat1` and `treat2`) become values in a</span>
<span class="sd">    new column `group`. `values_to` is overridden during this process.</span>

<span class="sd">    .. note:: The values not associated with &quot;.value&quot; (in the example above,</span>
<span class="sd">        this is the `group` column) are returned as object dtypes. You can</span>
<span class="sd">        change it to your preferred dtype using pandas&#39; ``astype`` method.</span>

<span class="sd">    Example 4: You can also unpivot from wide to long using regular expressions</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">            n_1  n_2  n_3  pct_1  pct_2  pct_3</span>
<span class="sd">        0   10   20   30   0.1    0.2    0.3</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(</span>
<span class="sd">                  names_to = (&quot;.value&quot;, &quot;name&quot;),</span>
<span class="sd">                  names_pattern = &quot;(.*)_(.)&quot;</span>
<span class="sd">                  )</span>
<span class="sd">            )</span>

<span class="sd">            name    n  pct</span>
<span class="sd">        0     1  10.0  0.1</span>
<span class="sd">        1     2  20.0  0.2</span>
<span class="sd">        2     3  30.0  0.3</span>

<span class="sd">    The same idea of `.value` works here as well. Based on the capturing groups</span>
<span class="sd">    in the regex in `names_pattern`, we have two pairings --&gt;</span>
<span class="sd">    ``{&quot;.value&quot;:[&quot;n&quot;, &quot;pct&quot;], &quot;name&quot;:[1,2,3]}``. Just like in the previous</span>
<span class="sd">    example, the values associated with `.value` become new column names,</span>
<span class="sd">    while those not associated with `.value` become values in the new column</span>
<span class="sd">    ``name``.</span>

<span class="sd">    Note that there are no limits to the pairing; however, you can only have</span>
<span class="sd">    one `.value` in ``names_to``.</span>

<span class="sd">    Example 5: You can also pass a list/tuple of regular expressions that match</span>
<span class="sd">    specific patterns to ``names_pattern``, along with a list/tuple of new</span>
<span class="sd">    names to ``names_to``; this can come in handy if `.value` falls short:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">          GameID   Date	        Visitor	     Score_V	   Home	        Score_H</span>
<span class="sd">        0  1     9/10/2020   Houston Texans     20    Kansas City Chiefs   34</span>
<span class="sd">        1  2     9/13/2020   Seattle Seahawks   38    Atlanta Falcons      25</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(</span>
<span class="sd">                    [&#39;GameID&#39;,&#39;Date&#39;],</span>
<span class="sd">                    names_to=(&quot;Team&quot;,&quot;Score&quot;),</span>
<span class="sd">                    names_pattern=(&quot;^Visitor|Home&quot;, &quot;^Score&quot;))</span>
<span class="sd">            )</span>

<span class="sd">               GameID       Date              Team       Score</span>
<span class="sd">        0       1       9/10/2020      Houston Texans     20</span>
<span class="sd">        1       2       9/13/2020    Seattle Seahawks     38</span>
<span class="sd">        2       1       9/10/2020  Kansas City Chiefs     34</span>
<span class="sd">        3       2       9/13/2020     Atlanta Falcons     25</span>

<span class="sd">    Note that in the code above, the number of entries in both `names_to` and</span>
<span class="sd">    `names_pattern` must match. Essentially, what the code does is look for</span>
<span class="sd">    columns that start with `Visitor` or `Home` (using the regex supplied) and</span>
<span class="sd">    puts all the values associated with these columns under a new column name</span>
<span class="sd">    `Team`. It then looks for columns that start with `Score` and collate all</span>
<span class="sd">    the values associated with these columns to a single column named `Score`.</span>

<span class="sd">    You can also take advantage of `janitor.patterns` function,</span>
<span class="sd">    or the `select_columns` syntax,</span>
<span class="sd">    which allows selection of columns via a regular expression;</span>
<span class="sd">    this can come in handy if you have a lot of column names</span>
<span class="sd">    to pass to the `index` or `column_names`  parameters,</span>
<span class="sd">    and you do not wish to manually type them all.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">             name    wk1   wk2   wk3   wk4</span>
<span class="sd">        0    Alice     5     9    20    22</span>
<span class="sd">        1    Bob       7    11    17    33</span>
<span class="sd">        2    Carla     6    13    39    40</span>

<span class="sd">        df = (pd.DataFrame(...)</span>
<span class="sd">              .pivot_longer(index = janitor.patterns(&quot;^(?!wk)&quot;))</span>
<span class="sd">              )</span>

<span class="sd">             name   variable  value</span>
<span class="sd">        0   Alice      wk1      5</span>
<span class="sd">        1     Bob      wk1      7</span>
<span class="sd">        2   Carla      wk1      6</span>
<span class="sd">        3   Alice      wk2      9</span>
<span class="sd">        4     Bob      wk2     11</span>
<span class="sd">        5   Carla      wk2     13</span>
<span class="sd">        6   Alice      wk3     20</span>
<span class="sd">        7     Bob      wk3     17</span>
<span class="sd">        8   Carla      wk3     39</span>
<span class="sd">        9   Alice      wk4     22</span>
<span class="sd">        10    Bob      wk4     33</span>
<span class="sd">        11  Carla      wk4     40</span>

<span class="sd">    .. note:: Unpivoting a dataframe with MultiIndex columns, when</span>
<span class="sd">        either `names_sep` or `names_pattern` is provided is not</span>
<span class="sd">        supported.</span>


<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>
<span class="sd">        df = jn.pivot_longer(</span>
<span class="sd">            df = df,</span>
<span class="sd">            index = [column1, column2, ...],</span>
<span class="sd">            column_names = [column3, column4, ...],</span>
<span class="sd">            names_to = new_column_name,</span>
<span class="sd">            names_sep = string/regular expression,</span>
<span class="sd">            names_pattern = string/regular expression,</span>
<span class="sd">            values_to= new_column_name,</span>
<span class="sd">            column_level=None/int/str,</span>
<span class="sd">            sort_by_appearance = True/False,</span>
<span class="sd">            ignore_index = True/False,</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .pivot_longer(</span>
<span class="sd">                index = [column1, column2, ...],</span>
<span class="sd">                column_names = [column3, column4, ...],</span>
<span class="sd">                names_to = new_column_name,</span>
<span class="sd">                names_sep = string/regular expression,</span>
<span class="sd">                names_pattern = string/regular expression,</span>
<span class="sd">                values_to= new_column_name,</span>
<span class="sd">                column_level=None/int/str,</span>
<span class="sd">                sort_by_appearance = True/False,</span>
<span class="sd">                ignore_index = True/False,</span>
<span class="sd">            )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param index: Name(s) of columns to use as identifier variables.</span>
<span class="sd">        Should be either a single column name, or a list/tuple of</span>
<span class="sd">        column names. The `janitor.select_columns` syntax is supported here,</span>
<span class="sd">        allowing for flexible and dynamic column selection.</span>
<span class="sd">        Index should be a list of tuples if the columns are a MultiIndex.</span>
<span class="sd">    :param column_names: Name(s) of columns to unpivot. Should be either</span>
<span class="sd">        a single column name or a list/tuple of column names.</span>
<span class="sd">        The `janitor.select_columns` syntax is supported here,</span>
<span class="sd">        allowing for flexible and dynamic column selection.</span>
<span class="sd">        Column_names should be a list of tuples</span>
<span class="sd">        if the columns are a MultiIndex.</span>
<span class="sd">    :param names_to: Name of new column as a string that will contain</span>
<span class="sd">        what were previously the column names in `column_names`.</span>
<span class="sd">        The default is `variable` if no value is provided. It can</span>
<span class="sd">        also be a list/tuple of strings that will serve as new column</span>
<span class="sd">        names, if `name_sep` or `names_pattern` is provided.</span>
<span class="sd">        If `.value` is in `names_to`, new column names will be extracted</span>
<span class="sd">        from part of the existing column names and `values_to` will be</span>
<span class="sd">        replaced.</span>
<span class="sd">    :param names_sep: Determines how the column name is broken up, if</span>
<span class="sd">        `names_to` contains multiple values. It takes the same</span>
<span class="sd">        specification as pandas&#39; `str.split` method, and can be a string</span>
<span class="sd">        or regular expression. `names_sep` does not work with MultiIndex</span>
<span class="sd">        columns.</span>
<span class="sd">    :param names_pattern: Determines how the column name is broken up.</span>
<span class="sd">        It can be a regular expression containing matching groups (it takes</span>
<span class="sd">        the same specification as pandas&#39; `str.extract` method), or a</span>
<span class="sd">        list/tuple of regular expressions. If it is a single regex, the</span>
<span class="sd">        number of groups must match the length of ``names_to`` ( if the</span>
<span class="sd">        length of ``names_to`` is 3, then the number of groups must be 3.</span>
<span class="sd">        If ``names_to`` is a string, then there should be only one group</span>
<span class="sd">        in ``names_pattern``). For a list/tuple of regular expressions,</span>
<span class="sd">        ``names_to`` must also be a list/tuple and the lengths of both</span>
<span class="sd">        arguments must match(if the length of `names_to` is 4, then the</span>
<span class="sd">        length of `names_pattern` must also be 4). The entries in both</span>
<span class="sd">        arguments must also match positionally, i.e  if</span>
<span class="sd">        ``names_to = (&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;)``, then ``names_pattern``</span>
<span class="sd">        should be (&quot;regex1&quot;, &quot;regex2&quot;, &quot;regex3&quot;), with &quot;name1&quot; pairing</span>
<span class="sd">        &quot;regex1&quot;, &quot;name2&quot; pairing &quot;regex2&quot;, and &quot;name3&quot; pairing &quot;regex3&quot;.</span>
<span class="sd">        `names_pattern` does not work with MultiIndex columns.</span>
<span class="sd">    :param values_to: Name of new column as a string that will contain what</span>
<span class="sd">        were previously the values of the columns in `column_names`.</span>
<span class="sd">    :param column_level: If columns are a MultiIndex, then use this level to</span>
<span class="sd">        unpivot the dataframe. Provided for compatibility with pandas&#39; melt,</span>
<span class="sd">        and applies only if neither `names_sep` nor `names_pattern` is</span>
<span class="sd">        provided.</span>
<span class="sd">    :param sort_by_appearance: Default `False`. Boolean value that determines</span>
<span class="sd">        the final look of the dataframe. If `True`, the unpivoted dataframe</span>
<span class="sd">        will be stacked in order of first appearance. See examples for more</span>
<span class="sd">        details. `pivot_longer` is usually more performant if</span>
<span class="sd">        `sort_by_appearance` is ``False``.</span>
<span class="sd">    :param ignore_index: Default `True`. If True, original index is ignored.</span>
<span class="sd">        If False, the original index is retained and the Index labels will be</span>
<span class="sd">        repeated as necessary.</span>
<span class="sd">    :returns: A pandas DataFrame that has been unpivoted from wide to long</span>
<span class="sd">        format.</span>
<span class="sd">    :raises TypeError: if `index` or `column_names` is not a string, or a</span>
<span class="sd">        list/tuple of column names, or a `janitor.patterns` function.</span>
<span class="sd">    :raises TypeError: if `names_to` or `column_names` is not a string, or a</span>
<span class="sd">        list/tuple of strings.</span>
<span class="sd">    :raises TypeError: if `names_sep` is not a string or regular expression.</span>
<span class="sd">    :raises TypeError: if `names_pattern` is not a regular expression, or a</span>
<span class="sd">        list/tuple of regular expressions.</span>
<span class="sd">    :raises TypeError: if `values_to` is not a string.</span>
<span class="sd">    :raises TypeError: if `sort_by_appearance` is not a boolean.</span>
<span class="sd">    :raises TypeError: if `ignore_index` is not a boolean.</span>
<span class="sd">    :raises ValueError: if `names_to` is a string or a list/tuple of length 1,</span>
<span class="sd">        and `names_sep` is provided.</span>
<span class="sd">    :raises ValueError: if `names_to` is a string, and the number of extracted</span>
<span class="sd">        columns is greater than 1.</span>
<span class="sd">    :raises ValueError: if `names_to` is a list/tuple, and its length does not</span>
<span class="sd">        match the number of extracted columns.</span>
<span class="sd">    :raises ValueError: if the dataframe contains MultiIndex columns, and</span>
<span class="sd">        `index` or `column_names` is not a list of tuples.</span>
<span class="sd">    :raises ValueError: if the dataframe contains MultiIndex columns, and</span>
<span class="sd">        either `names_sep` or `names_pattern` is provided.</span>

<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># this code builds on the wonderful work of @benjaminjack’s PR</span>
    <span class="c1"># https://github.com/benjaminjack/pyjanitor/commit/e3df817903c20dd21634461c8a92aec137963ed0</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">column_names</span><span class="p">,</span>
        <span class="n">names_to</span><span class="p">,</span>
        <span class="n">values_to</span><span class="p">,</span>
        <span class="n">column_level</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">names_pattern</span><span class="p">,</span>
        <span class="n">sort_by_appearance</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_data_checks_pivot_longer</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">column_names</span><span class="p">,</span>
        <span class="n">names_to</span><span class="p">,</span>
        <span class="n">values_to</span><span class="p">,</span>
        <span class="n">column_level</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">names_pattern</span><span class="p">,</span>
        <span class="n">sort_by_appearance</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">_computations_pivot_longer</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">column_names</span><span class="p">,</span>
        <span class="n">names_to</span><span class="p">,</span>
        <span class="n">values_to</span><span class="p">,</span>
        <span class="n">column_level</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">names_pattern</span><span class="p">,</span>
        <span class="n">sort_by_appearance</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="pivot_wider"><a class="viewcode-back" href="../../reference/janitor.functions/janitor.pivot_wider.html#janitor.pivot_wider">[docs]</a><span class="nd">@pf</span><span class="o">.</span><span class="n">register_dataframe_method</span>
<span class="k">def</span> <span class="nf">pivot_wider</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_from</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">values_from</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_sort</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">flatten_levels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">names_from_position</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
    <span class="n">names_prefix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">names_sep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span>
    <span class="n">aggfunc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reshapes data from &#39;long&#39; to &#39;wide&#39; form.</span>

<span class="sd">    The number of columns are increased, while decreasing</span>
<span class="sd">    the number of rows. It is the inverse of the `pivot_longer`</span>
<span class="sd">    method, and is a wrapper around `pd.DataFrame.pivot` method.</span>

<span class="sd">    This method does not mutate the original DataFrame.</span>

<span class="sd">    Reshaping to wide form :</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">             name variable  value</span>
<span class="sd">        0   Alice      wk1      5</span>
<span class="sd">        1   Alice      wk2      9</span>
<span class="sd">        2   Alice      wk3     20</span>
<span class="sd">        3   Alice      wk4     22</span>
<span class="sd">        4     Bob      wk1      7</span>
<span class="sd">        5     Bob      wk2     11</span>
<span class="sd">        6     Bob      wk3     17</span>
<span class="sd">        7     Bob      wk4     33</span>
<span class="sd">        8   Carla      wk1      6</span>
<span class="sd">        9   Carla      wk2     13</span>
<span class="sd">        10  Carla      wk3     39</span>
<span class="sd">        11  Carla      wk4     40</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .pivot_wider(</span>
<span class="sd">                index = &quot;name&quot;,</span>
<span class="sd">                names_from = &quot;variable&quot;,</span>
<span class="sd">                values_from = &quot;value&quot;</span>
<span class="sd">            )</span>

<span class="sd">             name    wk1   wk2   wk3   wk4</span>
<span class="sd">        0    Alice     5     9    20    22</span>
<span class="sd">        1    Bob       7    11    17    33</span>
<span class="sd">        2    Carla     6    13    39    40</span>

<span class="sd">    Pivoting on multiple columns is possible :</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">            name    n  pct</span>
<span class="sd">        0     1  10.0  0.1</span>
<span class="sd">        1     2  20.0  0.2</span>
<span class="sd">        2     3  30.0  0.3</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .assign(num = 0)</span>
<span class="sd">            .pivot_wider(</span>
<span class="sd">                index = &quot;num&quot;,</span>
<span class="sd">                names_from = &quot;name&quot;,</span>
<span class="sd">                values_from = [&quot;n&quot;, &quot;pct&quot;],</span>
<span class="sd">                names_sep = &quot;_&quot;</span>
<span class="sd">             )</span>
<span class="sd">         )</span>

<span class="sd">            num n_1  n_2  n_3  pct_1  pct_2  pct_3</span>
<span class="sd">        0   0   10   20   30   0.1    0.2    0.3</span>

<span class="sd">    Aggregations are also possible with the ``aggfunc`` parameter::</span>

<span class="sd">        df = pd.DataFrame([{&#39;id&#39;: &#39;a&#39;, &#39;name&#39;: &#39;Adam&#39;, &#39;value&#39;: 5},</span>
<span class="sd">                           {&#39;id&#39;: &#39;b&#39;, &#39;name&#39;: &#39;Eve&#39;, &#39;value&#39;: 6},</span>
<span class="sd">                           {&#39;id&#39;: &#39;c&#39;, &#39;name&#39;: &#39;Adam&#39;, &#39;value&#39;: 4},</span>
<span class="sd">                           {&#39;id&#39;: &#39;a&#39;, &#39;name&#39;: &#39;Eve&#39;, &#39;value&#39;: 3},</span>
<span class="sd">                           {&#39;id&#39;: &#39;d&#39;, &#39;name&#39;: &#39;Seth&#39;, &#39;value&#39;: 2},</span>
<span class="sd">                           {&#39;id&#39;: &#39;b&#39;, &#39;name&#39;: &#39;Adam&#39;, &#39;value&#39;: 4},</span>
<span class="sd">                           {&#39;id&#39;: &#39;a&#39;, &#39;name&#39;: &#39;Adam&#39;, &#39;value&#39;: 2}])</span>

<span class="sd">        id  name    value</span>
<span class="sd">        a   Adam    5</span>
<span class="sd">        b   Eve     6</span>
<span class="sd">        c   Adam    4</span>
<span class="sd">        a   Eve     3</span>
<span class="sd">        d   Seth    2</span>
<span class="sd">        b   Adam    4</span>
<span class="sd">        a   Adam    2</span>

<span class="sd">        df.pivot_wider(</span>
<span class="sd">            index = &quot;id&quot;,</span>
<span class="sd">            names_from = &quot;name&quot;,</span>
<span class="sd">            aggfunc = np.sum,</span>
<span class="sd">            values_from = &quot;value&quot;,</span>
<span class="sd">            flatten_levels = True,</span>
<span class="sd">            fill_value = 0</span>
<span class="sd">            )</span>

<span class="sd">            id  Adam  Eve  Seth</span>
<span class="sd">        0   a     7    3     0</span>
<span class="sd">        1   b     4    6     0</span>
<span class="sd">        2   c     4    0     0</span>
<span class="sd">        3   d     0    0     2</span>


<span class="sd">    .. note:: You may choose not to collapse the levels by passing `False`</span>
<span class="sd">        to the ``flatten_levels`` argument.</span>

<span class="sd">    .. note:: A ValueError is raised if the index is not unique and</span>
<span class="sd">        `aggfunc` is None.</span>

<span class="sd">    Functional usage syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        import janitor as jn</span>

<span class="sd">        df = pd.DataFrame(...)</span>

<span class="sd">        df = jn.pivot_wider(</span>
<span class="sd">            df = df,</span>
<span class="sd">            index = [column1, column2, ...],</span>
<span class="sd">            names_from = [column3, column4, ...],</span>
<span class="sd">            value_from = [column5, column6, ...],</span>
<span class="sd">            names_sort = True/False,</span>
<span class="sd">            names_prefix = string,</span>
<span class="sd">            names_sep = string,</span>
<span class="sd">            flatten_levels = True/False,</span>
<span class="sd">            names_from_position = &quot;first&quot;/&quot;last&quot;,</span>
<span class="sd">            aggfunc,</span>
<span class="sd">            fill_value = fill_value</span>
<span class="sd">        )</span>

<span class="sd">    Method chaining syntax:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        df = (</span>
<span class="sd">            pd.DataFrame(...)</span>
<span class="sd">            .pivot_wider(</span>
<span class="sd">                index = [column1, column2, ...],</span>
<span class="sd">                names_from = [column3, column4, ...],</span>
<span class="sd">                value_from = [column5, column6, ...],</span>
<span class="sd">                names_sort = True/False,</span>
<span class="sd">                names_prefix = string,</span>
<span class="sd">                names_sep = string,</span>
<span class="sd">                flatten_levels = True/False,</span>
<span class="sd">                names_from_position = &quot;first&quot;/&quot;last&quot;,</span>
<span class="sd">                aggfunc,</span>
<span class="sd">                fill_value = fill_value</span>
<span class="sd">                )</span>
<span class="sd">        )</span>

<span class="sd">    :param df: A pandas dataframe.</span>
<span class="sd">    :param index: Name(s) of columns to use as identifier variables.</span>
<span class="sd">        Should be either a single column name, or a list of column names.</span>
<span class="sd">        The `janitor.select_columns` syntax is supported here,</span>
<span class="sd">        allowing for flexible and dynamic column selection.</span>
<span class="sd">        If `index` is not provided, the current dataframe&#39;s index is used.</span>
<span class="sd">    :param names_from: Name(s) of column(s) to use to make the new</span>
<span class="sd">        dataframe&#39;s columns. Should be either a single column name, or a</span>
<span class="sd">        list of column names.</span>
<span class="sd">        The `janitor.select_columns` syntax is supported here,</span>
<span class="sd">        allowing for flexible and dynamic column selection.</span>
<span class="sd">        A label or labels must be provided for ``names_from``.</span>
<span class="sd">    :param values_from: Name(s) of column(s) that will be used for populating</span>
<span class="sd">        the new dataframe&#39;s values. Should be either a single column name,</span>
<span class="sd">        or a list of column names.</span>
<span class="sd">        The `janitor.select_columns` syntax is supported here,</span>
<span class="sd">        allowing for flexible and dynamic column selection.</span>
<span class="sd">        If ``values_from`` is not specified,</span>
<span class="sd">        all remaining columns will be used. If `flatten_levels` is ``False``,</span>
<span class="sd">        a MultiIndex dataframe is created.</span>
<span class="sd">    :param names_sort: Default is `True`. Sorts columns by order of</span>
<span class="sd">        appearance.</span>
<span class="sd">        Set as `True` to get the columns sorted lexicographicially,</span>
<span class="sd">        or if the columns are of category type.</span>
<span class="sd">    :param flatten_levels: Default is `True`. If `False`, the dataframe stays</span>
<span class="sd">        as a MultiIndex.</span>
<span class="sd">    :param names_from_position: By default, the values in ``names_from`` stay</span>
<span class="sd">        at the front of the new column names. This can be changed to &quot;last&quot;;</span>
<span class="sd">        this places the values in ``names_from``</span>
<span class="sd">        at the tail of the column names.</span>
<span class="sd">    :param names_prefix: String to be added to the front of each output column.</span>
<span class="sd">        Can be handy if the values in ``names_from`` are numeric data types.</span>
<span class="sd">        Applicable only if ``flatten_levels`` is True.</span>
<span class="sd">    :param names_sep: If ``names_from`` or ``values_from`` contain multiple</span>
<span class="sd">        variables, this will be used to join their values into a single string</span>
<span class="sd">        to use as a column name. Default is ``_``.</span>
<span class="sd">        Applicable only if ``flatten_levels`` is ``True``.</span>
<span class="sd">    :param aggfunc: An aggregate function. It can be a function, a string,</span>
<span class="sd">        list of functions, or a dictionary, pairing column name with aggregate</span>
<span class="sd">        function.</span>
<span class="sd">    :param fill_value: Scalar value to replace missing values with</span>
<span class="sd">        (after pivoting).</span>
<span class="sd">    :returns: A pandas DataFrame that has been unpivoted from long to wide</span>
<span class="sd">        form.</span>
<span class="sd">    :raises TypeError: if `index` or `names_from` is not a string, or a list of</span>
<span class="sd">        strings.</span>
<span class="sd">    :raises ValueError: if `names_from` is None.</span>
<span class="sd">    :raises TypeError: if `names_sep` is not a string.</span>
<span class="sd">    :raises TypeError: if `values_from` is not a string or a list of strings.</span>
<span class="sd">    :raises TypeError: if `names_sort` is not a boolean.</span>
<span class="sd">    :raises TypeError: if `flatten_levels` is not a boolean.</span>
<span class="sd">    :raises ValueError: if values in `index` or `names_from` or `values_from`</span>
<span class="sd">        do not exist in the dataframe.</span>
<span class="sd">    :raises ValueError: if the combination of `index` and `names_from` is not</span>
<span class="sd">        unique and ``aggfunc`` is ``None``.</span>


<span class="sd">    .. # noqa: DAR402</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">names_from</span><span class="p">,</span>
        <span class="n">values_from</span><span class="p">,</span>
        <span class="n">names_sort</span><span class="p">,</span>
        <span class="n">flatten_levels</span><span class="p">,</span>
        <span class="n">names_from_position</span><span class="p">,</span>
        <span class="n">names_prefix</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">aggfunc</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_data_checks_pivot_wider</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">names_from</span><span class="p">,</span>
        <span class="n">values_from</span><span class="p">,</span>
        <span class="n">names_sort</span><span class="p">,</span>
        <span class="n">flatten_levels</span><span class="p">,</span>
        <span class="n">names_from_position</span><span class="p">,</span>
        <span class="n">names_prefix</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">aggfunc</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">_computations_pivot_wider</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">names_from</span><span class="p">,</span>
        <span class="n">values_from</span><span class="p">,</span>
        <span class="n">names_sort</span><span class="p">,</span>
        <span class="n">flatten_levels</span><span class="p">,</span>
        <span class="n">names_from_position</span><span class="p">,</span>
        <span class="n">names_prefix</span><span class="p">,</span>
        <span class="n">names_sep</span><span class="p">,</span>
        <span class="n">aggfunc</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo_title.svg" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Contributors</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, PyJanitor devs.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>